==模板：==

**题述：**



**示例 ：**

```

```

**框架：**

```c++

```

### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 一些函数的解释

## 1.begin()和end()函数

问得非常好！这是一个理解C++标准模板库（STL）核心概念的关键问题。

简单直接的回答是：`begin()` 和 `end()` 函数返回的是一种叫做 **迭代器（Iterator）** 的特殊对象。

你的直觉很准，迭代器的行为和思想**非常像指针**，但它是一个更通用、更抽象的概念。我们不能简单地说它就是地址或者指针。

### **深入理解迭代器 (Iterator)**

1. **它是什么？—— 一个“聪明的指针”**

   你可以把迭代器想象成一个“智能指针”或“泛化指针”。它被设计出来的目的就是为了提供一种**统一的**方式来遍历各种不同数据结构（如 `vector`, `set`, `unordered_set`, `map` 等）中的元素，而不需要程序员关心这些数据结构底层的实现细节。

   它封装了访问容器元素所需的所有逻辑。

2. **它能做什么？—— 像指针一样操作**

   一个迭代器最基本的操作和指针非常相似：

   - **解引用 (Dereferencing)**: 使用 `*` 操作符来获取迭代器当前指向的元素的值。例如：`*it`。
   - **递增 (Incrementing)**: 使用 `++` 操作符来将迭代器移动到容器中的下一个元素。例如：`it++` 或 `++it`。
   - **比较 (Comparison)**: 使用 `==` 或 `!=` 来判断两个迭代器是否指向同一个位置。这在循环中至关重要，用来判断是否到达了容器的末尾。

### **为什么它不“是”一个指针？**

这才是问题的核心。

- **对于 `vector`**：因为 `vector` 的内存在物理上是连续的（就像一个普通的C语言数组），所以它的迭代器**可能**就是一个封装了的普通指针。在这种情况下，`++it` 的底层操作可能真的只是把一个内存地址增加了 `sizeof(element)`。

- **对于 `unordered_set` (或 `set`, `list`, `map`)**：情况就完全不同了。

  - `unordered_set` 底层是**哈希表**，元素在内存中是**不连续存放的**，它们被散布在不同的“桶”里。
  - `set` 底层是**红黑树**，元素在内存中通过节点指针互相连接，也不是连续的。

  对于这些非连续存储的容器，一个简单的指针和内存地址是无法工作的。你不能通过给一个地址加一来找到树中的“下一个”节点或哈希表中的下一个有效元素。

  因此，`unordered_set` 的迭代器是一个**更复杂的对象（通常是一个小的 `class` 或 `struct`）**。这个对象内部维护了指向当前哈希表桶和桶内位置的信息。当你对它执行 `++` 操作时，它会执行一系列复杂的逻辑：比如先在当前桶的链表中移动，如果到了链表末尾，就去寻找下一个非空的桶。

  **这就是迭代器抽象的强大之处**：无论底层数据结构是数组、链表、树还是哈希表，你作为程序员都使用完全相同的 `*it`, `++it`, `it != container.end()` 语法来遍历它，完全屏蔽了底层的复杂性。

### **`begin()` 和 `end()` 的具体含义**

现在我们来精确定义这两个函数返回的迭代器：

- **`begin()`**
  - 它返回一个迭代器，指向容器中的**第一个元素**。
  - 你可以对 `begin()` 返回的迭代器进行解引用（`*`）来获得第一个元素的值（前提是容器不为空）。
- **`end()`**
  - 它返回一个迭代器，指向容器中**“尾端元素的后一个位置”**。
  - 这是一个非常重要的概念：`end()` **并不指向最后一个元素**。它指向一个不存在的、作为“哨兵”或“边界”的位置。
  - 因此，你**绝对不能**对 `end()` 返回的迭代器进行解引用（`*`），这样做是未定义行为，通常会导致程序崩溃。
  - `end()` 的唯一目的就是用来做比较，判断遍历是否结束。`for` 循环的条件 `it != result_set.end()` 的意思就是“只要我的迭代器还没有走到那个末尾的边界位置，就继续循环”。

### **可视化比喻**

想象一条街上有一排房子：

- **容器（`result_set`）**：就是整条街。
- **元素**：是街上的每一栋房子。
- **迭代器**：是你自己，一个可以在街上行走的人。
- **`result_set.begin()`**：返回一个指向“1号房子”的你。
- **`\*it`**：是指你当前站着的房子本身。
- **`++it`**：是指你从当前房子走到下一栋房子。
- **`result_set.end()`**：返回一个指向“街尾的尽头，最后一栋房子之后”的你。那个位置没有房子，它只是标志着街道的结束。

所以，在 `return vector<int>(result_set.begin(), result_set.end());` 这句代码中，它的意思是：“请创建一个新的 `vector`，把 `result_set` 这条街上从**1号房子**开始，一直到**街尾尽头之前**的所有房子，都复制到新的 `vector` 里去。”



## 2.insert()函数

在vector中：

```c++
vector<int> ret;
ret.push_back(num);
ret.insert(ret.end(), num);
```

在unordered_set：

```c++
unordered_set<int> ret;
ret.insert(num);
```

在unorder_map中：

```c++
unordered_map<int, int> ret;
ret.insert({nums[i], i})
ret[nums[i]] = i;
```

## 3.字符和字符串

和字符char相比较时，用单引号；和字符串string相比较时，用双引号

## 4.字符串find函数返回值

`std::string` 类中的 `find` 函数是用来在一个字符串中查找另一个子字符串的。它的返回值有两种情况：

1. **如果找到了**：它会返回子字符串**第一次出现位置的起始索引（下标）**。这个返回值的类型是 `size_t`，一个无符号整数。
2. **如果没找到**：它会返回一个特殊的值 `std::string::npos`。这是一个静态常量，它的值通常是无符号整数的最大值。你可以把它理解为一个特殊的“未找到”标记。



# 一.数组

## 1.1 二分查找

**题述：**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 ：**

```
示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 
提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
```

**框架：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        
    }
};
```

### 解题思路1：二分查找

**思路解析:**

![image-20250716180238469](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250716180238469.png)

**题解：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len1 = nums.size();
        int left = 0, right = len1 - 1;
        while(left <= right)
        {
            int mid = (right + left) / 2;
            int num = nums[mid];
            if(num == target)
            {
                return mid;
            }
            else if(num > target)
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$，这是因为，经过k次迭代后$2^k\approx n$,所以$k \approx log_n$
- 空间复杂度：$O(1)$



## 1.2 移除元素

**题述：**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**用户评测：**

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 **通过**。

**示例 ：**

```
示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

示例 2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
 
提示：
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

**框架：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        
    }
};
```

### 解题思路1：从头开始双指针

**思路解析:**

经典双指针，这题可以用swap，也可以直接让左面覆盖住右面

**题解：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //双指针
        int len1 = nums.size();
        int left = 0, right = 0;
        int k = 0;
        while(right < len1)
        {
            if(nums[right] != val)
            {
                swap(nums[left], nums[right]);//当然，这题也可以直接让nums[left] = nums[right]
                left++;
                k++;
            }
            right++;
        }
        return k;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.3 有序数组的平方

**题述：**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 ：**

```
示例 1：
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]

示例 2：
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
 

提示：
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 已按 非递减顺序 排序
```

**框架：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
       
    }
};
```

### 解题思路1：暴力解法，先平方后排序

**思路解析:**

先用for循环平方，再用sort排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums)
        {
            ans.push_back(num * num);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$，sort函数的时间复杂度都是$O(nlog_n)$
- 空间复杂度：$O(log_n)$



### 解题思路2：双指针

**思路解析:**

![image-20250717163350472](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250717163350472.png)

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        //双指针
        int len1 = nums.size();
        int neg = -1;
        for(int i = 0; i < len1; ++i)
        {
            if(nums[i] < 0)
            {
                neg = i;
            }else
            {
                break;
            }
        }

        vector<int> ans;
        int i = neg, j = neg + 1;
        while(i >= 0 || j < len1)
        {
            if(i < 0)
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }else if(j == len1)
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else if(nums[i] * nums[i] < nums[j] * nums[j])
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路3：头尾开始双指针

**思路解析:**

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

由于数组两头就是最大的选择之一，所以可以从两头开始排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int len1 = nums.size();
        int left = 0, right = len1 - 1, pos = len1 - 1;
        vector<int> ans(len1);	//这里一定要确定ans的大小，否则会报错
        while(left <= right)	//这里一定要相等，否则最后一个值会无法进入
        {
            if(nums[left] * nums[left] < nums[right] * nums[right])
            {
                ans[pos] = nums[right] * nums[right];
                pos--;
                right--;
            }else
            {
                ans[pos] = nums[left] * nums[left];
                pos--;
                left++;
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.4 长度最小的子数组

**题述：**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 ：**

```
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：
输入：target = 4, nums = [1,4,4]
输出：1

示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
```

**框架：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        
    }
};
```

### 解题思路1：滑动窗口

**思路解析:**

滑动窗口，使用min函数寻找最小的长度

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

**题解：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        if(n == 0)
        {
            return 0;
        }
        int ans = INT_MAX;	//这是最大值
        int start = 0, end = 0;
        int sum = 0;
        while(end < n)
        {
            sum += nums[end];
            while(sum >= target)
            {
                ans = min(ans, end - start + 1);	//选取最小的长度
                sum -= nums[start];
                ++start;
            }
            ++end;
        }
        return ans == INT_MAX ? 0 : ans;	//如果ans没变，则返回0；否则返回ans的值
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.5 螺旋矩阵(II)

**题述：**

给你一个正整数 `n` ，生成一个包含 `1` 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/spiraln.jpg)

```
示例 1：
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

示例 2：
输入：n = 1
输出：[[1]]
 
提示：
1 <= n <= 20
```

**框架：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        
    }
};
```

### 解题思路1：模拟

**思路解析:**

左闭右开

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220922102236.png)

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 1.6 区间和

**题述：**

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

**输入描述：**

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b > = a），直至文件结束。

**输出描述：**

输出每个指定区间内元素的总和。

**示例 ：**

```
输入：
5
1
2
3
4
5
0 1
1 3

输出：
3
9

提示信息
数据范围：
0 < n <= 100000
```

**框架：**

```c++
无，ACM框架
```

### 解题思路1：前缀和

**思路解析:**

前缀和

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627110604.png)

输出2~5之间的值：

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627111319.png)

**题解：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for(int i = 0; i < n; i++)
    {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }
    while(cin >> a >> b)
    {
        int sum;
        if(a == 0)
        {
            sum = p[b];
        }
        else
        {
            sum = p[b] - p[a - 1];
        }
        cout << sum << endl;
    }    
}
```

C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多：

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.7 开发商购买土地

**题目描述：**

```
在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 
现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 
注意：区块不可再分。
```

**输入描述：**

```
第一行输入两个正整数，代表 n 和 m。 
接下来的 n 行，每行输出 m 个正整数。
```

**输出描述：**

```
请输出一个整数，代表两个子区域内土地总价值之间的最小差距。
```

**输入示例：**

```
3 3
1 2 3
2 1 3
1 2 3
```

**输出示例：**

```
0
```

**提示信息：**

```
如果将区域按照如下方式划分：
1 2 | 3
2 1 | 3
1 2 | 3 
两个子区域内土地总价值之间的最小差距可以达到 0。
数据范围：
1 <= n, m <= 100；
n 和 m 不同时为 1。
```

### 解题思路1：嵌套for循环

**思路解析:**

正常解题即可

**题解：**

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0));
    //输入数值
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }
    int result = INT_MAX;
    int count = 0;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            count += vec[i][j];
            if(j == m - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }

    count = 0;
    for(int j = 0; j < m; j++)
    {
        for(int i = 0; i < n; i++)
        {
            count += vec[i][j];
            if(i == n - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }
    cout << result << endl;
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 总结



![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)



# 二.链表



## 2.1 移除链表元素

**题述：**

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

示例 2：
输入：head = [], val = 1
输出：[]

示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]
```

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        
    }
};
```

### 解题思路1：递归

**思路解析:**

递归的两个核心要素：

- 1.**递推关系：**如何将一个大问题分解成一个性质相同、但规模更小的小问题
- 2.**终止条件：**最小的子问题是什么，它的解是什么。这个条件用来结束无穷的自我调用

**题解：**

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //1.终止条件：这是递归的出口
        if(head == nullptr)
        {
            return head;
        }
        //2.递推关系：
        head->next = removeElements(head->next, val);
        //3.处理当前节点：如果相等，删除元素，并返回新的头节点；如果不相等,则返回head本身
        return head->val == val? head->next : head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$,其中 *n* 是链表的长度。递归过程中需要遍历链表一次。
- 空间复杂度：$O(n)$,其中 *n* 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 *n* 层。



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //防止头节点被删除后无法确定，所以这里使用哑节点
        struct ListNode* dummyHead = new ListNode(0, head);
        struct ListNode* temp = dummyHead;
        //为了防止空指针解引用导致程序崩溃
        while(temp->next != NULL)
        {
            if(temp->next->val == val)
            {
                temp->next = temp->next->next;
            }
            else
            {
                temp = temp->next;
            }
        }
        //返回头节点
        head = dummyHead->next;
        //记得释放new节点
        delete dummyHead;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 2.2 设计链表

**题述：**

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例 ：**

```
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
 

提示：
0 <= index, val <= 1000
请不要使用内置的 LinkedList 库。
调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。
```

**框架：**

```c++
class MyLinkedList {
public:
    MyLinkedList() {
        
    }
    
    int get(int index) {
        
    }
    
    void addAtHead(int val) {
        
    }
    
    void addAtTail(int val) {
        
    }
    
    void addAtIndex(int index, int val) {
        
    }
    
    void deleteAtIndex(int index) {
        
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 解题思路1：单链表

**思路解析:**

确定链表长度size和链表头节点head，在节点前确立虚拟头节点

**题解：**

```c++
/*
struct ListNode{
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next): val(x), next(next) {}
};
*/

class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if(index < 0 || index >= size)
        {
            return -1;
        }
        ListNode *cur = head;
        for(int i = 0; i <= index; i++)
        {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        index = max(0, index);
        size++;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;

    }
    
    void deleteAtIndex(int index) {
        if(index < 0 || index >= size)
        {
            return;
        }
        size--;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
public:
    int size;
    ListNode *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 $O(1)$，get 消耗 $O(index)$，addAtHead 消耗 $O(1)$，addAtTail 消耗$ O(n)$，其中 n 为链表当前长度，即 addAtHead，addAtTail 和 addAtIndex 已调用次数之和，addAtIndex 消耗 $O(index)$。

- 空间复杂度：所有函数的单次调用空间复杂度均为$ O(1)$，总体空间复杂度为$ O(n)$，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。

  



### 解题思路1：双链表

**思路解析:**



**题解：**

```c++
class MyLinkedList {
public:
    struct DLinkListNode{
        int val;
        DLinkListNode *prev, *next;
        DLinkListNode(int x): val(x), prev(nullptr), next(nullptr) {}
    };
    MyLinkedList() {
        this->size = 0;
        this->head = new DLinkListNode(0);
        this->tail = new DLinkListNode(0);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int index) {
        if(index >= size)
        {
            return -1;
        }
        DLinkListNode *curr;
        if(index + 1 < size - index)
        {
            curr = head;
            for(int i = 0; i <= index; i++)
            {
                curr = curr->next;
            }
        }else
        {
            curr = tail;
            for(int i = 0; i < size - index; i++)
            {
                curr = curr->prev;
            }
        }
        return curr->val;

    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev;
        }
        size++;
        DLinkListNode *toAdd = new DLinkListNode(val);
        toAdd->prev = pred;
        toAdd->next = succ;
        pred->next = toAdd;
        succ->prev = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if(index >= size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index - 1; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev->prev;
        }
        size--;
        DLinkListNode *p = pred->next;
        pred->next = succ;
        succ->prev = pred;
        delete p;
    }
public:
    int size;
    DLinkListNode *head;
    DLinkListNode *tail;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。

- 空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。






## 2.3 反转链表

**题述：**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 ：**

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

输入：head = [1,2]
输出：[2,1]

输入：head = []
输出：[]
```



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex1.jpg)



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex2.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

令后指针指向前即可

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *curr = head;
        while(curr)
        {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

回溯思路如图所示：

![image-20250805164527502](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805164527502.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        ListNode *newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;	//如果不指向空，可能在回溯的最后造成环链表
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 2.4 两两交换链表中的节点

**题述：**

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/swap_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

如图所示：

![image-20250731161817709](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250731161817709.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *temp = dummyNode;
        while(temp->next != nullptr && temp->next->next != nullptr)
        {
            ListNode *node1 = temp->next;
            ListNode *node2 = temp->next->next;
            temp->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            temp = node1;
        }
        ListNode *ans = dummyNode->next;
        delete dummyNode;
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

![image-20250805192330379](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805192330379.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || head->next)
        {
            return head;
        }
        ListNode *newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->head = head;
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 2.5 删除链表的倒数第N个结点

**题述：**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/remove_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        
    }
};
```

### 解题思路1：暴力迭代

**思路解析:**

先计算总体长度，然后再遍历到size-n处，删除即可

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.确定链表长度，设置为size
        int size = 0;
        ListNode *temp = head;
        while(temp != nullptr)
        {
            size++;
            temp = temp->next;
        }
        //2.设置哑节点,找出被删节点所在位置
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *p = dummyNode;
        for(int i = 0; i < size - n; i++)
        {
            p = p->next;
        }
        ListNode *toDelete = p->next;
        p->next = p->next->next;
        delete toDelete;
        //3.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路2：双指针

**思路解析:**

经典快慢指针

![p3](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/p3.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点和快慢指针
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *fast = dummyNode;
        ListNode *slow = dummyNode;
        //2.令快指针领先两个身位
        for(int i = 0; i < n; i++)
        {
            fast = fast->next;
        }
        //3.令快指针直到末尾，结束循环
        while(fast->next)
        {
            fast = fast->next;
            slow = slow->next;
        }
        //删除节点
        slow->next = slow->next->next;
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路3：栈

**思路解析:**

先入栈push()，再出栈pop()，再删除节点，然后返回头节点

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点
        ListNode *dummyNode = new ListNode(0, head);
        //2.设置栈
        stack<ListNode*> stk;
        ListNode *curr = dummyNode;
        //3.入栈
        while(curr)
        {
            stk.push(curr);
            curr = curr->next;
        }
        //4.出栈
        for(int i = 0; i < n; i++)
        {
            stk.pop();
        }
        //5.删除节点
        ListNode *prev = stk.top();
        ListNode *toDelete = prev->next;
        prev->next = prev->next->next;
        delete toDelete;
        //6.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



## 2.6 面试题 02.07.链表相交

**题述：**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/160_statement.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
    }
};
```

### 解题思路1：赛道追击

**思路解析:**

![image-20250807165922067](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250807165922067.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == nullptr || headB == nullptr)
        {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        while(pA != pB)
        {
            pA = pA == nullptr? headB: pA->next;
            pB = pB == nullptr? headA: pB->next;
        }
        return pA;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(1)$

### 解题思路2：确定长度

**思路解析:**

先确定长度，然后使最长的始终为len1，currA，最后从相同长度处开始比较

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //1.确定两个链表的长度
        int len1 = 0, len2 = 0;
        ListNode *currA = headA;
        ListNode *currB = headB;
        while(currA)
        {
            len1++;
            currA = currA->next;
        }
        while(currB)
        {
            len2++;
            currB = currB->next;
        }
        //2.使最长的为len1，currA
        currA = headA;
        currB = headB;
        if(len2 > len1)
        {
            swap(len1, len2);
            swap(currA,currB);
        }
        //3.从相同长度处开始循环
        int gap = len1 - len2;
        for(int i = 0; i < gap; i++)
        {
            currA = currA->next;
        }
        //4.如果有一位相等，那么就说明后面的已经相等，因为这是指针，遂返回即可
        while(currA != nullptr)
        {
            if(currA == currB)
            {
                return currA;
            }
            currA = currA->next;
            currB = currB->next;
        }
        //5.没有的话就返回空指针
        return nullptr;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(1)$





## 2.7 环形链表II

**题述：**

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/circularlinkedlist.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        
    }
};
```

### 解题思路1：快慢指针

**思路解析:**

公式推导如下：



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast != NULL && fast->next != NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(fast == slow)
            {
                ListNode *index1 = fast;
                ListNode *index2 = head;
                while(index1 != index2)
                {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return NULL;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



# 三.哈希表

哈希表的三种结构：

- 数组
- set(集合)
- map(映射)

set数据结构：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| ------------------ | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | $0(1)$     | $0(1)$     |

map数据结构：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| ------------------ | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | $0(1)$     | $0(1)$     |

## 3.1 有效的字母异位词

**题述：**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词。

**示例 ：**

```
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

提示:
1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母
 
进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
```

**框架：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        
    }
};
```

### 解题思路1：哈希表

**思路解析:**

建立26位的vector数组

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        vector<int> ans(26, 0);
        for(char ch: s)
        {
            ans[ch - 'a']++;
        }
        for(char ch: t)
        {
            ans[ch - 'a']--;
            if(ans[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(26)$



### 解题思路2：排序

**思路解析:**

使用sort函数排序

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(log_n)$





## 3.2 两个数组的交集

**题述：**

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。



**示例 ：**

```
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000
```

**框架：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

### 解题思路1：unordered_set

**思路解析:**

![set哈希法](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220707173513.png)

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for(int num: nums2)
        {
            if(nums_set.find(num) != nums_set.end())
            {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(n)$



### 解题思路2：排序+双指针

**思路解析:**

先排序，然后看值是否相等，相等的话就插入，否则就让小的那一位+1

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int len1 = nums1.size(), len2 = nums2.size();
        int index1 = 0, index2 = 0;
        vector<int> ret;
        while(index1 < len1 && index2 < len2)
        {
            int num1 = nums1[index1], num2 = nums2[index2];
            if(num1 == num2)
            {
                if(!ret.size() || num1 != ret.back())
                {
                    ret.push_back(num1);
                    //也可以改为这句：ret.insert(ret.end(), num1);
                }
                index1++;
                index2++;
            }
            else if(num1 < num2)
            {
                index1++;
            }else
            {
                index2++;
            }
        }
        return ret;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(mlog_m + nlog_n)$
- 空间复杂度：$O(log_m + log_n)$



## 3.3 快乐数

### 解题思路1：unordered_set

**思路解析:**

使用unordered_set的特性：无序但不可重复，查询效率快

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> ret;
        while(1)
        {
            int sum = getSum(n);
            if(sum == 1)
            {
                return true;
            }
            if(ret.find(sum) != ret.end())
            {
                return false;
            }
            else
            {
                ret.insert(sum);
            }
            n = sum;
        }
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(logn)$



### 解题思路2：快慢指针

**思路解析:**

如果最后不能到1，那么一定会陷入一个循环；如果最后能到1，fast还是会和slow相同

到1：

![fig1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig1.png)

陷入循环：

![fig2](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig2.png)

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n > 0)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = getSum(slow);
            fast = getSum(fast);
            fast = getSum(fast);
        }while(slow != fast);

        return slow == 1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(log_n)$
- 空间复杂度：$O(1)$





## 3.4 两数之和

### 解题思路1：哈希表

**思路解析:**

使用unorder_map哈希表插入寻找

**题解：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> ret;
        for(int i = 0; i < nums.size(); i++)
        {
            auto iter = ret.find(target - nums[i]);
            if(iter != ret.end())
            {
                return {iter->second, i};
            }
            ret.insert(pair<int, int>(nums[i], i));
            //也可改为 ret[nums[i]] = i;
            //ret.insert({nums[i], i});
        }
        return {};
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 3.5 四数相加II

### 解题思路1：分组+哈希表

**思路解析:**

先查看前两个数组的和，然后检查后两个数组的和

**题解：**

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> countAB;
        int ans = 0;
        for(int a: nums1)
        {
            for(int b: nums2)
            {
                countAB[a + b]++;
            }
        }
        for(int c: nums3)
        {
            for(int d: nums4)
            {
                //也可以改为：if(countAB.count(-c - d))
                if(countAB.find(0 - (c + d)) != countAB.end())
                {
                    ans += countAB[0 - (c + d)];
                }
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$



## 3.6 赎金信

### 解题思路1：vector哈希表

**思路解析:**

老套的vector哈希表

**题解：**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if(ransomNote.size() > magazine.length())
        {
            return false;
        }
        vector<int> cnt(26, 0);
        for(char ch: magazine)
        {
            cnt[ch - 'a']++;
        }
        for(char ch: ransomNote)
        {
            cnt[ch - 'a']--;
            if(cnt[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(26)$



## 3.7 三数之和

### 解题思路1：排序+双指针

**思路解析:**

先排序再循环寻找不重复的三元组

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] > 0)
            {
                //return result;
                break;	//最好用break，这样逻辑通顺
            }
            if(i > 0 && nums[i] == nums[i - 1])
            {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right)
            {
                if(nums[i] + nums[left] + nums[right] > 0) right--;
                else if(nums[i] + nums[left] + nums[right] < 0) left++;
                else
                {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while(right > left && nums[right] == nums[right - 1]) right--;
                    while(right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$



## 3.8 四数之和

### 解题思路1：排序+双指针

**思路解析:**

和三数之和差不多

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int k = 0; k < nums.size(); k++)
        {
            if(nums[k] > target && nums[k] >= 0)
            {
                break;
            }
            if(k > 0 && nums[k] == nums[k - 1])
            {
                continue;
            }
            for(int i = k + 1; i < nums.size(); i++)
            {
                if(nums[k] + nums[i] > target && nums[k] + nums[i] >= 0)
                {
                    break;
                }
                if(i > k + 1 && nums[i] == nums[i - 1])
                {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while(left < right)
                {
                    if((long) nums[k] + nums[i] + nums[left] + nums[right] > target) right--;
                    else if((long) nums[k] + nums[i] + nums[left] + nums[right] < target) left++;
                    else
                    {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        while(right > left && nums[right] == nums[right - 1]) right--;
                        while(right > left && nums[left] == nums[left + 1]) left++;
                        right--;
                        left++;
                    }
                }
            }


        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^3)$
- 空间复杂度：$O(1)$



# 四.字符串

## 4.1 反转字符串

### 解题思路1：双指针

**思路解析:**

经典双指针

**题解：**

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int len1 = s.size();
        int left = 0, right = len1 - 1;
        while(left < right)
        {
            char ch = s[left];
            s[left] = s[right];
            s[right] = ch;
            left++;
            right--;
        }
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.2 反转字符串II

### 解题思路1：模拟

**思路解析:**

如果没超出长度，正常反转；如果超出了长度，则反转到长度len1的字符串

**题解：**

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        int len1 = s.size();
        for(int i = 0; i < len1; i += 2 * k)
        {
            if(i + k < len1)
            {
                reverse(s.begin() + i, s.begin() + i + k);
            }else
            {
                //也可以写为： reverse(s.begin() + i, s.end());
                reverse(s.begin() + i, s.begin() + len1);
            }
        }
        return s;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.3 替换数字

### 解题思路1：先查数，在扩容

**思路解析:**

先查有几个数字，然后扩容到对应的长度，最后从后向前插入

**题解：**

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s;
    while(cin >> s)
    {
        int countNumber = 0;
        int len1 = s.size();
        for(int i = 0; i < len1; i++)
        {
            if(s[i] >= '0' && s[i] <= '9')
            {
                countNumber++; 
            } 
        }
        s.resize(len1 + countNumber * 5);
        int indexA = len1 - 1;
        int indexB = s.size() - 1;
        while(indexA >= 0)
        {
            if(s[indexA] >= '0' && s[indexA] <= '9')
            {
                s[indexB--] = 'r';
                s[indexB--] = 'e';
                s[indexB--] = 'b';
                s[indexB--] = 'm';
                s[indexB--] = 'u';
                s[indexB--] = 'n';
            }
            else
            {
                s[indexB--] = s[indexA];
            }
            indexA--;
        }
        cout << s << endl;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.4 反转字符串中的单词

### 解题思路1：去除空格+反转

**思路解析:**

先擦除多余空格，再反转所有单词，最后反转局部单词

**题解：**

```c++
class Solution {
public:
    //1.去除多余空格
    void removeExtraSpace(string &s)
    {
        int len1 = s.size();
        int left = 0, right = 0;
        while(right < len1)
        {
            if(s[right] != ' ')
            {
                while(s[right] != ' ' && right < len1)
                {
                    swap(s[left], s[right]);
                    left++;
                    right++;
                }
                //这里到末尾也要加上空格
                if(right <= len1)
                {
                    s[left] = ' ';
                    left++;
                }
            }
            right++;
        }
        s.resize(left + 1 - 2);
    }
    //2.在特定位置反转字符串，左闭右闭
    void reverseString(string &s, int start, int end)
    {
        for(int i = start, j = end; i < j; i++, j--)
        {
            swap(s[i], s[j]);
        }
    }

    string reverseWords(string s) {
        removeExtraSpace(s);
        reverseString(s, 0, s.size() - 1);
        //3.根据空格反转单词
        int start = 0;
        int len1 = s.size();
        for(int i = 0; i <= len1; i++)
        {
            //如果到末尾了，就要开始反转
            if(i == len1 || s[i] == ' ')
            {
                reverseString(s, start, i - 1);
                start = i + 1;
            }
        }
        return s;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.5 右旋字符串

### 解题思路1：reverse逆转

**思路解析:**

先全部逆转，再局部逆转

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20231106172058.png)

**题解：**

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
    int k;
    string s;
    while(cin >> k >> s)
    {
        //1.先让字符串全部反转
        reverse(s.begin(), s.end());
        //2.确定长度
        int len1 = s.size();
        //3.让前k个和，后len1 -k反转
        reverse(s.begin(), s.begin() + k);
        reverse(s.begin() + k, s.end());
        cout << s << endl;
    }
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 4.6 找出字符串中第一个匹配项的下标

### 解题思路1：双循环

**思路解析:**

两层循环

**题解：**

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int len1 = haystack.size();
        int len2 = needle.length();
        if(len1 < len2)
        {
            return -1;
        }
        for(int i = 0; i < len1; i++)
        {
            int k = i;
            for(int j = 0; j < len2; j++)
            {
                if(needle[j] == haystack[k])
                {
                    k++;
                }
            }
            if(k - i == len2)
            {
                return i;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n * m)$
- 空间复杂度：$O(1)$



### 解题思路2：KMP

**思路解析:**

首先，我构建了一个数组next，这个数组next[i]存放的值就代表了，从字符串开始0到字符串i处，最长相等前后缀的长度；

第二，我在对next数组赋值时，要用到i和j的定义，j代表了前缀尾，i代表了后缀尾，

第三，当s[i]和s[j]相等时，我对next[i]处进行赋值，代表了此次最长前后缀的长度，但是当s[i]和s[j]不相等时，我需要将j向后跳跃，而跳跃的意义就在于，我要寻找一个即是P1的前缀又是S1的后缀的一个字符串，由于P1与S1相同，所以也就是找一个既是P1的前缀又是P1的后缀的字符串，此时恰好满足了对于next数组的定义，所以j = next[j - 1]

**题解：**

```c++
class Solution {
public:
    //1.KMP算法的获得next数组函数
    void getNext(int *next, const string &s)
    {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++)
        {
            while(j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if(s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        int len1 = haystack.size(), len2 = needle.size();
        int next[len2];
        getNext(next, needle);
        int j = 0;
        for(int i = 0; i < len1; i++)
        {
            while(j > 0 && haystack[i] != needle[j])
            {
                j = next[j - 1];
            }
            if(haystack[i] == needle[j])
            {
                j++;
            }
            if(j == len2)
            {
                return i - len2 + 1;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(m)$



## 4.7 重复的子字符串

### 解题思路1：枚举

**思路解析:**

如果s[j] != s[j - i]，那么就退出并将判断置为false

**题解：**

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int len1 = s.size();
        for(int i = 1; i * 2 <= len1; i++)
        {
            if(len1 % i == 0)
            {
                bool match = true;
                for(int j = i; j < len1; j++)
                {
                    if(s[j] != s[j - i])
                    {
                        match = false;
                        break;
                    }
                }
                if(match)
                {
                    return true;
                }
            }
        }
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$



### 解题思路2：字符串匹配

**思路解析:**

先合并，再寻找是否有相等的

**题解：**

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();	//find函数返回的是：字符串出现时的第一个下标
    }
};
```

**复杂度分析** : 根据语言特性，时间与空间的复杂度会有差异

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路3：KMP

**思路解析:**



**题解：**

```c++
class Solution {
public:
    void getNext(int *next, const string &s)
    {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++)
        {
            while(j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if(s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        } 
    }

    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int len1 = s.size();
        int next[len1];
        getNext(next, s);
        if(next[len1 - 1] != 0 && (len1 %  (len1 - next[len1 - 1]) == 0)) return true;
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



# 五.栈与队列

## 5.1 用栈实现队列

### 解题思路1：双栈

**思路解析:**

使用双栈，一个作为出栈，一个作为入栈

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

**题解：**

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x);
        
    }
    
    int pop() {
        if(stOut.empty())
        {
            while(!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }
    
    int peek() {
        if(stOut.empty())
        {
            while(!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        return stOut.top();
    }
    
    bool empty() {
        return stOut.empty() && stIn.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(1)$
- 空间复杂度：$O(n)$





## 5.2 用队列实现栈

### 解题思路1：双队列

**思路解析:**

que1做为输入队列，que2做为输出队列，当输入值时，将que1的所有元素拷贝到que2，然后输出que1的最后一个元素，然后再将que2的元素返回到que1

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif)

**题解：**

```c++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

public:
    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }
    
    int pop() {
        int size = que1.size();
        size--;
        while(size)
        {
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int result = que1.front();
        que1.pop();
        que1 = que2;
        while(!que2.empty())
        {
            que2.pop();
        }
        return result;
    }
    
    int top() {
        int size = que1.size();
        size--;
        while(size)
        {
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int result = que1.front();
        que2.push(result);
        que1.pop();
        que1 = que2;
        while(!que2.empty())
        {
            que2.pop();
        }
        return result;
    }
    
    bool empty() {
        return que1.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：单队列

**思路解析:**

入队列时，先将前面的重新入一遍，即可达到栈的效果

**题解：**

```c++
class MyStack {
public:
    queue<int> que;
    MyStack() {
        
    }
    
    void push(int x) {
        int n = que.size();
        que.push(x);
        for(int i = 0; i < n; i++)
        {
            que.push(que.front());
            que.pop();
        }
    }
    
    int pop() {
        int res = que.front();
        que.pop();
        return res;
    }
    
    int top() {
        return que.front();
    }
    
    bool empty() {
        return que.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 5.3 有效的括号

### 解题思路1：栈+unordered_map哈希表

**思路解析:**

先构建哈希表，然后判断：此时如果输入的是左括号，则入栈；输入的是右括号：在栈里寻找此时的顶部对应的是否为相应的左括号，是的话出栈，不是或者栈为空就返回false

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif)

**题解：**

```c++
class Solution {
public:
    bool isValid(string s) {
        int len1 = s.size();
        if(len1 % 2)
        {
            return false;
        }

        unordered_map<char, char> pairs = {
            {'}', '{'},
            {']', '['},
            {')', '('}
        };

        stack<char> stk;
        for(char ch: s)
        {
            if(pairs.count(ch))	//如果在哈希表中找到了对应的键
            {
                if(stk.empty() || stk.top() != pairs[ch])
                {
                    return false;
                }
                stk.pop();
            }else
            {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：栈

**思路解析:**

一步一步比较即可

**题解：**

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.size() % 2 != 0) return false;
        stack<char> stk;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '(') stk.push(')');
            else if(s[i] == '[') stk.push(']');	//只用用''，不能用""
            else if(s[i] == '{') stk.push('}');
            else if(stk.empty() || s[i] != stk.top()) return false;
            else stk.pop();
        }
        return stk.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 5.4 删除字符串中的所有相邻重复项

### 解题思路1：stack栈

**思路解析:**

新建栈

**题解：**

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> stk;
        for(char ch: s)
        {
            if(!stk.empty() && ch == stk.top())
            {
                stk.pop();
            }else
            {
                stk.push(ch);
            }
        }
        string result = "";
        while(!stk.empty())
        {
            result += stk.top();
            stk.pop();
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：string栈

**思路解析:**

直接在string字符串上操作

**题解：**

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for(char ch: s)
        {
            if(result.empty() || ch != result.back())
            {
                result.push_back(ch);
                //result += ch; 也是可以的
            }else
            {
                result.pop_back();
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 5.5 逆波兰表达式求值

### 解题思路1：栈

**思路解析:**

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

**题解：**

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        //vector<string>代表了 tokens中的每个字符都是字符串，所以比较时要用双引号
        int len1 = tokens.size();
        stack<long long> stk;
        for(int i = 0; i < len1; i++)
        {
            //必须用双引号
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")
            {
                long long num1 = stk.top();
                stk.pop();
                long long num2 = stk.top();
                stk.pop();
                if(tokens[i] == "+") stk.push(num2 + num1);
                else if(tokens[i] == "-") stk.push(num2 - num1);
                else if(tokens[i] == "*") stk.push(num2 * num1);
                else if(tokens[i] == "/") stk.push(num2 / num1);
            }else
            {
                stk.push(stoll(tokens[i])); //stoll:将字符串转化为长整型的函数
            }
        }
        return stk.top();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 5.6 滑动窗口最大值

### 解题思路1：优先队列（后面在学）

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(n)$



### 解题思路2：单调队列

**思路解析:**

pop的时候只需要判断，pop的这个值是否在队列头部，是的话就pop，否则不需要

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif)

**题解：**

```c++
class Solution {
private:
    class MyQueue{
        public:
            deque<int> que;
            void pop(int value)
            {
                if(!que.empty() && value == que.front())
                {
                    que.pop_front();
                }
            }
            void push(int value)
            {
                while(!que.empty() && value > que.back())
                {
                    que.pop_back();
                }
                que.push_back(value);
            }
            int front()
            {
                return que.front();
            }

    };

public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for(int i = 0; i < k; i++)
        {
            que.push(nums[i]);
        }
        result.push_back(que.front());
        for(int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(k)$



## 5.7 前K个高频元素（后面学完了树再来看吧）

### 解题思路1：堆

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 六.二叉树

## 6.1 二叉树的前序遍历

中左右

### 解题思路1：递归

**思路解析:**

前序递归

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        } 
        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        preorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**

注意入栈的时候要遵守**中右左**的顺序，因为栈是先进后出

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            if(node->right) stk.push(node->right);
            if(node->left) stk.push(node->left);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.2 二叉树的后序遍历

左右中

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void postorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        }
        postorder(root->left, res);
        postorder(root->right, res);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        postorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

### 解题思路2：迭代

**思路解析:**

先按照中右左的顺序对res数据进行输入，最后将数组反转过来就是左右中的顺序

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            if(node->left) stk.push(node->left);
            if(node->right) stk.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.3 二叉树的中序遍历

左中右

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> res;
        TreeNode *curr = root;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                res.push_back(curr->val);
                curr = curr->right;
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.4 二叉树的层序遍历

### 解题思路1：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vec);	//由于每次循环都会清空vec这个数组，所以并不会产生重复插入
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：递归（后面在学）

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void order(TreeNode *root, vector<vector<int>> &result, int depth)
    {
        if(root == nullptr)
        {
            return;
        }
        if(result.size() == depth)
        {
            result.push_back(vector<int>());
        }
        result[depth].push_back(root->val);
        order(root->left, result, depth + 1);
        order(root->right, result, depth + 1);
    }

    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$





## 6.5 二叉树的层序遍历II

### 解题思路1：迭代

**思路解析:**

只需要加一句反转即可，reverse函数把vec当作单个元素来反转的

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vec);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.6 二叉树的右视图

### 解题思路1：层序遍历

**思路解析:**

依旧层序遍历

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size - 1; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            TreeNode *node = que.front();
            que.pop();
            res.push_back(node->val);
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.7 二叉树的层平均值

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        vector<double> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            double sum = 0;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(sum / size);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.8 N叉树的层序遍历

### 解题思路1：层序遍历

**思路解析:**

children指针数组可以用数组的方式调用

**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                vec.push_back(node->val);
                for(int i = 0; i < node->children.size(); i++)
                {
                    if(node->children[i]) que.push(node->children[i]);
                }
            }
            res.push_back(vec);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.9 在每个树行中找最大值

### 解题思路1：层序遍历

**思路解析:**

INT_MAX和max()函数

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            int maxNumber = INT_MIN;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                maxNumber = max(maxNumber, node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(maxNumber);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.10 填充每个节点的下一个右侧节点指针

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root == nullptr)
        {
            return nullptr;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                if(i < size - 1)
                {
                    node->next = que.front();
                }else
                {
                    node->next = nullptr;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.11 填充每个节点的下一个右侧节点指针II

### 解题思路1：层序遍历

**思路解析:**

和上一题一样的

**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root == nullptr)
        {
            return root;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                if(i < size - 1)
                {
                    node->next = que.front();
                }
                else
                {
                    node->next = nullptr;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 6.12 二叉树的最大深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        int depth = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i <size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth += 1;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：后序递归求高度

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getdepth(TreeNode *root)
    {
        if(root == nullptr)
        {
            return 0;
        }
        int leftdepth = getdepth(root->left);
        int rightdepth = getdepth(root->right);
        int depth = 1 + max(leftdepth, rightdepth);
        return depth;

    }

    int maxDepth(TreeNode* root) {
        return getdepth(root);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路3：前序递归求深度

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int result;
    void getdepth(TreeNode *node, int depth)
    {
        result = depth > result ? depth : result;
        if(node->left == nullptr && node->right == nullptr) return;

        if(node->left)
        {
            depth++;
            getdepth(node->left, depth);
            depth--;
        }
        if(node->right)
        {
            depth++;
            getdepth(node->right, depth);;
            depth--;
        }
        return;
    }

    int maxDepth(TreeNode* root) {
        result = 0;
        if(root == nullptr)
        {
            return 0;
        }
        getdepth(root, 1);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.13 二叉树的最小深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        int depth = 1;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left == nullptr && node->right == nullptr)
                {
                    return depth;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.14 翻转二叉树

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //1.层序遍历
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return root;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                swap(node->left, node->right);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：前序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //1.前序遍历
    void Traversal(TreeNode *root)
    {
        if(root == nullptr)
        {
            return;
        }
        swap(root->left, root->right);
        Traversal(root->left);
        Traversal(root->right);
    }
    TreeNode* invertTree(TreeNode* root) {
        Traversal(root);
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：前序迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //1.前序迭代
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return root;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            swap(node->left, node->right);
            //2.前序迭代先放入右侧指针
            if(node->right) stk.push(node->right);
            if(node->left) stk.push(node->left);
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.15 N叉树的前序遍历

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    //递归前序遍历:中左右
    void Traversal(Node *root, vector<int> &res)
    {
        //1.确定弹出条件
        if(root == nullptr)
        {
            return;
        }
        //2.按照中左右的顺序进行递归调用
        res.push_back(root->val);
        for(int i = 0; i < root->children.size(); i++)
        {
            Traversal(root->children[i], res);
        }
    }

    vector<int> preorder(Node* root) {
        vector<int> res;
        Traversal(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> preorder(Node* root) {
        //前序迭代遍历
        stack<Node*> stk;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            Node *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            int size = node->children.size();
            for(int i = size - 1; i >= 0; i--)
            {
                stk.push(node->children[i]);
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.16 N叉树的后续遍历

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    //后续遍历的递归：左右中
    void Traversal(Node *root, vector<int> &res)
    {
        //1.确定弹出条件
        if(root == nullptr)
        {
            return;
        }
        //2.根据左右中的顺序进行调用
        for(int i = 0; i < root->children.size(); i++)
        {
            Traversal(root->children[i], res);
        }
        res.push_back(root->val);
    }


    vector<int> postorder(Node* root) {
        vector<int> res;
        Traversal(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> postorder(Node* root) {
        //使用迭代后续遍历：左右中
        stack<Node*> stk;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            Node *node = stk.top();
            stk.pop();
            int size = node->children.size();
            for(int i = 0; i < size; i++)
            {
                stk.push(node->children[i]);
            }
            res.push_back(node->val);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.17 对称二叉树

### 解题思路1：后序递归

**思路解析:**

判断外侧节点和内测节点是否相等

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //使用递归：判断外侧节点和内测节点是否相同
    bool compare(TreeNode *left, TreeNode *right)
    {
        //1.出递归条件
        if(left == nullptr && right != nullptr) return false;
        else if(left != nullptr && right == nullptr) return false;
        else if(left == nullptr && right == nullptr) return true;
        else if(left->val != right->val) return false;
        //2.进入递归
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        return outside && inside;
    }

    bool isSymmetric(TreeNode* root) {
        bool result = compare(root->left, root->right);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：栈或队列的迭代

**思路解析:**

和上面的同理

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        //迭代
        stack<TreeNode*> stk;
        stk.push(root->left);
        stk.push(root->right);
        while(!stk.empty())
        {  
            //1.将前两个节点出栈，分别为右和左
            TreeNode *rightNode = stk.top();
            stk.pop();
            TreeNode *leftNode = stk.top();
            stk.pop();
            //2.判断两个节点是否相等，如果相同，那么继续，如果不同，返回false
            //2.1 如果有一个节点存在，一个节点不存在，那么返回false
            if(leftNode == nullptr && rightNode != nullptr) return false;
            else if(leftNode != nullptr && rightNode == nullptr) return false;
            //2.2 如果两个节点都不存在，那么跳出此次循环
            else if(leftNode == nullptr && rightNode == nullptr) continue;
            //2.2 如果两个节点都存在，但是值不同，那么返回false
            else if(leftNode->val != rightNode->val) return false;
            //2.3 如果两个节点都存在，值相同，那么继续
            //3.将子节点压栈
            stk.push(leftNode->left);
            stk.push(rightNode->right);
            stk.push(leftNode->right);
            stk.push(rightNode->left);

        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.18 完全二叉树的节点个数

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        int depth = 0;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        while(!que.empty())
        {
            TreeNode *node = que.front();
            que.pop();
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.19 N叉树的最大深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node*> que;
        int depth = 0;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                for(int j = 0; j < node->children.size(); j++)
                {
                    que.push(node->children[j]);
                }
            }
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.20 平衡二叉树

### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

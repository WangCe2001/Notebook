==模板：==

**题述：**



**示例 ：**

```

```

**框架：**

```c++

```

### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 一些函数的解释

## 1.begin()和end()函数

问得非常好！这是一个理解C++标准模板库（STL）核心概念的关键问题。

简单直接的回答是：`begin()` 和 `end()` 函数返回的是一种叫做 **迭代器（Iterator）** 的特殊对象。

你的直觉很准，迭代器的行为和思想**非常像指针**，但它是一个更通用、更抽象的概念。我们不能简单地说它就是地址或者指针。

### **深入理解迭代器 (Iterator)**

1. **它是什么？—— 一个“聪明的指针”**

   你可以把迭代器想象成一个“智能指针”或“泛化指针”。它被设计出来的目的就是为了提供一种**统一的**方式来遍历各种不同数据结构（如 `vector`, `set`, `unordered_set`, `map` 等）中的元素，而不需要程序员关心这些数据结构底层的实现细节。

   它封装了访问容器元素所需的所有逻辑。

2. **它能做什么？—— 像指针一样操作**

   一个迭代器最基本的操作和指针非常相似：

   - **解引用 (Dereferencing)**: 使用 `*` 操作符来获取迭代器当前指向的元素的值。例如：`*it`。
   - **递增 (Incrementing)**: 使用 `++` 操作符来将迭代器移动到容器中的下一个元素。例如：`it++` 或 `++it`。
   - **比较 (Comparison)**: 使用 `==` 或 `!=` 来判断两个迭代器是否指向同一个位置。这在循环中至关重要，用来判断是否到达了容器的末尾。

### **为什么它不“是”一个指针？**

这才是问题的核心。

- **对于 `vector`**：因为 `vector` 的内存在物理上是连续的（就像一个普通的C语言数组），所以它的迭代器**可能**就是一个封装了的普通指针。在这种情况下，`++it` 的底层操作可能真的只是把一个内存地址增加了 `sizeof(element)`。

- **对于 `unordered_set` (或 `set`, `list`, `map`)**：情况就完全不同了。

  - `unordered_set` 底层是**哈希表**，元素在内存中是**不连续存放的**，它们被散布在不同的“桶”里。
  - `set` 底层是**红黑树**，元素在内存中通过节点指针互相连接，也不是连续的。

  对于这些非连续存储的容器，一个简单的指针和内存地址是无法工作的。你不能通过给一个地址加一来找到树中的“下一个”节点或哈希表中的下一个有效元素。

  因此，`unordered_set` 的迭代器是一个**更复杂的对象（通常是一个小的 `class` 或 `struct`）**。这个对象内部维护了指向当前哈希表桶和桶内位置的信息。当你对它执行 `++` 操作时，它会执行一系列复杂的逻辑：比如先在当前桶的链表中移动，如果到了链表末尾，就去寻找下一个非空的桶。

  **这就是迭代器抽象的强大之处**：无论底层数据结构是数组、链表、树还是哈希表，你作为程序员都使用完全相同的 `*it`, `++it`, `it != container.end()` 语法来遍历它，完全屏蔽了底层的复杂性。

### **`begin()` 和 `end()` 的具体含义**

现在我们来精确定义这两个函数返回的迭代器：

- **`begin()`**
  - 它返回一个迭代器，指向容器中的**第一个元素**。
  - 你可以对 `begin()` 返回的迭代器进行解引用（`*`）来获得第一个元素的值（前提是容器不为空）。
- **`end()`**
  - 它返回一个迭代器，指向容器中**“尾端元素的后一个位置”**。
  - 这是一个非常重要的概念：`end()` **并不指向最后一个元素**。它指向一个不存在的、作为“哨兵”或“边界”的位置。
  - 因此，你**绝对不能**对 `end()` 返回的迭代器进行解引用（`*`），这样做是未定义行为，通常会导致程序崩溃。
  - `end()` 的唯一目的就是用来做比较，判断遍历是否结束。`for` 循环的条件 `it != result_set.end()` 的意思就是“只要我的迭代器还没有走到那个末尾的边界位置，就继续循环”。

### **可视化比喻**

想象一条街上有一排房子：

- **容器（`result_set`）**：就是整条街。
- **元素**：是街上的每一栋房子。
- **迭代器**：是你自己，一个可以在街上行走的人。
- **`result_set.begin()`**：返回一个指向“1号房子”的你。
- **`\*it`**：是指你当前站着的房子本身。
- **`++it`**：是指你从当前房子走到下一栋房子。
- **`result_set.end()`**：返回一个指向“街尾的尽头，最后一栋房子之后”的你。那个位置没有房子，它只是标志着街道的结束。

所以，在 `return vector<int>(result_set.begin(), result_set.end());` 这句代码中，它的意思是：“请创建一个新的 `vector`，把 `result_set` 这条街上从**1号房子**开始，一直到**街尾尽头之前**的所有房子，都复制到新的 `vector` 里去。”



# 一.数组

## 1.1 二分查找

**题述：**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 ：**

```
示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 
提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
```

**框架：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        
    }
};
```

### 解题思路1：二分查找

**思路解析:**

![image-20250716180238469](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250716180238469.png)

**题解：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len1 = nums.size();
        int left = 0, right = len1 - 1;
        while(left <= right)
        {
            int mid = (right + left) / 2;
            int num = nums[mid];
            if(num == target)
            {
                return mid;
            }
            else if(num > target)
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$，这是因为，经过k次迭代后$2^k\approx n$,所以$k \approx log_n$
- 空间复杂度：$O(1)$



## 1.2 移除元素

**题述：**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**用户评测：**

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 **通过**。

**示例 ：**

```
示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

示例 2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
 
提示：
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

**框架：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        
    }
};
```

### 解题思路1：从头开始双指针

**思路解析:**

经典双指针，这题可以用swap，也可以直接让左面覆盖住右面

**题解：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //双指针
        int len1 = nums.size();
        int left = 0, right = 0;
        int k = 0;
        while(right < len1)
        {
            if(nums[right] != val)
            {
                swap(nums[left], nums[right]);//当然，这题也可以直接让nums[left] = nums[right]
                left++;
                k++;
            }
            right++;
        }
        return k;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.3 有序数组的平方

**题述：**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 ：**

```
示例 1：
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]

示例 2：
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
 

提示：
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 已按 非递减顺序 排序
```

**框架：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
       
    }
};
```

### 解题思路1：暴力解法，先平方后排序

**思路解析:**

先用for循环平方，再用sort排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums)
        {
            ans.push_back(num * num);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$，sort函数的时间复杂度都是$O(nlog_n)$
- 空间复杂度：$O(log_n)$



### 解题思路2：双指针

**思路解析:**

![image-20250717163350472](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250717163350472.png)

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        //双指针
        int len1 = nums.size();
        int neg = -1;
        for(int i = 0; i < len1; ++i)
        {
            if(nums[i] < 0)
            {
                neg = i;
            }else
            {
                break;
            }
        }

        vector<int> ans;
        int i = neg, j = neg + 1;
        while(i >= 0 || j < len1)
        {
            if(i < 0)
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }else if(j == len1)
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else if(nums[i] * nums[i] < nums[j] * nums[j])
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路3：头尾开始双指针

**思路解析:**

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

由于数组两头就是最大的选择之一，所以可以从两头开始排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int len1 = nums.size();
        vector<int> ans(len1);
        for(int i = 0, j = len1 - 1, pos = len1 - 1; i <= j;)
        {
            if(nums[j] * nums[j] > nums[i] * nums[i])
            {
                ans[pos] = nums[j] * nums[j];
                j--;
            }
            else
            {
                ans[pos] = nums[i] * nums[i];
                i++;
            }
            --pos;
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.4 长度最小的子数组

**题述：**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 ：**

```
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：
输入：target = 4, nums = [1,4,4]
输出：1

示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
```

**框架：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        
    }
};
```

### 解题思路1：滑动窗口

**思路解析:**

滑动窗口，使用min函数寻找最小的长度

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

**题解：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        if(n == 0)
        {
            return 0;
        }
        int ans = INT_MAX;	//这是最大值
        int start = 0, end = 0;
        int sum = 0;
        while(end < n)
        {
            sum += nums[end];
            while(sum >= target)
            {
                ans = min(ans, end - start + 1);	//选取最小的长度
                sum -= nums[start];
                ++start;
            }
            ++end;
        }
        return ans == INT_MAX ? 0 : ans;	//如果ans没变，则返回0；否则返回ans的值
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.5 螺旋矩阵(II)

**题述：**

给你一个正整数 `n` ，生成一个包含 `1` 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/spiraln.jpg)

```
示例 1：
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

示例 2：
输入：n = 1
输出：[[1]]
 
提示：
1 <= n <= 20
```

**框架：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        
    }
};
```

### 解题思路1：模拟

**思路解析:**

左闭右开

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220922102236.png)

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 1.6 区间和

**题述：**

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

**输入描述：**

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b > = a），直至文件结束。

**输出描述：**

输出每个指定区间内元素的总和。

**示例 ：**

```
输入：
5
1
2
3
4
5
0 1
1 3

输出：
3
9

提示信息
数据范围：
0 < n <= 100000
```

**框架：**

```c++
无，ACM框架
```

### 解题思路1：前缀和

**思路解析:**

前缀和

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627110604.png)

输出2~5之间的值：

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627111319.png)

**题解：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for(int i = 0; i < n; i++)
    {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }
    while(cin >> a >> b)
    {
        int sum;
        if(a == 0)
        {
            sum = p[b];
        }
        else
        {
            sum = p[b] - p[a - 1];
        }
        cout << sum << endl;
    }    
}
```

C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多：

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.7 开发商购买土地

**题目描述：**

```
在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 
现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 
注意：区块不可再分。
```

**输入描述：**

```
第一行输入两个正整数，代表 n 和 m。 
接下来的 n 行，每行输出 m 个正整数。
```

**输出描述：**

```
请输出一个整数，代表两个子区域内土地总价值之间的最小差距。
```

**输入示例：**

```
3 3
1 2 3
2 1 3
1 2 3
```

**输出示例：**

```
0
```

**提示信息：**

```
如果将区域按照如下方式划分：
1 2 | 3
2 1 | 3
1 2 | 3 
两个子区域内土地总价值之间的最小差距可以达到 0。
数据范围：
1 <= n, m <= 100；
n 和 m 不同时为 1。
```

### 解题思路1：嵌套for循环

**思路解析:**

正常解题即可

**题解：**

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0));
    //输入数值
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }
    int result = INT_MAX;
    int count = 0;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            count += vec[i][j];
            if(j == m - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }

    count = 0;
    for(int j = 0; j < m; j++)
    {
        for(int i = 0; i < n; i++)
        {
            count += vec[i][j];
            if(i == n - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }
    cout << result << endl;
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 总结



![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)



# 二.链表



## 2.1 移除链表元素

**题述：**

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

示例 2：
输入：head = [], val = 1
输出：[]

示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]
```

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        
    }
};
```

### 解题思路1：递归

**思路解析:**

递归的两个核心要素：

- 1.**递推关系：**如何将一个大问题分解成一个性质相同、但规模更小的小问题
- 2.**终止条件：**最小的子问题是什么，它的解是什么。这个条件用来结束无穷的自我调用

**题解：**

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //1.终止条件：这是递归的出口
        if(head == nullptr)
        {
            return head;
        }
        //2.递推关系：
        head->next = removeElements(head->next, val);
        //3.处理当前节点：如果相等，删除元素，并返回新的头节点；如果不相等,则返回head本身
        return head->val == val? head->next : head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$,其中 *n* 是链表的长度。递归过程中需要遍历链表一次。
- 空间复杂度：$O(n)$,其中 *n* 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 *n* 层。



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //防止头节点被删除后无法确定，所以这里使用哑节点
        struct ListNode* dummyHead = new ListNode(0, head);
        struct ListNode* temp = dummyHead;
        //为了防止空指针解引用导致程序崩溃
        while(temp->next != NULL)
        {
            if(temp->next->val == val)
            {
                temp->next = temp->next->next;
            }
            else
            {
                temp = temp->next;
            }
        }
        //返回头节点
        head = dummyHead->next;
        //记得释放new节点
        delete dummyHead;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 2.2 设计链表

**题述：**

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例 ：**

```
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
 

提示：
0 <= index, val <= 1000
请不要使用内置的 LinkedList 库。
调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。
```

**框架：**

```c++
class MyLinkedList {
public:
    MyLinkedList() {
        
    }
    
    int get(int index) {
        
    }
    
    void addAtHead(int val) {
        
    }
    
    void addAtTail(int val) {
        
    }
    
    void addAtIndex(int index, int val) {
        
    }
    
    void deleteAtIndex(int index) {
        
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 解题思路1：单链表

**思路解析:**

确定链表长度size和链表头节点head，在节点前确立虚拟头节点

**题解：**

```c++
/*
struct ListNode{
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next): val(x), next(next) {}
};
*/

class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if(index < 0 || index >= size)
        {
            return -1;
        }
        ListNode *cur = head;
        for(int i = 0; i <= index; i++)
        {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        index = max(0, index);
        size++;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;

    }
    
    void deleteAtIndex(int index) {
        if(index < 0 || index >= size)
        {
            return;
        }
        size--;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
public:
    int size;
    ListNode *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 $O(1)$，get 消耗 $O(index)$，addAtHead 消耗 $O(1)$，addAtTail 消耗$ O(n)$，其中 n 为链表当前长度，即 addAtHead，addAtTail 和 addAtIndex 已调用次数之和，addAtIndex 消耗 $O(index)$。

- 空间复杂度：所有函数的单次调用空间复杂度均为$ O(1)$，总体空间复杂度为$ O(n)$，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。

  



### 解题思路1：双链表

**思路解析:**



**题解：**

```c++
class MyLinkedList {
public:
    struct DLinkListNode{
        int val;
        DLinkListNode *prev, *next;
        DLinkListNode(int x): val(x), prev(nullptr), next(nullptr) {}
    };
    MyLinkedList() {
        this->size = 0;
        this->head = new DLinkListNode(0);
        this->tail = new DLinkListNode(0);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int index) {
        if(index >= size)
        {
            return -1;
        }
        DLinkListNode *curr;
        if(index + 1 < size - index)
        {
            curr = head;
            for(int i = 0; i <= index; i++)
            {
                curr = curr->next;
            }
        }else
        {
            curr = tail;
            for(int i = 0; i < size - index; i++)
            {
                curr = curr->prev;
            }
        }
        return curr->val;

    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev;
        }
        size++;
        DLinkListNode *toAdd = new DLinkListNode(val);
        toAdd->prev = pred;
        toAdd->next = succ;
        pred->next = toAdd;
        succ->prev = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if(index >= size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index - 1; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev->prev;
        }
        size--;
        DLinkListNode *p = pred->next;
        pred->next = succ;
        succ->prev = pred;
        delete p;
    }
public:
    int size;
    DLinkListNode *head;
    DLinkListNode *tail;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。

- 空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。






## 2.3 反转链表

**题述：**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 ：**

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

输入：head = [1,2]
输出：[2,1]

输入：head = []
输出：[]
```



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex1.jpg)



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex2.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

令后指针指向前即可

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *curr = head;
        while(curr)
        {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

回溯思路如图所示：

![image-20250805164527502](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805164527502.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        ListNode *newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;	//如果不指向空，可能在回溯的最后造成环链表
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 2.4 两两交换链表中的节点

**题述：**

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/swap_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

如图所示：

![image-20250731161817709](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250731161817709.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *temp = dummyNode;
        while(temp->next != nullptr && temp->next->next != nullptr)
        {
            ListNode *node1 = temp->next;
            ListNode *node2 = temp->next->next;
            temp->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            temp = node1;
        }
        ListNode *ans = dummyNode->next;
        delete dummyNode;
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

![image-20250805192330379](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805192330379.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || head->next)
        {
            return head;
        }
        ListNode *newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->head = head;
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 2.5 删除链表的倒数第N个结点

**题述：**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/remove_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        
    }
};
```

### 解题思路1：暴力迭代

**思路解析:**

先计算总体长度，然后再遍历到size-n处，删除即可

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.确定链表长度，设置为size
        int size = 0;
        ListNode *temp = head;
        while(temp != nullptr)
        {
            size++;
            temp = temp->next;
        }
        //2.设置哑节点,找出被删节点所在位置
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *p = dummyNode;
        for(int i = 0; i < size - n; i++)
        {
            p = p->next;
        }
        ListNode *toDelete = p->next;
        p->next = p->next->next;
        delete toDelete;
        //3.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路2：双指针

**思路解析:**

经典快慢指针

![p3](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/p3.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点和快慢指针
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *fast = dummyNode;
        ListNode *slow = dummyNode;
        //2.令快指针领先两个身位
        for(int i = 0; i < n; i++)
        {
            fast = fast->next;
        }
        //3.令快指针直到末尾，结束循环
        while(fast->next)
        {
            fast = fast->next;
            slow = slow->next;
        }
        //删除节点
        slow->next = slow->next->next;
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路3：栈

**思路解析:**

先入栈push()，再出栈pop()，再删除节点，然后返回头节点

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点
        ListNode *dummyNode = new ListNode(0, head);
        //2.设置栈
        stack<ListNode*> stk;
        ListNode *curr = dummyNode;
        //3.入栈
        while(curr)
        {
            stk.push(curr);
            curr = curr->next;
        }
        //4.出栈
        for(int i = 0; i < n; i++)
        {
            stk.pop();
        }
        //5.删除节点
        ListNode *prev = stk.top();
        ListNode *toDelete = prev->next;
        prev->next = prev->next->next;
        delete toDelete;
        //6.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



## 2.6 面试题 02.07.链表相交

**题述：**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/160_statement.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
    }
};
```

### 解题思路1：赛道追击

**思路解析:**

![image-20250807165922067](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250807165922067.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == nullptr || headB == nullptr)
        {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        while(pA != pB)
        {
            pA = pA == nullptr? headB: pA->next;
            pB = pB == nullptr? headA: pB->next;
        }
        return pA;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(1)$

### 解题思路2：确定长度

**思路解析:**

先确定长度，然后使最长的始终为len1，currA，最后从相同长度处开始比较

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //1.确定两个链表的长度
        int len1 = 0, len2 = 0;
        ListNode *currA = headA;
        ListNode *currB = headB;
        while(currA)
        {
            len1++;
            currA = currA->next;
        }
        while(currB)
        {
            len2++;
            currB = currB->next;
        }
        //2.使最长的为len1，currA
        currA = headA;
        currB = headB;
        if(len2 > len1)
        {
            swap(len1, len2);
            swap(currA,currB);
        }
        //3.从相同长度处开始循环
        int gap = len1 - len2;
        for(int i = 0; i < gap; i++)
        {
            currA = currA->next;
        }
        //4.如果有一位相等，那么就说明后面的已经相等，因为这是指针，遂返回即可
        while(currA != nullptr)
        {
            if(currA == currB)
            {
                return currA;
            }
            currA = currA->next;
            currB = currB->next;
        }
        //5.没有的话就返回空指针
        return nullptr;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(1)$





## 2.7 环形链表II

**题述：**

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/circularlinkedlist.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        
    }
};
```

### 解题思路1：快慢指针

**思路解析:**

公式推导如下：



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast != NULL && fast->next != NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(fast == slow)
            {
                ListNode *index1 = fast;
                ListNode *index2 = head;
                while(index1 != index2)
                {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return NULL;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



# 三.哈希表

哈希表的三种结构：

- 数组
- set(集合)
- map(映射)

set数据结构：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| ------------------ | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | $0(1)$     | $0(1)$     |



## 3.1 有效的字母异位词

**题述：**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词。

**示例 ：**

```
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

提示:
1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母
 
进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
```

**框架：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        
    }
};
```

### 解题思路1：哈希表

**思路解析:**

建立26位的vector数组

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        vector<int> ans(26, 0);
        for(char ch: s)
        {
            ans[ch - 'a']++;
        }
        for(char ch: t)
        {
            ans[ch - 'a']--;
            if(ans[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(26)$



### 解题思路2：排序

**思路解析:**

使用sort函数排序

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(log_n)$





## 3.2 两个数组的交集

**题述：**

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。



**示例 ：**

```
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000
```

**框架：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

### 解题思路1：unordered_set

**思路解析:**

![set哈希法](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220707173513.png)

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for(int num: nums2)
        {
            if(nums_set.find(num) != nums_set.end())
            {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(n)$



### 解题思路2：排序+双指针

**思路解析:**

先排序，然后看值是否相等，相等的话就插入，否则就让小的那一位+1

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int len1 = nums1.size(), len2 = nums2.size();
        int index1 = 0, index2 = 0;
        vector<int> ret;
        while(index1 < len1 && index2 < len2)
        {
            int num1 = nums1[index1], num2 = nums2[index2];
            if(num1 == num2)
            {
                if(!ret.size() || num1 != ret.back())
                {
                    ret.push_back(num1);
                    //也可以改为这句：ret.insert(ret.end(), num1);
                }
                index1++;
                index2++;
            }
            else if(num1 < num2)
            {
                index1++;
            }else
            {
                index2++;
            }
        }
        return ret;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(mlog_m + nlog_n)$
- 空间复杂度：$O(log_m + log_n)$



## 3.3 快乐数

### 解题思路1：unordered_set

**思路解析:**

使用unordered_set的特性：无序但不可重复，查询效率快

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> ret;
        while(1)
        {
            int sum = getSum(n);
            if(sum == 1)
            {
                return true;
            }
            if(ret.find(sum) != ret.end())
            {
                return false;
            }
            else
            {
                ret.insert(sum);
            }
            n = sum;
        }
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(logn)$



### 解题思路2：快慢指针

**思路解析:**

如果最后不能到1，那么一定会陷入一个循环；如果最后能到1，fast还是会和slow相同

到1：

![fig1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig1.png)

陷入循环：

![fig2](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig2.png)

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n > 0)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = getSum(slow);
            fast = getSum(fast);
            fast = getSum(fast);
        }while(slow != fast);

        return slow == 1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(log_n)$
- 空间复杂度：$O(1)$





## 3.4 两数之和

### 解题思路1：哈希表

**思路解析:**

使用unorder_map哈希表插入寻找

**题解：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> ret;
        for(int i = 0; i < nums.size(); i++)
        {
            auto iter = ret.find(target - nums[i]);
            if(iter != ret.end())
            {
                return {iter->second, i};
            }
            ret.insert(pair<int, int>(nums[i], i));
            //也可改为 ret[nums[i]] = i;
            //ret.insert({nums[i], i});
        }
        return {};
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 3.5 四数相加II

### 解题思路1：分组+哈希表

**思路解析:**

先查看前两个数组的和，然后检查后两个数组的和

**题解：**

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> countAB;
        int ans = 0;
        for(int a: nums1)
        {
            for(int b: nums2)
            {
                countAB[a + b]++;
            }
        }
        for(int c: nums3)
        {
            for(int d: nums4)
            {
                //也可以改为：if(countAB.count(-c - d))
                if(countAB.find(0 - (c + d)) != countAB.end())
                {
                    ans += countAB[0 - (c + d)];
                }
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$



## 3.6 赎金信

### 解题思路1：哈希表

**思路解析:**



**题解：**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if(ransomNote.size() > magazine.length())
        {
            return false;
        }
        vector<int> cnt(26, 0);
        for(char ch: magazine)
        {
            cnt[ch - 'a']++;
        }
        for(char ch: ransomNote)
        {
            cnt[ch - 'a']--;
            if(cnt[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(26)$

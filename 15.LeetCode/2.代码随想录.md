==模板：==

**题述：**



**示例 ：**

```

```

**框架：**

```c++

```

### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 一些函数的解释

## 1.begin()和end()函数

问得非常好！这是一个理解C++标准模板库（STL）核心概念的关键问题。

简单直接的回答是：`begin()` 和 `end()` 函数返回的是一种叫做 **迭代器（Iterator）** 的特殊对象。

你的直觉很准，迭代器的行为和思想**非常像指针**，但它是一个更通用、更抽象的概念。我们不能简单地说它就是地址或者指针。

### **深入理解迭代器 (Iterator)**

1. **它是什么？—— 一个“聪明的指针”**

   你可以把迭代器想象成一个“智能指针”或“泛化指针”。它被设计出来的目的就是为了提供一种**统一的**方式来遍历各种不同数据结构（如 `vector`, `set`, `unordered_set`, `map` 等）中的元素，而不需要程序员关心这些数据结构底层的实现细节。

   它封装了访问容器元素所需的所有逻辑。

2. **它能做什么？—— 像指针一样操作**

   一个迭代器最基本的操作和指针非常相似：

   - **解引用 (Dereferencing)**: 使用 `*` 操作符来获取迭代器当前指向的元素的值。例如：`*it`。
   - **递增 (Incrementing)**: 使用 `++` 操作符来将迭代器移动到容器中的下一个元素。例如：`it++` 或 `++it`。
   - **比较 (Comparison)**: 使用 `==` 或 `!=` 来判断两个迭代器是否指向同一个位置。这在循环中至关重要，用来判断是否到达了容器的末尾。

### **为什么它不“是”一个指针？**

这才是问题的核心。

- **对于 `vector`**：因为 `vector` 的内存在物理上是连续的（就像一个普通的C语言数组），所以它的迭代器**可能**就是一个封装了的普通指针。在这种情况下，`++it` 的底层操作可能真的只是把一个内存地址增加了 `sizeof(element)`。

- **对于 `unordered_set` (或 `set`, `list`, `map`)**：情况就完全不同了。

  - `unordered_set` 底层是**哈希表**，元素在内存中是**不连续存放的**，它们被散布在不同的“桶”里。
  - `set` 底层是**红黑树**，元素在内存中通过节点指针互相连接，也不是连续的。

  对于这些非连续存储的容器，一个简单的指针和内存地址是无法工作的。你不能通过给一个地址加一来找到树中的“下一个”节点或哈希表中的下一个有效元素。

  因此，`unordered_set` 的迭代器是一个**更复杂的对象（通常是一个小的 `class` 或 `struct`）**。这个对象内部维护了指向当前哈希表桶和桶内位置的信息。当你对它执行 `++` 操作时，它会执行一系列复杂的逻辑：比如先在当前桶的链表中移动，如果到了链表末尾，就去寻找下一个非空的桶。

  **这就是迭代器抽象的强大之处**：无论底层数据结构是数组、链表、树还是哈希表，你作为程序员都使用完全相同的 `*it`, `++it`, `it != container.end()` 语法来遍历它，完全屏蔽了底层的复杂性。

### **`begin()` 和 `end()` 的具体含义**

现在我们来精确定义这两个函数返回的迭代器：

- **`begin()`**
  - 它返回一个迭代器，指向容器中的**第一个元素**。
  - 你可以对 `begin()` 返回的迭代器进行解引用（`*`）来获得第一个元素的值（前提是容器不为空）。
- **`end()`**
  - 它返回一个迭代器，指向容器中**“尾端元素的后一个位置”**。
  - 这是一个非常重要的概念：`end()` **并不指向最后一个元素**。它指向一个不存在的、作为“哨兵”或“边界”的位置。
  - 因此，你**绝对不能**对 `end()` 返回的迭代器进行解引用（`*`），这样做是未定义行为，通常会导致程序崩溃。
  - `end()` 的唯一目的就是用来做比较，判断遍历是否结束。`for` 循环的条件 `it != result_set.end()` 的意思就是“只要我的迭代器还没有走到那个末尾的边界位置，就继续循环”。

### **可视化比喻**

想象一条街上有一排房子：

- **容器（`result_set`）**：就是整条街。
- **元素**：是街上的每一栋房子。
- **迭代器**：是你自己，一个可以在街上行走的人。
- **`result_set.begin()`**：返回一个指向“1号房子”的你。
- **`\*it`**：是指你当前站着的房子本身。
- **`++it`**：是指你从当前房子走到下一栋房子。
- **`result_set.end()`**：返回一个指向“街尾的尽头，最后一栋房子之后”的你。那个位置没有房子，它只是标志着街道的结束。

所以，在 `return vector<int>(result_set.begin(), result_set.end());` 这句代码中，它的意思是：“请创建一个新的 `vector`，把 `result_set` 这条街上从**1号房子**开始，一直到**街尾尽头之前**的所有房子，都复制到新的 `vector` 里去。”



## 2.insert()函数

在vector中：

```c++
vector<int> ret;
ret.push_back(num);
ret.insert(ret.end(), num);
```

在unordered_set：

```c++
unordered_set<int> ret;
ret.insert(num);
```

在unorder_map中：

```c++
unordered_map<int, int> ret;
ret.insert({nums[i], i})
ret[nums[i]] = i;
```

## 3.字符和字符串

和字符char相比较时，用单引号；和字符串string相比较时，用双引号

## 4.字符串find函数返回值

`std::string` 类中的 `find` 函数是用来在一个字符串中查找另一个子字符串的。它的返回值有两种情况：

1. **如果找到了**：它会返回子字符串**第一次出现位置的起始索引（下标）**。这个返回值的类型是 `size_t`，一个无符号整数。
2. **如果没找到**：它会返回一个特殊的值 `std::string::npos`。这是一个静态常量，它的值通常是无符号整数的最大值。你可以把它理解为一个特殊的“未找到”标记。



# 一.数组

## 1.1 二分查找

**题述：**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 ：**

```
示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 
提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
```

**框架：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        
    }
};
```

### 解题思路1：二分查找

**思路解析:**

![image-20250716180238469](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250716180238469.png)

**题解：**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int len1 = nums.size();
        int left = 0, right = len1 - 1;
        while(left <= right)
        {
            int mid = (right + left) / 2;
            int num = nums[mid];
            if(num == target)
            {
                return mid;
            }
            else if(num > target)
            {
                right = mid - 1;
            }
            else
            {
                left = mid + 1;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$，这是因为，经过k次迭代后$2^k\approx n$,所以$k \approx log_n$
- 空间复杂度：$O(1)$

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while(left <= right):
            mid = (left + right) // 2;
            if(nums[mid] == target):
                return mid
            elif(nums[mid] < target):
                left = mid + 1
            else:
                right = mid - 1
        
        return -1
```



## 1.2 移除元素

**题述：**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**用户评测：**

评测机将使用以下代码测试您的解决方案：

```
int[] nums = [...]; // 输入数组
int val = ...; // 要移除的值
int[] expectedNums = [...]; // 长度正确的预期答案。
                            // 它以不等于 val 的值排序。

int k = removeElement(nums, val); // 调用你的实现

assert k == expectedNums.length;
sort(nums, 0, k); // 排序 nums 的前 k 个元素
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

如果所有的断言都通过，你的解决方案将会 **通过**。

**示例 ：**

```
示例 1：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

示例 2：
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
 
提示：
0 <= nums.length <= 100
0 <= nums[i] <= 50
0 <= val <= 100
```

**框架：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        
    }
};
```

### 解题思路1：从头开始双指针

**思路解析:**

经典双指针，这题可以用swap，也可以直接让左面覆盖住右面

**题解：**

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        //双指针
        int len1 = nums.size();
        int left = 0, right = 0;
        int k = 0;
        while(right < len1)
        {
            if(nums[right] != val)
            {
                swap(nums[left], nums[right]);//当然，这题也可以直接让nums[left] = nums[right]
                left++;
                k++;
            }
            right++;
        }
        return k;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.3 有序数组的平方

**题述：**

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 ：**

```
示例 1：
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]

示例 2：
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
 

提示：
1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 已按 非递减顺序 排序
```

**框架：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
       
    }
};
```

### 解题思路1：暴力解法，先平方后排序

**思路解析:**

先用for循环平方，再用sort排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans;
        for(int num : nums)
        {
            ans.push_back(num * num);
        }
        sort(ans.begin(), ans.end());
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$，sort函数的时间复杂度都是$O(nlog_n)$
- 空间复杂度：$O(log_n)$



### 解题思路2：双指针

**思路解析:**

![image-20250717163350472](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250717163350472.png)

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        //双指针
        int len1 = nums.size();
        int neg = -1;
        for(int i = 0; i < len1; ++i)
        {
            if(nums[i] < 0)
            {
                neg = i;
            }else
            {
                break;
            }
        }

        vector<int> ans;
        int i = neg, j = neg + 1;
        while(i >= 0 || j < len1)
        {
            if(i < 0)
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }else if(j == len1)
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else if(nums[i] * nums[i] < nums[j] * nums[j])
            {
                ans.push_back(nums[i] * nums[i]);
                --i;
            }else
            {
                ans.push_back(nums[j] * nums[j]);
                ++j;
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路3：头尾开始双指针

**思路解析:**

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

由于数组两头就是最大的选择之一，所以可以从两头开始排序

**题解：**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int len1 = nums.size();
        int left = 0, right = len1 - 1, pos = len1 - 1;
        vector<int> ans(len1);	//这里一定要确定ans的大小，否则会报错
        while(left <= right)	//这里一定要相等，否则最后一个值会无法进入
        {
            if(nums[left] * nums[left] < nums[right] * nums[right])
            {
                ans[pos] = nums[right] * nums[right];
                pos--;
                right--;
            }else
            {
                ans[pos] = nums[left] * nums[left];
                pos--;
                left++;
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.4 长度最小的子数组

**题述：**

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 ：**

```
示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：
输入：target = 4, nums = [1,4,4]
输出：1

示例 3：
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
 
提示：
1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 104
```

**框架：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        
    }
};
```

### 解题思路1：滑动窗口

**思路解析:**

滑动窗口，使用min函数寻找最小的长度

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

**题解：**

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        if(n == 0)
        {
            return 0;
        }
        int ans = INT_MAX;	//这是最大值
        int start = 0, end = 0;
        int sum = 0;
        while(end < n)
        {
            sum += nums[end];
            while(sum >= target)
            {
                ans = min(ans, end - start + 1);	//选取最小的长度
                sum -= nums[start];
                ++start;
            }
            ++end;
        }
        return ans == INT_MAX ? 0 : ans;	//如果ans没变，则返回0；否则返回ans的值
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.5 螺旋矩阵(II)

**题述：**

给你一个正整数 `n` ，生成一个包含 `1` 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/spiraln.jpg)

```
示例 1：
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]

示例 2：
输入：n = 1
输出：[[1]]
 
提示：
1 <= n <= 20
```

**框架：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        
    }
};
```

### 解题思路1：模拟

**思路解析:**

左闭右开

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220922102236.png)

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 1.6 区间和

**题述：**

给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。

**输入描述：**

第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间下标：a，b （b > = a），直至文件结束。

**输出描述：**

输出每个指定区间内元素的总和。

**示例 ：**

```
输入：
5
1
2
3
4
5
0 1
1 3

输出：
3
9

提示信息
数据范围：
0 < n <= 100000
```

**框架：**

```c++
无，ACM框架
```

### 解题思路1：前缀和

**思路解析:**

前缀和

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627110604.png)

输出2~5之间的值：

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20240627111319.png)

**题解：**

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for(int i = 0; i < n; i++)
    {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }
    while(cin >> a >> b)
    {
        int sum;
        if(a == 0)
        {
            sum = p[b];
        }
        else
        {
            sum = p[b] - p[a - 1];
        }
        cout << sum << endl;
    }    
}
```

C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多：

```c++
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &vec[i]);
        presum += vec[i];
        p[i] = presum;
    }

    while (~scanf("%d%d", &a, &b)) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        printf("%d\n", sum);
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 1.7 开发商购买土地

**题目描述：**

```
在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 
现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 
注意：区块不可再分。
```

**输入描述：**

```
第一行输入两个正整数，代表 n 和 m。 
接下来的 n 行，每行输出 m 个正整数。
```

**输出描述：**

```
请输出一个整数，代表两个子区域内土地总价值之间的最小差距。
```

**输入示例：**

```
3 3
1 2 3
2 1 3
1 2 3
```

**输出示例：**

```
0
```

**提示信息：**

```
如果将区域按照如下方式划分：
1 2 | 3
2 1 | 3
1 2 | 3 
两个子区域内土地总价值之间的最小差距可以达到 0。
数据范围：
1 <= n, m <= 100；
n 和 m 不同时为 1。
```

### 解题思路1：嵌套for循环

**思路解析:**

正常解题即可

**题解：**

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0));
    //输入数值
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }
    int result = INT_MAX;
    int count = 0;
    for(int i = 0; i < n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            count += vec[i][j];
            if(j == m - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }

    count = 0;
    for(int j = 0; j < m; j++)
    {
        for(int i = 0; i < n; i++)
        {
            count += vec[i][j];
            if(i == n - 1)
            {
                result = min(result, abs(sum - count - count));
            }
        }
    }
    cout << result << endl;
}
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O()$



## 总结



![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png)



# 二.链表



## 2.1 移除链表元素

**题述：**

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]

示例 2：
输入：head = [], val = 1
输出：[]

示例 3：
输入：head = [7,7,7,7], val = 7
输出：[]
```

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        
    }
};
```

### 解题思路1：递归

**思路解析:**

递归的两个核心要素：

- 1.**递推关系：**如何将一个大问题分解成一个性质相同、但规模更小的小问题
- 2.**终止条件：**最小的子问题是什么，它的解是什么。这个条件用来结束无穷的自我调用

**题解：**

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //1.终止条件：这是递归的出口
        if(head == nullptr)
        {
            return head;
        }
        //2.递推关系：
        head->next = removeElements(head->next, val);
        //3.处理当前节点：如果相等，删除元素，并返回新的头节点；如果不相等,则返回head本身
        return head->val == val? head->next : head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$,其中 *n* 是链表的长度。递归过程中需要遍历链表一次。
- 空间复杂度：$O(n)$,其中 *n* 是链表的长度。空间复杂度主要取决于递归调用栈，最多不会超过 *n* 层。



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        //防止头节点被删除后无法确定，所以这里使用哑节点
        struct ListNode* dummyHead = new ListNode(0, head);
        struct ListNode* temp = dummyHead;
        //为了防止空指针解引用导致程序崩溃
        while(temp->next != NULL)
        {
            if(temp->next->val == val)
            {
                temp->next = temp->next->next;
            }
            else
            {
                temp = temp->next;
            }
        }
        //返回头节点
        head = dummyHead->next;
        //记得释放new节点
        delete dummyHead;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 2.2 设计链表

**题述：**

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例 ：**

```
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
 

提示：
0 <= index, val <= 1000
请不要使用内置的 LinkedList 库。
调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。
```

**框架：**

```c++
class MyLinkedList {
public:
    MyLinkedList() {
        
    }
    
    int get(int index) {
        
    }
    
    void addAtHead(int val) {
        
    }
    
    void addAtTail(int val) {
        
    }
    
    void addAtIndex(int index, int val) {
        
    }
    
    void deleteAtIndex(int index) {
        
    }
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 解题思路1：单链表

**思路解析:**

确定链表长度size和链表头节点head，在节点前确立虚拟头节点

**题解：**

```c++
/*
struct ListNode{
    int val;
    ListNode *next;
    ListNode(): val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next): val(x), next(next) {}
};
*/

class MyLinkedList {
public:
    MyLinkedList() {
        this->size = 0;
        this->head = new ListNode(0);
    }
    
    int get(int index) {
        if(index < 0 || index >= size)
        {
            return -1;
        }
        ListNode *cur = head;
        for(int i = 0; i <= index; i++)
        {
            cur = cur->next;
        }
        return cur->val;
    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        index = max(0, index);
        size++;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *toAdd = new ListNode(val);
        toAdd->next = pred->next;
        pred->next = toAdd;

    }
    
    void deleteAtIndex(int index) {
        if(index < 0 || index >= size)
        {
            return;
        }
        size--;
        ListNode *pred = head;
        for(int i = 0; i < index; i++)
        {
            pred = pred->next;
        }
        ListNode *p = pred->next;
        pred->next = pred->next->next;
        delete p;
    }
public:
    int size;
    ListNode *head;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 $O(1)$，get 消耗 $O(index)$，addAtHead 消耗 $O(1)$，addAtTail 消耗$ O(n)$，其中 n 为链表当前长度，即 addAtHead，addAtTail 和 addAtIndex 已调用次数之和，addAtIndex 消耗 $O(index)$。

- 空间复杂度：所有函数的单次调用空间复杂度均为$ O(1)$，总体空间复杂度为$ O(n)$，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。

  



### 解题思路1：双链表

**思路解析:**



**题解：**

```c++
class MyLinkedList {
public:
    struct DLinkListNode{
        int val;
        DLinkListNode *prev, *next;
        DLinkListNode(int x): val(x), prev(nullptr), next(nullptr) {}
    };
    MyLinkedList() {
        this->size = 0;
        this->head = new DLinkListNode(0);
        this->tail = new DLinkListNode(0);
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int index) {
        if(index >= size)
        {
            return -1;
        }
        DLinkListNode *curr;
        if(index + 1 < size - index)
        {
            curr = head;
            for(int i = 0; i <= index; i++)
            {
                curr = curr->next;
            }
        }else
        {
            curr = tail;
            for(int i = 0; i < size - index; i++)
            {
                curr = curr->prev;
            }
        }
        return curr->val;

    }
    
    void addAtHead(int val) {
        addAtIndex(0, val);
    }
    
    void addAtTail(int val) {
        addAtIndex(size, val);
    }
    
    void addAtIndex(int index, int val) {
        if(index > size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev;
        }
        size++;
        DLinkListNode *toAdd = new DLinkListNode(val);
        toAdd->prev = pred;
        toAdd->next = succ;
        pred->next = toAdd;
        succ->prev = toAdd;
    }
    
    void deleteAtIndex(int index) {
        if(index >= size)
        {
            return;
        }
        DLinkListNode *pred, *succ;
        if(index + index < size)
        {
            pred = head;
            for(int i = 0; i < index; i++)
            {
                pred = pred->next;
            }
            succ = pred->next->next;
        }else
        {
            succ = tail;
            for(int i = 0; i < size - index - 1; i++)
            {
                succ = succ->prev;
            }
            pred = succ->prev->prev;
        }
        size--;
        DLinkListNode *p = pred->next;
        pred->next = succ;
        succ->prev = pred;
        delete p;
    }
public:
    int size;
    DLinkListNode *head;
    DLinkListNode *tail;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

**复杂度分析**

- 时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。

- 空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。






## 2.3 反转链表

**题述：**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 ：**

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]

输入：head = [1,2]
输出：[2,1]

输入：head = []
输出：[]
```



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex1.jpg)



![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/rev1ex2.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

令后指针指向前即可

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = nullptr;
        ListNode *curr = head;
        while(curr)
        {
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

回溯思路如图所示：

![image-20250805164527502](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805164527502.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head || !head->next)
        {
            return head;
        }
        ListNode *newHead = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;	//如果不指向空，可能在回溯的最后造成环链表
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 2.4 两两交换链表中的节点

**题述：**

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/swap_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        
    }
};
```

### 解题思路1：迭代

**思路解析:**

如图所示：

![image-20250731161817709](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250731161817709.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *temp = dummyNode;
        while(temp->next != nullptr && temp->next->next != nullptr)
        {
            ListNode *node1 = temp->next;
            ListNode *node2 = temp->next->next;
            temp->next = node2;
            node1->next = node2->next;
            node2->next = node1;
            temp = node1;
        }
        ListNode *ans = dummyNode->next;
        delete dummyNode;
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：递归

**思路解析:**

![image-20250805192330379](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250805192330379.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head || head->next)
        {
            return head;
        }
        ListNode *newHead = head->next;
        head->next = swapPairs(newHead->next);
        newHead->head = head;
        return newHead;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 2.5 删除链表的倒数第N个结点

**题述：**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/remove_ex1.jpg)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        
    }
};
```

### 解题思路1：暴力迭代

**思路解析:**

先计算总体长度，然后再遍历到size-n处，删除即可

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.确定链表长度，设置为size
        int size = 0;
        ListNode *temp = head;
        while(temp != nullptr)
        {
            size++;
            temp = temp->next;
        }
        //2.设置哑节点,找出被删节点所在位置
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *p = dummyNode;
        for(int i = 0; i < size - n; i++)
        {
            p = p->next;
        }
        ListNode *toDelete = p->next;
        p->next = p->next->next;
        delete toDelete;
        //3.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路2：双指针

**思路解析:**

经典快慢指针

![p3](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/p3.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点和快慢指针
        ListNode *dummyNode = new ListNode(0, head);
        ListNode *fast = dummyNode;
        ListNode *slow = dummyNode;
        //2.令快指针领先两个身位
        for(int i = 0; i < n; i++)
        {
            fast = fast->next;
        }
        //3.令快指针直到末尾，结束循环
        while(fast->next)
        {
            fast = fast->next;
            slow = slow->next;
        }
        //删除节点
        slow->next = slow->next->next;
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



### 解题思路3：栈

**思路解析:**

先入栈push()，再出栈pop()，再删除节点，然后返回头节点

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        //1.设置哑节点
        ListNode *dummyNode = new ListNode(0, head);
        //2.设置栈
        stack<ListNode*> stk;
        ListNode *curr = dummyNode;
        //3.入栈
        while(curr)
        {
            stk.push(curr);
            curr = curr->next;
        }
        //4.出栈
        for(int i = 0; i < n; i++)
        {
            stk.pop();
        }
        //5.删除节点
        ListNode *prev = stk.top();
        ListNode *toDelete = prev->next;
        prev->next = prev->next->next;
        delete toDelete;
        //6.返回头节点
        head = dummyNode->next;
        delete dummyNode;
        return head;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(L)$
- 空间复杂度：$O(1)$



## 2.6 面试题 02.07.链表相交

**题述：**

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/160_statement.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
    }
};
```

### 解题思路1：赛道追击

**思路解析:**

![image-20250807165922067](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/image-20250807165922067.png)

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA == nullptr || headB == nullptr)
        {
            return nullptr;
        }
        ListNode *pA = headA, *pB = headB;
        while(pA != pB)
        {
            pA = pA == nullptr? headB: pA->next;
            pB = pB == nullptr? headA: pB->next;
        }
        return pA;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(1)$

### 解题思路2：确定长度

**思路解析:**

先确定长度，然后使最长的始终为len1，currA，最后从相同长度处开始比较

**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //1.确定两个链表的长度
        int len1 = 0, len2 = 0;
        ListNode *currA = headA;
        ListNode *currB = headB;
        while(currA)
        {
            len1++;
            currA = currA->next;
        }
        while(currB)
        {
            len2++;
            currB = currB->next;
        }
        //2.使最长的为len1，currA
        currA = headA;
        currB = headB;
        if(len2 > len1)
        {
            swap(len1, len2);
            swap(currA,currB);
        }
        //3.从相同长度处开始循环
        int gap = len1 - len2;
        for(int i = 0; i < gap; i++)
        {
            currA = currA->next;
        }
        //4.如果有一位相等，那么就说明后面的已经相等，因为这是指针，遂返回即可
        while(currA != nullptr)
        {
            if(currA == currB)
            {
                return currA;
            }
            currA = currA->next;
            currB = currB->next;
        }
        //5.没有的话就返回空指针
        return nullptr;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(1)$





## 2.7 环形链表II

**题述：**

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 ：**

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/circularlinkedlist.png)

**框架：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        
    }
};
```

### 解题思路1：快慢指针

**思路解析:**

公式推导如下：



**题解：**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while(fast != NULL && fast->next != NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
            if(fast == slow)
            {
                ListNode *index1 = fast;
                ListNode *index2 = head;
                while(index1 != index2)
                {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return NULL;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



# 三.哈希表

哈希表的三种结构：

- 数组
- set(集合)
- map(映射)

set数据结构：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| ------------------ | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | $O(log_n)$ | $O(log_n)$ |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | $0(1)$     | $0(1)$     |

map数据结构：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率   | 增删效率   |
| ------------------ | -------- | -------- | ---------------- | ------------ | ---------- | ---------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | $O(log_n)$ | $O(log_n)$ |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | $0(1)$     | $0(1)$     |

## 3.1 有效的字母异位词

**题述：**

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的 字母异位词。

**示例 ：**

```
示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

提示:
1 <= s.length, t.length <= 5 * 104
s 和 t 仅包含小写字母
 
进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
```

**框架：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        
    }
};
```

### 解题思路1：哈希表

**思路解析:**

建立26位的vector数组

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        vector<int> ans(26, 0);
        for(char ch: s)
        {
            ans[ch - 'a']++;
        }
        for(char ch: t)
        {
            ans[ch - 'a']--;
            if(ans[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(26)$



### 解题思路2：排序

**思路解析:**

使用sort函数排序

**题解：**

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int len1 = s.size();
        int len2 = t.size();
        if(len1 != len2)
        {
            return false;
        }
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s == t;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(log_n)$





## 3.2 两个数组的交集

**题述：**

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。



**示例 ：**

```
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]

示例 2：
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的

提示：
1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000
```

**框架：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        
    }
};
```

### 解题思路1：unordered_set

**思路解析:**

![set哈希法](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20220707173513.png)

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for(int num: nums2)
        {
            if(nums_set.find(num) != nums_set.end())
            {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(n)$



### 解题思路2：排序+双指针

**思路解析:**

先排序，然后看值是否相等，相等的话就插入，否则就让小的那一位+1

**题解：**

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        sort(nums1.begin(), nums1.end());
        sort(nums2.begin(), nums2.end());
        int len1 = nums1.size(), len2 = nums2.size();
        int index1 = 0, index2 = 0;
        vector<int> ret;
        while(index1 < len1 && index2 < len2)
        {
            int num1 = nums1[index1], num2 = nums2[index2];
            if(num1 == num2)
            {
                if(!ret.size() || num1 != ret.back())
                {
                    ret.push_back(num1);
                    //也可以改为这句：ret.insert(ret.end(), num1);
                }
                index1++;
                index2++;
            }
            else if(num1 < num2)
            {
                index1++;
            }else
            {
                index2++;
            }
        }
        return ret;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(mlog_m + nlog_n)$
- 空间复杂度：$O(log_m + log_n)$



## 3.3 快乐数

### 解题思路1：unordered_set

**思路解析:**

使用unordered_set的特性：无序但不可重复，查询效率快

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> ret;
        while(1)
        {
            int sum = getSum(n);
            if(sum == 1)
            {
                return true;
            }
            if(ret.find(sum) != ret.end())
            {
                return false;
            }
            else
            {
                ret.insert(sum);
            }
            n = sum;
        }
    }
};
```

**复杂度分析**

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(logn)$



### 解题思路2：快慢指针

**思路解析:**

如果最后不能到1，那么一定会陷入一个循环；如果最后能到1，fast还是会和slow相同

到1：

![fig1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig1.png)

陷入循环：

![fig2](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/202_fig2.png)

**题解：**

```c++
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n > 0)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow = n, fast = n;
        do{
            slow = getSum(slow);
            fast = getSum(fast);
            fast = getSum(fast);
        }while(slow != fast);

        return slow == 1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(log_n)$
- 空间复杂度：$O(1)$





## 3.4 两数之和

### 解题思路1：哈希表

**思路解析:**

使用unorder_map哈希表插入寻找

**题解：**

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> ret;
        for(int i = 0; i < nums.size(); i++)
        {
            auto iter = ret.find(target - nums[i]);
            if(iter != ret.end())
            {
                return {iter->second, i};
            }
            ret.insert(pair<int, int>(nums[i], i));
            //也可改为 ret[nums[i]] = i;
            //ret.insert({nums[i], i});
        }
        return {};
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 3.5 四数相加II

### 解题思路1：分组+哈希表

**思路解析:**

先查看前两个数组的和，然后检查后两个数组的和

**题解：**

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int, int> countAB;
        int ans = 0;
        for(int a: nums1)
        {
            for(int b: nums2)
            {
                countAB[a + b]++;
            }
        }
        for(int c: nums3)
        {
            for(int d: nums4)
            {
                //也可以改为：if(countAB.count(-c - d))
                if(countAB.find(0 - (c + d)) != countAB.end())
                {
                    ans += countAB[0 - (c + d)];
                }
            }
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$



## 3.6 赎金信

### 解题思路1：vector哈希表

**思路解析:**

老套的vector哈希表

**题解：**

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if(ransomNote.size() > magazine.length())
        {
            return false;
        }
        vector<int> cnt(26, 0);
        for(char ch: magazine)
        {
            cnt[ch - 'a']++;
        }
        for(char ch: ransomNote)
        {
            cnt[ch - 'a']--;
            if(cnt[ch - 'a'] < 0)
            {
                return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(26)$



## 3.7 三数之和

### 解题思路1：排序+双指针

**思路解析:**

先排序再循环寻找不重复的三元组

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] > 0)
            {
                //return result;
                break;	//最好用break，这样逻辑通顺
            }
            if(i > 0 && nums[i] == nums[i - 1])
            {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right)
            {
                if(nums[i] + nums[left] + nums[right] > 0) right--;
                else if(nums[i] + nums[left] + nums[right] < 0) left++;
                else
                {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    while(right > left && nums[right] == nums[right - 1]) right--;
                    while(right > left && nums[left] == nums[left + 1]) left++;
                    right--;
                    left++;
                }
            }
        }
        return result
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$



## 3.8 四数之和

### 解题思路1：排序+双指针

**思路解析:**

和三数之和差不多

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for(int k = 0; k < nums.size(); k++)
        {
            if(nums[k] > target && nums[k] >= 0)
            {
                break;
            }
            if(k > 0 && nums[k] == nums[k - 1])
            {
                continue;
            }
            for(int i = k + 1; i < nums.size(); i++)
            {
                if(nums[k] + nums[i] > target && nums[k] + nums[i] >= 0)
                {
                    break;
                }
                if(i > k + 1 && nums[i] == nums[i - 1])
                {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while(left < right)
                {
                    if((long) nums[k] + nums[i] + nums[left] + nums[right] > target) right--;
                    else if((long) nums[k] + nums[i] + nums[left] + nums[right] < target) left++;
                    else
                    {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        while(right > left && nums[right] == nums[right - 1]) right--;
                        while(right > left && nums[left] == nums[left + 1]) left++;
                        right--;
                        left++;
                    }
                }
            }


        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^3)$
- 空间复杂度：$O(1)$



# 四.字符串

## 4.1 反转字符串

### 解题思路1：双指针

**思路解析:**

经典双指针

**题解：**

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int len1 = s.size();
        int left = 0, right = len1 - 1;
        while(left < right)
        {
            char ch = s[left];
            s[left] = s[right];
            s[right] = ch;
            left++;
            right--;
        }
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.2 反转字符串II

### 解题思路1：模拟

**思路解析:**

如果没超出长度，正常反转；如果超出了长度，则反转到长度len1的字符串

**题解：**

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        int len1 = s.size();
        for(int i = 0; i < len1; i += 2 * k)
        {
            if(i + k < len1)
            {
                reverse(s.begin() + i, s.begin() + i + k);
            }else
            {
                //也可以写为： reverse(s.begin() + i, s.end());
                reverse(s.begin() + i, s.begin() + len1);
            }
        }
        return s;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.3 替换数字

### 解题思路1：先查数，在扩容

**思路解析:**

先查有几个数字，然后扩容到对应的长度，最后从后向前插入

**题解：**

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
    string s;
    while(cin >> s)
    {
        int countNumber = 0;
        int len1 = s.size();
        for(int i = 0; i < len1; i++)
        {
            if(s[i] >= '0' && s[i] <= '9')
            {
                countNumber++; 
            } 
        }
        s.resize(len1 + countNumber * 5);
        int indexA = len1 - 1;
        int indexB = s.size() - 1;
        while(indexA >= 0)
        {
            if(s[indexA] >= '0' && s[indexA] <= '9')
            {
                s[indexB--] = 'r';
                s[indexB--] = 'e';
                s[indexB--] = 'b';
                s[indexB--] = 'm';
                s[indexB--] = 'u';
                s[indexB--] = 'n';
            }
            else
            {
                s[indexB--] = s[indexA];
            }
            indexA--;
        }
        cout << s << endl;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.4 反转字符串中的单词

### 解题思路1：去除空格+反转

**思路解析:**

先擦除多余空格，再反转所有单词，最后反转局部单词

**题解：**

```c++
class Solution {
public:
    //1.去除多余空格
    void removeExtraSpace(string &s)
    {
        int len1 = s.size();
        int left = 0, right = 0;
        while(right < len1)
        {
            if(s[right] != ' ')
            {
                while(s[right] != ' ' && right < len1)
                {
                    swap(s[left], s[right]);
                    left++;
                    right++;
                }
                //这里到末尾也要加上空格
                if(right <= len1)
                {
                    s[left] = ' ';
                    left++;
                }
            }
            right++;
        }
        s.resize(left + 1 - 2);
    }
    //2.在特定位置反转字符串，左闭右闭
    void reverseString(string &s, int start, int end)
    {
        for(int i = start, j = end; i < j; i++, j--)
        {
            swap(s[i], s[j]);
        }
    }

    string reverseWords(string s) {
        removeExtraSpace(s);
        reverseString(s, 0, s.size() - 1);
        //3.根据空格反转单词
        int start = 0;
        int len1 = s.size();
        for(int i = 0; i <= len1; i++)
        {
            //如果到末尾了，就要开始反转
            if(i == len1 || s[i] == ' ')
            {
                reverseString(s, start, i - 1);
                start = i + 1;
            }
        }
        return s;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 4.5 右旋字符串

### 解题思路1：reverse逆转

**思路解析:**

先全部逆转，再局部逆转

![img](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20231106172058.png)

**题解：**

```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
    int k;
    string s;
    while(cin >> k >> s)
    {
        //1.先让字符串全部反转
        reverse(s.begin(), s.end());
        //2.确定长度
        int len1 = s.size();
        //3.让前k个和，后len1 -k反转
        reverse(s.begin(), s.begin() + k);
        reverse(s.begin() + k, s.end());
        cout << s << endl;
    }
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 4.6 找出字符串中第一个匹配项的下标

### 解题思路1：双循环

**思路解析:**

两层循环

**题解：**

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        int len1 = haystack.size();
        int len2 = needle.length();
        if(len1 < len2)
        {
            return -1;
        }
        for(int i = 0; i < len1; i++)
        {
            int k = i;
            for(int j = 0; j < len2; j++)
            {
                if(needle[j] == haystack[k])
                {
                    k++;
                }
            }
            if(k - i == len2)
            {
                return i;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n * m)$
- 空间复杂度：$O(1)$



### 解题思路2：KMP

**思路解析:**

首先，我构建了一个数组next，这个数组next[i]存放的值就代表了，从字符串开始0到字符串i处，最长相等前后缀的长度；

第二，我在对next数组赋值时，要用到i和j的定义，j代表了前缀尾，i代表了后缀尾，

第三，当s[i]和s[j]相等时，我对next[i]处进行赋值，代表了此次最长前后缀的长度，但是当s[i]和s[j]不相等时，我需要将j向后跳跃，而跳跃的意义就在于，我要寻找一个即是P1的前缀又是S1的后缀的一个字符串，由于P1与S1相同，所以也就是找一个既是P1的前缀又是P1的后缀的字符串，此时恰好满足了对于next数组的定义，所以j = next[j - 1]

**题解：**

```c++
class Solution {
public:
    //1.KMP算法的获得next数组函数
    void getNext(int *next, const string &s)
    {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++)
        {
            while(j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if(s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        }
    }

    int strStr(string haystack, string needle) {
        int len1 = haystack.size(), len2 = needle.size();
        int next[len2];
        getNext(next, needle);
        int j = 0;
        for(int i = 0; i < len1; i++)
        {
            while(j > 0 && haystack[i] != needle[j])
            {
                j = next[j - 1];
            }
            if(haystack[i] == needle[j])
            {
                j++;
            }
            if(j == len2)
            {
                return i - len2 + 1;
            }
        }
        return -1;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n+m)$
- 空间复杂度：$O(m)$



## 4.7 重复的子字符串

### 解题思路1：枚举

**思路解析:**

如果s[j] != s[j - i]，那么就退出并将判断置为false

**题解：**

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int len1 = s.size();
        for(int i = 1; i * 2 <= len1; i++)
        {
            if(len1 % i == 0)
            {
                bool match = true;
                for(int j = i; j < len1; j++)
                {
                    if(s[j] != s[j - i])
                    {
                        match = false;
                        break;
                    }
                }
                if(match)
                {
                    return true;
                }
            }
        }
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$



### 解题思路2：字符串匹配

**思路解析:**

先合并，再寻找是否有相等的

**题解：**

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        return (s + s).find(s, 1) != s.size();	//find函数返回的是：字符串出现时的第一个下标
    }
};
```

**复杂度分析** : 根据语言特性，时间与空间的复杂度会有差异

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路3：KMP

**思路解析:**



**题解：**

```c++
class Solution {
public:
    void getNext(int *next, const string &s)
    {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++)
        {
            while(j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }
            if(s[i] == s[j])
            {
                j++;
            }
            next[i] = j;
        } 
    }

    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int len1 = s.size();
        int next[len1];
        getNext(next, s);
        if(next[len1 - 1] != 0 && (len1 %  (len1 - next[len1 - 1]) == 0)) return true;
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



# 五.栈与队列

## 5.1 用栈实现队列

### 解题思路1：双栈

**思路解析:**

使用双栈，一个作为出栈，一个作为入栈

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

**题解：**

```c++
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stIn.push(x);
        
    }
    
    int pop() {
        if(stOut.empty())
        {
            while(!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }
    
    int peek() {
        if(stOut.empty())
        {
            while(!stIn.empty())
            {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        return stOut.top();
    }
    
    bool empty() {
        return stOut.empty() && stIn.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(1)$
- 空间复杂度：$O(n)$





## 5.2 用队列实现栈

### 解题思路1：双队列

**思路解析:**

que1做为输入队列，que2做为输出队列，当输入值时，将que1的所有元素拷贝到que2，然后输出que1的最后一个元素，然后再将que2的元素返回到que1

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.gif)

**题解：**

```c++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;

public:
    MyStack() {
        
    }
    
    void push(int x) {
        que1.push(x);
    }
    
    int pop() {
        int size = que1.size();
        size--;
        while(size)
        {
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int result = que1.front();
        que1.pop();
        que1 = que2;
        while(!que2.empty())
        {
            que2.pop();
        }
        return result;
    }
    
    int top() {
        int size = que1.size();
        size--;
        while(size)
        {
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int result = que1.front();
        que2.push(result);
        que1.pop();
        que1 = que2;
        while(!que2.empty())
        {
            que2.pop();
        }
        return result;
    }
    
    bool empty() {
        return que1.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



### 解题思路2：单队列

**思路解析:**

入队列时，先将前面的重新入一遍，即可达到栈的效果

**题解：**

```c++
class MyStack {
public:
    queue<int> que;
    MyStack() {
        
    }
    
    void push(int x) {
        int n = que.size();
        que.push(x);
        for(int i = 0; i < n; i++)
        {
            que.push(que.front());
            que.pop();
        }
    }
    
    int pop() {
        int res = que.front();
        que.pop();
        return res;
    }
    
    int top() {
        return que.front();
    }
    
    bool empty() {
        return que.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 5.3 有效的括号

### 解题思路1：栈+unordered_map哈希表

**思路解析:**

先构建哈希表，然后判断：此时如果输入的是左括号，则入栈；输入的是右括号：在栈里寻找此时的顶部对应的是否为相应的左括号，是的话出栈，不是或者栈为空就返回false

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif)

**题解：**

```c++
class Solution {
public:
    bool isValid(string s) {
        int len1 = s.size();
        if(len1 % 2)
        {
            return false;
        }

        unordered_map<char, char> pairs = {
            {'}', '{'},
            {']', '['},
            {')', '('}
        };

        stack<char> stk;
        for(char ch: s)
        {
            if(pairs.count(ch))	//如果在哈希表中找到了对应的键
            {
                if(stk.empty() || stk.top() != pairs[ch])
                {
                    return false;
                }
                stk.pop();
            }else
            {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：栈

**思路解析:**

一步一步比较即可

**题解：**

```c++
class Solution {
public:
    bool isValid(string s) {
        if(s.size() % 2 != 0) return false;
        stack<char> stk;
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] == '(') stk.push(')');
            else if(s[i] == '[') stk.push(']');	//只用用''，不能用""
            else if(s[i] == '{') stk.push('}');
            else if(stk.empty() || s[i] != stk.top()) return false;
            else stk.pop();
        }
        return stk.empty();
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 5.4 删除字符串中的所有相邻重复项

### 解题思路1：stack栈

**思路解析:**

新建栈

**题解：**

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> stk;
        for(char ch: s)
        {
            if(!stk.empty() && ch == stk.top())
            {
                stk.pop();
            }else
            {
                stk.push(ch);
            }
        }
        string result = "";
        while(!stk.empty())
        {
            result += stk.top();
            stk.pop();
        }
        reverse(result.begin(), result.end());
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：string栈

**思路解析:**

直接在string字符串上操作

**题解：**

```c++
class Solution {
public:
    string removeDuplicates(string s) {
        string result;
        for(char ch: s)
        {
            if(result.empty() || ch != result.back())
            {
                result.push_back(ch);
                //result += ch; 也是可以的
            }else
            {
                result.pop_back();
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 5.5 逆波兰表达式求值

### 解题思路1：栈

**思路解析:**

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

**题解：**

```c++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        //vector<string>代表了 tokens中的每个字符都是字符串，所以比较时要用双引号
        int len1 = tokens.size();
        stack<long long> stk;
        for(int i = 0; i < len1; i++)
        {
            //必须用双引号
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/")
            {
                long long num1 = stk.top();
                stk.pop();
                long long num2 = stk.top();
                stk.pop();
                if(tokens[i] == "+") stk.push(num2 + num1);
                else if(tokens[i] == "-") stk.push(num2 - num1);
                else if(tokens[i] == "*") stk.push(num2 * num1);
                else if(tokens[i] == "/") stk.push(num2 / num1);
            }else
            {
                stk.push(stoll(tokens[i])); //stoll:将字符串转化为长整型的函数
            }
        }
        return stk.top();
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 5.6 滑动窗口最大值(太难了)

### 解题思路1：优先队列（后面在学）

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(n)$



### 解题思路2：单调队列

**思路解析:**

pop的时候只需要判断，pop的这个值是否在队列头部，是的话就pop，否则不需要

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-2.gif)

**题解：**

```c++
class Solution {
private:
    class MyQueue{
        public:
            deque<int> que;
            void pop(int value)
            {
                if(!que.empty() && value == que.front())
                {
                    que.pop_front();
                }
            }
            void push(int value)
            {
                while(!que.empty() && value > que.back())
                {
                    que.pop_back();
                }
                que.push_back(value);
            }
            int front()
            {
                return que.front();
            }

    };

public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for(int i = 0; i < k; i++)
        {
            que.push(nums[i]);
        }
        result.push_back(que.front());
        for(int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(k)$



## 5.7 前K个高频元素（后面学完了树再来看吧）

### 解题思路1：堆

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 六.二叉树

## 6.1 二叉树的前序遍历

中左右

### 解题思路1：递归

**思路解析:**

前序递归

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void preorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        } 
        res.push_back(root->val);
        preorder(root->left, res);
        preorder(root->right, res);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        preorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**

注意入栈的时候要遵守**中右左**的顺序，因为栈是先进后出

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            if(node->right) stk.push(node->right);
            if(node->left) stk.push(node->left);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.2 二叉树的后序遍历

左右中

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void postorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        }
        postorder(root->left, res);
        postorder(root->right, res);
        res.push_back(root->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        postorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

### 解题思路2：迭代

**思路解析:**

先按照中右左的顺序对res数据进行输入，最后将数组反转过来就是左右中的顺序

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            if(node->left) stk.push(node->left);
            if(node->right) stk.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.3 二叉树的中序遍历

左中右

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root, vector<int> &res)
    {
        if(root == nullptr)
        {
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> res;
        TreeNode *curr = root;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                res.push_back(curr->val);
                curr = curr->right;
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：遍历的统一解法(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.4 二叉树的层序遍历

### 解题思路1：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vec);	//由于每次循环都会清空vec这个数组，所以并不会产生重复插入
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：递归（后面在学）

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void order(TreeNode *root, vector<vector<int>> &result, int depth)
    {
        if(root == nullptr)
        {
            return;
        }
        if(result.size() == depth)
        {
            result.push_back(vector<int>());
        }
        result[depth].push_back(root->val);
        order(root->left, result, depth + 1);
        order(root->right, result, depth + 1);
    }

    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$





## 6.5 二叉树的层序遍历II

### 解题思路1：迭代

**思路解析:**

只需要加一句反转即可，reverse函数把vec当作单个元素来反转的

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(vec);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.6 二叉树的右视图

### 解题思路1：层序遍历

**思路解析:**

依旧层序遍历

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size - 1; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            TreeNode *node = que.front();
            que.pop();
            res.push_back(node->val);
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.7 二叉树的层平均值

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        vector<double> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            double sum = 0;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                sum += node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(sum / size);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.8 N叉树的层序遍历

### 解题思路1：层序遍历

**思路解析:**

children指针数组可以用数组的方式调用

**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                vec.push_back(node->val);
                for(int i = 0; i < node->children.size(); i++)
                {
                    if(node->children[i]) que.push(node->children[i]);
                }
            }
            res.push_back(vec);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.9 在每个树行中找最大值

### 解题思路1：层序遍历

**思路解析:**

INT_MAX和max()函数

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            int maxNumber = INT_MIN;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                maxNumber = max(maxNumber, node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            res.push_back(maxNumber);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.10 填充每个节点的下一个右侧节点指针

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root == nullptr)
        {
            return nullptr;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                if(i < size - 1)
                {
                    node->next = que.front();
                }else
                {
                    node->next = nullptr;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.11 填充每个节点的下一个右侧节点指针II

### 解题思路1：层序遍历

**思路解析:**

和上一题一样的

**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if(root == nullptr)
        {
            return root;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                if(i < size - 1)
                {
                    node->next = que.front();
                }
                else
                {
                    node->next = nullptr;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 6.12 二叉树的最大深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        int depth = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i <size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth += 1;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：后序递归求高度

**思路解析:**

使用左树高度和右树高度

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //后序，左中右，求左面的深度和右面的深度，返回最大的深度+1
    int Traversal(TreeNode *node)
    {
        if(node == nullptr) return 0;
        int leftDepth = Traversal(node->left);
        int rightDepth = Traversal(node->right);
        return 1 + max(leftDepth, rightDepth);
    }

    int maxDepth(TreeNode* root) {
        return Traversal(root);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路3：前序递归求深度

**思路解析:**

使用当前深度depth和全局深度res

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //前序，中左右
    int res;
    void Traversal(TreeNode *node, int depth)
    {
        if(node->left == nullptr && node->right == nullptr)
        {
            res = max(depth, res);
        }
        if(node->left)
        {
            depth++;
            Traversal(node->left, depth);
            depth--;
        }
        if(node->right)
        {
            depth++;
            Traversal(node->right, depth);
            depth--;
        }
    }

    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        res = 0;
        Traversal(root, 1);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.13 二叉树的最小深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        int depth = 1;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left == nullptr && node->right == nullptr)
                {
                    return depth;
                }
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：后序遍历

**思路解析:**

使用左树高度和右树高度，还需要注意单边为空的这种特殊情况

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int Traversal(TreeNode *node)
    {
        if(node == nullptr) return 0;
        int leftLength = Traversal(node->left);
        int rightLength = Traversal(node->right);
        //单边有节点的情况
        if(node->left == nullptr && node->right != nullptr)
        {
            return 1 + rightLength;
        }
        if(node->left != nullptr && node->right == nullptr)
        {
            return 1 + leftLength;
        }
        //两边都有节点的情况
        int result = 1 + min(leftLength, rightLength);
        return result;

    }

    int minDepth(TreeNode* root) {
        return Traversal(root);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路3：前序遍历

**思路解析:**

使用当前深度depth和全局深度res

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //前序，中左右
    int res;
    void Traversal(TreeNode *node, int depth)
    {
        if(node->left == nullptr && node->right == nullptr)
        {
            res = min(res, depth);
        }
        if(node->left)
        {
            depth++;
            Traversal(node->left, depth);
            depth--;
        }
        if(node->right)
        {
            depth++;
            Traversal(node->right, depth);
            depth--;
        }
    }

    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        res = INT_MAX;
        Traversal(root, 1);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.14 翻转二叉树

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //1.层序遍历
        queue<TreeNode*> que;
        if(root == nullptr)
        {
            return root;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                swap(node->left, node->right);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：前序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //1.前序遍历
    void Traversal(TreeNode *root)
    {
        if(root == nullptr)
        {
            return;
        }
        swap(root->left, root->right);
        Traversal(root->left);
        Traversal(root->right);
    }
    TreeNode* invertTree(TreeNode* root) {
        Traversal(root);
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路3：前序迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //1.前序迭代
        stack<TreeNode*> stk;
        if(root == nullptr)
        {
            return root;
        }
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            swap(node->left, node->right);
            //2.前序迭代先放入右侧指针
            if(node->right) stk.push(node->right);
            if(node->left) stk.push(node->left);
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.15 N叉树的前序遍历

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    //递归前序遍历:中左右
    void Traversal(Node *root, vector<int> &res)
    {
        //1.确定弹出条件
        if(root == nullptr)
        {
            return;
        }
        //2.按照中左右的顺序进行递归调用
        res.push_back(root->val);
        for(int i = 0; i < root->children.size(); i++)
        {
            Traversal(root->children[i], res);
        }
    }

    vector<int> preorder(Node* root) {
        vector<int> res;
        Traversal(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> preorder(Node* root) {
        //前序迭代遍历
        stack<Node*> stk;
        vector<int> res;
        if(root == nullptr)
        {
            return res;
        }
        stk.push(root);
        while(!stk.empty())
        {
            Node *node = stk.top();
            stk.pop();
            res.push_back(node->val);
            int size = node->children.size();
            for(int i = size - 1; i >= 0; i--)
            {
                stk.push(node->children[i]);
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.16 N叉树的后续遍历

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    //后续遍历的递归：左右中
    void Traversal(Node *root, vector<int> &res)
    {
        //1.确定弹出条件
        if(root == nullptr)
        {
            return;
        }
        //2.根据左右中的顺序进行调用
        for(int i = 0; i < root->children.size(); i++)
        {
            Traversal(root->children[i], res);
        }
        res.push_back(root->val);
    }


    vector<int> postorder(Node* root) {
        vector<int> res;
        Traversal(root, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<int> postorder(Node* root) {
        //使用迭代后续遍历：左右中
        vector<int> res;
        if(root == nullptr) return res;
        stack<Node*> stk;
        stk.push(root);
        while(!stk.empty())
        {
            Node* node = stk.top();
            stk.pop();
            res.push_back(node->val);
            for(int i = 0; i < node->children.size(); i++)
            {
                stk.push(node->children[i]);
            }
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.17 对称二叉树

### 解题思路1：后序递归

**思路解析:**

判断外侧节点和内测节点是否相等

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //使用递归：判断外侧节点和内测节点是否相同
    bool compare(TreeNode *left, TreeNode *right)
    {
        //1.出递归条件
        if(left == nullptr && right != nullptr) return false;
        else if(left != nullptr && right == nullptr) return false;
        else if(left == nullptr && right == nullptr) return true;
        else if(left->val != right->val) return false;
        //2.进入递归
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        return outside && inside;
    }

    bool isSymmetric(TreeNode* root) {
        bool result = compare(root->left, root->right);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：栈或队列的迭代

**思路解析:**

和上面的同理

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        //迭代
        stack<TreeNode*> stk;
        stk.push(root->left);
        stk.push(root->right);
        while(!stk.empty())
        {  
            //1.将前两个节点出栈，分别为右和左
            TreeNode *rightNode = stk.top();
            stk.pop();
            TreeNode *leftNode = stk.top();
            stk.pop();
            //2.判断两个节点是否相等，如果相同，那么继续，如果不同，返回false
            //2.1 如果有一个节点存在，一个节点不存在，那么返回false
            if(leftNode == nullptr && rightNode != nullptr) return false;
            else if(leftNode != nullptr && rightNode == nullptr) return false;
            //2.2 如果两个节点都不存在，那么跳出此次循环
            else if(leftNode == nullptr && rightNode == nullptr) continue;
            //2.2 如果两个节点都存在，但是值不同，那么返回false
            else if(leftNode->val != rightNode->val) return false;
            //2.3 如果两个节点都存在，值相同，那么继续
            //3.将子节点压栈
            stk.push(leftNode->left);
            stk.push(rightNode->right);
            stk.push(leftNode->right);
            stk.push(rightNode->left);

        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.18 完全二叉树的节点个数

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        int depth = 0;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        while(!que.empty())
        {
            TreeNode *node = que.front();
            que.pop();
            if(node->left) que.push(node->left);
            if(node->right) que.push(node->right);
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：后序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //后序遍历：
    int Traversal(TreeNode *node)
    {
        if(node == nullptr)
        {
            return 0;
        }
        int leftNode = Traversal(node->left);
        int rightNode = Traversal(node->right);
        return 1 + leftNode + rightNode;

    }

    int countNodes(TreeNode* root) {
        return Traversal(root);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路3：前序遍历

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //前序遍历：设置全局遍历res记录个数
    int res;
    void Traversal(TreeNode *node)
    {
        if(node == nullptr) return;
        res++;
        if(node->left) Traversal(node->left);
        if(node->right) Traversal(node->right);
    }

    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        res = 0;
        Traversal(root);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.19 N叉树的最大深度

### 解题思路1：层序遍历

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node*> que;
        int depth = 0;
        if(root == nullptr)
        {
            return 0;
        }
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                Node *node = que.front();
                que.pop();
                for(int j = 0; j < node->children.size(); j++)
                {
                    que.push(node->children[j]);
                }
            }
            depth++;
        }
        return depth;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



### 解题思路2：后序递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int Traversal(Node *node)
    {
        int depth = 0;
        if(node == nullptr) return 0;
        for(int i = 0; i < node->children.size(); i++)
        {
            depth = max(depth, Traversal(node->children[i]));
        }
        return depth + 1;
    }

    int maxDepth(Node* root) {
        return Traversal(root);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路3：前序递归

**思路解析:**



**题解：**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int res;
    void Traversal(Node *node, int depth)
    {
        res = depth > res ? depth : res;
        if(node == nullptr)
        {
            return;
        }

        for(int i = 0; i < node->children.size(); i++)
        {
            depth++;
            Traversal(node->children[i], depth);
            depth--;
        }
        
    }

    int maxDepth(Node* root) {
        res = 0;
        if(root == nullptr) return 0;
        Traversal(root, 1);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

## 6.20 平衡二叉树

### 解题思路1：后序遍历

**思路解析:**

构造一个递归函数，如果是平衡二叉树则返回此处树的高度，否则返回-1；

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //用后序求左右高度差值，如果是平衡二叉树则返回高度，否则返回-1
    int Traversal(TreeNode *node)
    {
        if(node == nullptr) return 0;
        int leftHeight = Traversal(node->left);
        if(leftHeight == -1) return -1;
        int rightHeight = Traversal(node->right);
        if(rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
        
    }

    bool isBalanced(TreeNode* root) {
        return Traversal(root) == -1 ? false : true; 
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.21 二叉树的所有路径

### 解题思路1：递归回溯

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void Traversal(TreeNode *node, vector<int> &path, vector<string> &result)
    {
        path.push_back(node->val);
        if(node->left == nullptr && node->right == nullptr)
        {
            string sPath;
            for(int i = 0; i < path.size() - 1; i++)
            {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }

        if(node->left)
        {
            Traversal(node->left, path, result);
            path.pop_back();
        }
        if(node->right)
        {
            Traversal(node->right, path, result);
            path.pop_back();
        }

    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if(root == nullptr)
        {
            return result;
        }
        Traversal(root, path, result);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n^2)$



### 解题思路2：迭代（没学）

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 二叉树的周末总结(二)

### 1.相同的树

#### 解题思路1：后序

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool Traversal(TreeNode *node1, TreeNode *node2)
    {
        if(node1 == nullptr && node2 != nullptr) return false;
        else if(node1 != nullptr && node2 == nullptr) return false;
        else if(node1 == nullptr && node2 == nullptr) return true;
        else if(node1->val != node2->val) return false;
        bool leftNode = Traversal(node1->left, node2->left);
        bool rightNode = Traversal(node1->right, node2->right);
        return leftNode && rightNode;
    }

    bool isSameTree(TreeNode* p, TreeNode* q) {
        return Traversal(p, q);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 2.另一个树的子树

#### 解题思路1：递归+递归

**思路解析:**

递归+递归

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool Traversal(TreeNode *node1, TreeNode *node2)
    {
        if(node1 == nullptr && node2 != nullptr) return false;
        else if(node1 != nullptr && node2 == nullptr) return false;
        else if(node1 == nullptr && node2 == nullptr) return true;
        else if(node1->val != node2->val) return false;
        bool leftNode = Traversal(node1->left, node2->left);
        bool rightNode = Traversal(node1->right, node2->right);
        return leftNode && rightNode;

    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root == nullptr) return false;
        if(subRoot == nullptr) return true;
        return Traversal(root, subRoot) || 
        isSubtree(root->left, subRoot) || 
        isSubtree(root->right, subRoot);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.22 左叶子之和

### 解题思路1：前序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //前序遍历
    void Traversal(TreeNode *node, int &sum)
    {
        //判断一个节点是否为左叶子
        if(node == nullptr) return;
        if(node->left != nullptr && node->left->left == nullptr && node->left->right == nullptr)
        {
            //值入栈
            sum += node->left->val;
        }
        if(node->left)
        {
            Traversal(node->left, sum);
        }
        if(node->right)
        {
            Traversal(node->right, sum);
        }
    }

    int sumOfLeftLeaves(TreeNode* root) {
        int sum = 0;
        if(root == nullptr) return 0;
        Traversal(root, sum);
        return sum;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：前序迭代

**思路解析:**

其实层序迭代也可以

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        stack<TreeNode*> stk;
        stk.push(root);
        int sum = 0;
        while(!stk.empty())
        {
            TreeNode *node = stk.top();
            stk.pop();
            if(node->left != nullptr && node->left->left == nullptr && node->left->right == nullptr)
            {
                sum += node->left->val;
            }
            if(node->right) stk.push(node->right);
            if(node->left) stk.push(node->left);
        }
        return sum;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 6.23 找树左下角的值

### 解题思路1：层序迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        que.push(root);
        int result = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(i == 0) result = node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：前序递归

**思路解析:**

设定当前深度和最大深度进行比较

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth = INT_MIN;
    int res;
    void Traversal(TreeNode *node, int depth)
    {
        if(node->left == nullptr && node->right == nullptr)
        {
            if(depth > maxDepth)
            {
                maxDepth = depth;
                res = node->val;
            }
        }
        if(node->left)
        {
            depth++;
            Traversal(node->left, depth);
            depth--;
        }
        if(node->right)
        {
            depth++;
            Traversal(node->right, depth);
            depth--;
        }
    }
    int findBottomLeftValue(TreeNode* root) {
        res = 0;
        Traversal(root, 1);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.24 路径总和

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void Traversal(TreeNode* node, int targetSum, int sum, int &res)
    {
        if(node->left == nullptr && node->right == nullptr)
        {
            if(sum == targetSum)
            {
                res += 1;
            }
        }
        if(node->left)
        {
            sum += node->left->val;
            Traversal(node->left, targetSum, sum, res);
            sum -= node->left->val;
        }
        if(node->right)
        {
            sum += node->right->val;
            Traversal(node->right, targetSum, sum, res);
            sum -= node->right->val;
        }
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        int sum = 0;
        int res = 0;
        if(root == nullptr) return false;
        sum += root->val;
        Traversal(root, targetSum, sum, res);
        return res == 0 ? false : true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代(没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.25 路径之和II

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void Traversal(TreeNode *node, int count, vector<int> &path, vector<vector<int>> &res)
    {
        if(node->left == nullptr && node->right == nullptr)
        {
            if(count == 0)
            {
                res.push_back(path);
            }
        }
        if(node->left)
        {
            count -= node->left->val;
            path.push_back(node->left->val);
            Traversal(node->left, count, path, res);
            count += node->left->val;
            path.pop_back();
        }
        if(node->right)
        {
            count -= node->right->val;
            path.push_back(node->right->val);
            Traversal(node->right, count, path, res);
            count += node->right->val;
            path.pop_back();
        }

    }

    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        vector<vector<int>> res;
        vector<int> path;
        if(root == nullptr) return res;
        path.push_back(root->val);
        Traversal(root, targetSum - root->val, path, res);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

## 6.25 从中序与后序遍历序列构造二叉树

### 解题思路1：递归

**思路解析:**

先确定中节点，然后再分割，最后递归

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(vector<int> &inorder, vector<int> &postorder)
    {
        //确定退出条件
        if(postorder.size() == 0) return nullptr;
        //确定根节点值
        int rootValue = postorder[postorder.size() - 1];
        TreeNode *root = new TreeNode(rootValue);
        //如果是最后一个点了，那么返回
        if(postorder.size() == 1) return root;
        //确定中序切割大小
        int index1 = 0;
        for(index1; index1 < inorder.size(); index1++)
        {
            if(inorder[index1] == rootValue) break;
        }
        //切割中序数组
        vector<int> leftInorder(inorder.begin(), inorder.begin() + index1);
        vector<int> rightInorder(inorder.begin() + index1 + 1, inorder.end());

        //postorder舍弃最后一位元素
        postorder.resize(postorder.size() - 1);

        //切割后序数组
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root->left = Traversal(leftInorder, leftPostorder);
        root->right = Traversal(rightInorder, rightPostorder);
        return root;
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size() == 0 || postorder.size() == 0) return nullptr;
        return Traversal(inorder, postorder);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.26 从前序与中序遍历构造二叉树

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(vector<int> preorder,vector<int> inorder)
    {
        //确定退出条件
        if(preorder.size() == 0) return nullptr;
        //记录中节点的值
        int rootValue = preorder[0];
        TreeNode *root = new TreeNode(rootValue);
        //如果这个点已经是叶子节点，那么返回这个新创建的节点root
        if(preorder.size() == 1) return root;
        //找出中序数组里面等于rootValue这个值的地方
        int index_Inorder = 0;
        for(index_Inorder; index_Inorder < inorder.size(); index_Inorder++)
        {
            if(inorder[index_Inorder] == rootValue) break;
        }
        //从索引处,将中序数组分为两块
        vector<int> leftInorder(inorder.begin(), inorder.begin() + index_Inorder);
        vector<int> rightInorder(inorder.begin() + index_Inorder + 1, inorder.end());

        //将前序数组分块
        vector<int> leftPreorder(preorder.begin() + 1, preorder.begin() + 1 + leftInorder.size());
        vector<int> rightPreorder(preorder.begin() + 1 + leftInorder.size(), preorder.end());

        root->left = Traversal(leftPreorder, leftInorder);
        root->right = Traversal(rightPreorder, rightInorder);
        return root;
    }

    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return Traversal(preorder, inorder);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.27 最大二叉树

### 解题思路1：前序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(vector<int> nums)
    {
        if(nums.size() == 0) return nullptr;
        //找出数组中最大的值，令这个值为rootValue，构建新节点root
        int rootValue = INT_MIN;
        int indexA = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] > rootValue)
            {
                rootValue = nums[i];
                indexA = i;
            }
        }
        TreeNode *root = new TreeNode(rootValue);
        if(nums.size() == 1) return root;
        //按照index，将nums分为左数组和右数组
        vector<int> left_nums(nums.begin(), nums.begin() + indexA);
        vector<int> right_nums(nums.begin() + indexA + 1, nums.end());
        //开始递归
        root->left = Traversal(left_nums);
        root->right = Traversal(right_nums);
        //返回创建好的根节点root
        return root;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return Traversal(nums);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$





## 6.28 合并二叉树

### 解题思路1：前序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(TreeNode* root1, TreeNode* root2)
    {
        if(root1 == nullptr && root2 == nullptr) return nullptr;
        else if(root1 != nullptr && root2 == nullptr) return root1;
        else if(root1 == nullptr && root2 != nullptr) return root2;
        TreeNode *root = new TreeNode(root1->val + root2->val);
        root->left = Traversal(root1->left, root2->left);
        root->right = Traversal(root1->right, root2->right);
        return root;
    }

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr && root2 == nullptr) return nullptr;
        else if(root1 != nullptr && root2 == nullptr) return root1;
        else if(root1 == nullptr && root2 != nullptr) return root2;
        return Traversal(root1, root2);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：层序迭代(没写)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.29 二叉搜索书中的搜索

### 解题思路1：递归

**思路解析:**

二叉搜索树的意思就是，左面的值小于根节点，右面的值大于根节点

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode *Traversal(TreeNode *node, int val)
    {
        if(node == nullptr || node->val == val) return node;
        TreeNode *res = nullptr;
        if(node->val > val) res = Traversal(node->left, val);
        if(node->val < val) res = Traversal(node->right, val);
        return res;
    }

    TreeNode* searchBST(TreeNode* root, int val) {
        return Traversal(root, val);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == nullptr || root->val == val) return root;
        TreeNode* curr = root;
        stack<TreeNode*> stk;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                if(curr->val == val) return curr;
                curr = curr->right;
            }
        }
        return nullptr;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.30 验证二叉搜索树



### 解题思路1：中序遍历

**思路解析:**

按照左中右的顺序得到的二叉树数组，是一个递增数组

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    void Traversal(TreeNode *node)
    {
        if(node == nullptr) return;
        if(node->left) Traversal(node->left);
        res.push_back(node->val);
        if(node->right) Traversal(node->right); 
    }

    bool isValidBST(TreeNode* root) {
        res.clear();    //最好加上这句
        Traversal(root);
        for(int i = 1; i < res.size(); i++)
        {
            if(res[i] <= res[i - 1]) return false;
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：中序迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode *curr = root;
        TreeNode *pre = nullptr;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                if(pre != nullptr && curr->val <= pre->val) return false;
                pre = curr;
                curr = curr->right;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.31 二叉搜索树的最小绝对差

### 解题思路1：中序递归(双指针)

**思路解析:**

双指针

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int result = INT_MAX;
    TreeNode *pre = nullptr;
    void Traversal(TreeNode *node)
    {
        if(node == nullptr) return;
        Traversal(node->left);
        if(pre != nullptr)
        {
            result = min(result, node->val - pre->val);
        }
        pre = node;
        Traversal(node->right);
    }
    int getMinimumDifference(TreeNode* root) {
        Traversal(root);
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：中序迭代(双指针)

**思路解析:**

双指针来解决

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        TreeNode *curr = root;
        TreeNode *pre = nullptr;
        int res = INT_MAX;
        stack<TreeNode*> stk;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                if(pre != nullptr)
                {
                    res = min(res, curr->val - pre->val);
                }
                pre = curr;
                curr = curr->right;
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.32 二叉搜索树中的众数

### 解题思路1：中序递归(双指针)

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> res;
    int count = 1;
    int maxCount = 0;
    TreeNode* prev = nullptr;
    void Traversal(TreeNode *node)
    {
        if(node == nullptr) return;
        Traversal(node->left);
        if(prev != nullptr && prev->val == node->val) count++;
        else count = 1;
        prev = node;
        if(count == maxCount) res.push_back(node->val);
        else if(count > maxCount)
        {
            res.clear();
            maxCount = count;
            res.push_back(node->val);
        }
        Traversal(node->right);

    }
    vector<int> findMode(TreeNode* root) {
        count = 1;
        maxCount = 0;
        prev = nullptr;
        res.clear();
        Traversal(root);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：中序迭代(双指针)

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        int count = 1;
        int maxCount = 0;
        TreeNode* curr = root;
        TreeNode* prev = nullptr;
        stack<TreeNode*> stk;
        vector<int> res;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->left;
            }else
            {
                curr = stk.top();
                stk.pop();
                if(prev != nullptr && prev->val == curr->val) count++;
                else count = 1;
                prev = curr;

                if(count == maxCount) res.push_back(curr->val);
                else if(count > maxCount)
                {
                    res.clear();
                    maxCount = count;
                    res.push_back(curr->val);
                }

                curr = curr->right;
            }
        }

        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.33 二叉树的最近公共先祖

### 解题思路1：后序递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(TreeNode* root, TreeNode* p, TreeNode* q)
    {
        if(root == NULL) return NULL;
        if(root == p || root == q) return root;
        TreeNode *left = Traversal(root->left, p, q);
        TreeNode *right = Traversal(root->right, p, q);
        if(left != NULL && right != NULL) return root;
        else if(left != NULL && right == NULL) return left;
        else if(left == NULL && right != NULL) return right;
        else return NULL;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return Traversal(root, p ,q);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.34 二叉搜索树的最近公共祖先

本题可以应用上题的代码，也可以利用二叉搜索树的特性来解题

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* Traversal(TreeNode* root, TreeNode* p, TreeNode* q)
    {
        if(root == nullptr || root->val == p->val || root->val == q->val) return root;
        else if(root->val > p->val && root->val > q->val) return Traversal(root->left, p, q);
        else if(root->val < p->val && root->val < q->val) return Traversal(root->right, p, q);
        return root;
    }

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return Traversal(root, p, q);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root)
        {
            if(root->val > p->val && root->val > q->val) root = root->left;
            else if(root->val < p->val && root->val < q->val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.35 二叉搜索树中的插入操作

### 解题思路1：递归

**思路解析:**

一定会在叶子节点中找到地方来插入

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode *parent;
    void Traversal(TreeNode *root, int val)
    {
        if(root == nullptr)
        {
            TreeNode *node = new TreeNode(val);
            if(parent->val > val) parent->left = node;
            else parent->right = node;
            return;
        }
        parent = root;
        if(root->val > val) Traversal(root->left, val);
        if(root->val < val) Traversal(root->right, val);
        return;

    }
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr)
        {
            TreeNode *node = new TreeNode(val);
            return node;
        }
        Traversal(root, val);
        return root;
    }
};
//或者这样
class Solution {
public:
    TreeNode* parent = nullptr;
    void Traversal(TreeNode* curr, int val)
    {
        if(curr == nullptr) return;
        if(curr->val > val)
        {
            parent = curr;
            if(curr->left == nullptr)
            {
                TreeNode* node = new TreeNode(val);
                parent->left = node;
            }
            Traversal(curr->left, val);
        }
        if(curr->val < val)
        {
            parent = curr;
            if(curr->right == nullptr)
            {
                TreeNode* node = new TreeNode(val);
                parent->right = node;
            }
            Traversal(curr->right, val);
        }
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr)
        {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        Traversal(root, val);
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == nullptr)
        {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        TreeNode* curr = root;
        while(curr)
        {
            if(curr->val > val)
            {
                if(curr->left == nullptr)
                {
                    TreeNode* node = new TreeNode(val);
                    curr->left = node;
                    break;
                }
                curr = curr->left;
            }
            else if(curr->val < val)
            {
                if(curr->right == nullptr)
                {
                    TreeNode* node = new TreeNode(val);
                    curr->right = node;
                    break;
                }
                curr = curr->right;
            }
        }
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.36 删除二叉搜索树中的节点

### 解题思路1：递归

**思路解析:**

要分五种情况来讨论

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(TreeNode* root, int val)
    {
        if(root == nullptr) return nullptr;
        if(root->val == val)
        {
            if(root->left == nullptr && root->right == nullptr)
            {
                delete root;
                return nullptr;
            }
            else if(root->left == nullptr && root->right != nullptr)
            {
                TreeNode *node = root->right;
                delete root;
                return node;
            }
            else if(root->left != nullptr && root->right == nullptr)
            {
                TreeNode *node = root->left;
                delete root;
                return node;
            }
            else
            {
                TreeNode *curr = root->right;
                while(curr->left != nullptr) curr = curr->left;
                curr->left = root->left;
                TreeNode *temp = root->right;
                delete root;
                return temp;
            }

        }
        if(root->val > val) root->left = Traversal(root->left, val);
        if(root->val < val) root->right = Traversal(root->right, val);
        return root;
    }

    TreeNode* deleteNode(TreeNode* root, int key) {
        return Traversal(root, key);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路2：迭代(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.37 修剪二叉搜索树



### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(TreeNode* root, int low , int high)
    {
        if(root == nullptr) return nullptr;
        if(root->val < low)
        {
            TreeNode* right =Traversal(root->right, low, high);
            return right;
        }
        if(root->val > high)
        {
            TreeNode* left = Traversal(root->left, low, high);
            return left;
        }
        root->left = Traversal(root->left, low, high);
        root->right = Traversal(root->right, low, high);
        return root;
    }

    TreeNode* trimBST(TreeNode* root, int low, int high) {
        return Traversal(root, low, high);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路2：迭代(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.38 将有序数组转换为二叉搜索树

### 解题思路1：递归

**思路解析:**

将数组分为左闭右闭的子数组，然后进行递归构造

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* Traversal(vector<int> &nums, int left, int right)
    {
        if(left > right) return nullptr;
        int mid = (left + right) / 2;
        TreeNode *root = new TreeNode(nums[mid]);
        root->left = Traversal(nums, left, mid - 1);
        root->right = Traversal(nums, mid + 1, right);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return Traversal(nums, 0, nums.size() - 1);
    }
};
//下面这种也可以
class Solution {
public:
    TreeNode* Traversal(vector<int>& nums)
    {
        if(nums.size() == 0) return nullptr;
        int n = nums.size();
        int mid = n / 2;
        int rootValue = nums[mid];
        TreeNode* root = new TreeNode(rootValue);
        vector<int> leftNums(nums.begin(), nums.begin() + mid);
        vector<int> rightNums(nums.begin() + mid + 1, nums.end());
        root->left = Traversal(leftNums);
        root->right = Traversal(rightNums);
        return root;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return Traversal(nums);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代(还没学)

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 6.39 把二叉搜索树转换为累加数

### 解题思路1：递归

**思路解析:**



**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sum = 0;
    void Traversal(TreeNode* root)
    {
        if(root == nullptr) return;
        Traversal(root->right);
        root->val += sum;
        sum = root->val;
        Traversal(root->left);
    }

    TreeNode* convertBST(TreeNode* root) {
        sum = 0;
        Traversal(root);
        return root;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：迭代

**思路解析:**

按照右中左的顺序迭代即可

**题解：**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        TreeNode* curr = root;
        stack<TreeNode*> stk;
        int pre = 0;
        while(curr != nullptr || !stk.empty())
        {
            if(curr != nullptr)
            {
                stk.push(curr);
                curr = curr->right;
            }
            else
            {
                curr = stk.top();
                stk.pop();
                curr->val += pre;
                pre = curr->val;
                curr = curr->left;
            }
        }   
        return root; 
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 七.回溯



## 7.1 组合

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(int n, int k, int startIndex)
    {
        if(path.size() == k)
        {
            res.push_back(path);
            return;
        }
        //也可以写为如下剪枝：for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
        for(int i = startIndex; i <= n; i++)
        {
            path.push_back(i);
            backtracking(n, k, i + 1);
            path.pop_back();
        }

    }

    vector<vector<int>> combine(int n, int k) {
        res.clear();
        path.clear();
        backtracking(n, k, 1);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$



## 7.2 组合总和III

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    int sum = 0;
    void backtracking(int k, int n, int startNum, int sum)
    {
        int min_num = (1 + k) * k / 2;
        int max_num = (9 + (9 - k + 1)) * k / 2; 
        if(n < min_num || n > max_num) return;
        if(path.size() == k && sum == n)
        {
            res.push_back(path);
        }
        for(int i = startNum; i < 10; i++)
        {
            path.push_back(i);
            sum += i;
            backtracking(k, n, i + 1, sum);
            sum -= i;
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        path.clear();
        res.clear();
        sum = 0;
        backtracking(k, n, 1, sum);

        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 7.3 电话号码的字母组合

### 解题思路1：回溯

**思路解析:**

先构建对应字符串，然后将digits转变为int

**题解：**

```c++
class Solution {
public:
    string leterMaps[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    vector<string> res;
    string s;
    void backtracking(const string &digits, int index)
    {
        if(index == digits.size())
        {
            res.push_back(s);
            return;
        }
        int num = digits[index] - '0'; //这里只能用单引号，否则无法进行ASCII码的转换
        string leter = leterMaps[num];
        for(int i = 0; i < leter.size(); i++)
        {
            s.push_back(leter[i]);
            backtracking(digits, index + 1);
            s.pop_back();
        }
        return;
    }

    vector<string> letterCombinations(string digits) {
        res.clear();
        s.clear();
        if(digits.size() == 0) return res;
        backtracking(digits, 0);
        return res;
    }
};
//用下面的版本可能更好理解一些
class Solution {
public:
    unordered_map<char, string> leterMaps = {
        {'2', "abc"},
        {'3', "def"},
        {'4', "ghi"},
        {'5', "jkl"},
        {'6', "mno"},
        {'7', "pqrs"},
        {'8', "tuv"},
        {'9', "wxyz"}
    };
    string s;
    vector<string> res;
    void backtracking(const string& digits, int start)
    {
        if(digits.size() == start)
        {
            res.push_back(s);
            return;
        }
        char num = digits[start];
        string leter = leterMaps[num];
        for(int i = 0; i < leter.size(); i++)
        {
            s.push_back(leter[i]);
            backtracking(digits, start + 1);
            s.pop_back();
        }
    }

    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) return res;
        backtracking(digits, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(3^m * 4^n)$ 其中 m 是对应三个字母的数字个数，n 是对应四个字母的数字个数
- 空间复杂度：$O(3^m * 4^n)$



## 7.4 组合总和

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    void backtrackint(const vector<int>& candidates, int target, int sum, int startIndex)
    {
        if(sum > target)
        {
            return;
        }
        if(sum == target)
        {
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++)
        {
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtrackint(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        sum = 0;
        backtrackint(candidates, target, sum, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：排序+剪枝

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    void backtrackint(const vector<int>& candidates, int target, int sum, int startIndex)
    {
        if(sum > target)
        {
            return;
        }
        if(sum == target)
        {
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
        //for(int i = startIndex; i < candidates.size(); i++)
        {
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtrackint(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();
        }
        return;
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        sum = 0;
        sort(candidates.begin(), candidates.end());
        backtrackint(candidates, target, sum, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 7.5 组合总和II

### 解题思路1：排序+回溯+去重

**思路解析:**

先排序，然后需要有一个说明之前的元素是否用过的数组uesd，适当的剪枝

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    void backtrackint(const vector<int>& candidates, int target, int start, vector<bool>& used)
    {
        if(sum == target)
        {
            res.push_back(path);
            return;
        }
        //其实这里也可以使用start进行降重，后面写的时候可以试一下
        for(int i = start; i < candidates.size() && sum + candidates[i] <= target; i++)
        {
            if(i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false)
            {
                continue;
            }
            path.push_back(candidates[i]);
            sum += candidates[i];
            used[i] = true;
            backtrackint(candidates, target, i + 1, used);
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }

    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        res.clear();
        path.clear();
        sum = 0;
        sort(candidates.begin(), candidates.end());
        vector<bool> used(candidates.size(), false);
        backtrackint(candidates, target, 0, used);
        return res;
    }
};

class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    int sum = 0;
    void backtracking(vector<int>& candidates, int target, int start)
    {
        if(sum > target) return;
        if(sum == target)
        {
            res.push_back(path);
            return;
        }
        for(int i = start; i < candidates.size(); i++)
        {
            if(i > start && candidates[i] == candidates[i - 1]) continue;
            path.push_back(candidates[i]);
            sum += candidates[i];
            backtracking(candidates, target, i + 1);
            sum -= candidates[i];
            path.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$



## 7.6 分割回文串

### 解题思路1：回溯

**思路解析:**

构建一个判断字符串是不是回文串的子函数，是回文串的话就插入

**题解：**

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;
    void backtrackint(const string& s, int start)
    {
        if(start >= s.size())
        {
            res.push_back(path);
            return;
        }
        for(int i = start; i < s.size(); i++)
        {
            if(isPalindrome(s, start, i))
            {
                //第一个参数是起始位置，第二个参数是截取的字符串长度
                string str = s.substr(start, i - start + 1);
                path.push_back(str);
            }else
            {
                continue;
            }
            backtrackint(s, i + 1);
            path.pop_back();
        }
    }
    bool isPalindrome(const string& s, int start, int end)
    {
        for(int i = start, j = end; i < j; i++, j --)
        {
            if(s[i] != s[j]) return false;
        }
        return true;
    }

    vector<vector<string>> partition(string s) {
        res.clear();
        path.clear();
        backtrackint(s, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 7.7 复原IP地址

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<string> res;
    void backtracking(string& s, int start, int pointNum)
    {
        if(pointNum == 3)
        {
            if(isValid(s, start, s.size() - 1))
            {
                res.push_back(s);
            }
            return;
        }
        for(int i = start; i < s.size(); i++)
        {
            if(isValid(s, start, i))
            {
                s.insert(s.begin() + i + 1, '.');
                pointNum++;
                backtracking(s, i + 2, pointNum);
                pointNum--;
                s.erase(s.begin() + i + 1);

            }
            else break;
        }
    }
    //左闭右闭函数
    bool isValid(const string& s, int start, int end)
    {
        if(start > end)
        {
            return false;
        }
        if(s[start] == '0' && start != end)
        {
            return false;
        }
        int num = 0;
        for(int i = start; i <= end; i++)
        {
            if(s[i] > '9' || s[i] < '0')
            {
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if(num > 255)
            {
                return false;
            }
        }  
        return true;
    }


    vector<string> restoreIpAddresses(string s) {
        res.clear();
        if(s.size() < 4 || s.size() > 12) return res;
        backtracking(s, 0, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(3*4)$
- 空间复杂度：$O(n)$



## 7.8 子集



### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int start)
    {
        res.push_back(path);
        if(start >= nums.size())	//判断条件可以不写
        {
            return;
        }
        for(int i = start; i < nums.size(); i++)
        {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

    vector<vector<int>> subsets(vector<int>& nums) {
        res.clear();
        path.clear();
        backtracking(nums, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$



## 7.9 子集II

### 解题思路1：回溯

**思路解析:**

也可以使用start来降重，后面有兴趣的话可以学一下

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int start, vector<bool> used)
    {
        res.push_back(path);
        if(start >= nums.size())
        {
            return;
        }
        for(int i = start; i < nums.size(); i++)
        {
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false)
            {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i + 1, used);
            path.pop_back();
            used[i] = false;
        }

    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, 0, used);
        return res;
    }
};
//下面这样也可以
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int start)
    {
        res.push_back(path);
        if(start >= nums.size())
        {
            return;
        }
        for(int i = start; i < nums.size(); i++)
        {
            if(i > start && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        backtracking(nums, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$

## 7.10 非递减子序列

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, int start)
    {
        if(path.size() >= 2)
        {
            res.push_back(path);
        }
        unordered_set<int> uset;
        for(int i = start; i < nums.size(); i++)
        {
            if(!path.empty() && nums[i] < path.back() || uset.find(nums[i]) != uset.end())
            {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }

    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        res.clear();
        path.clear();
        backtracking(nums, 0);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*2^n)$
- 空间复杂度：$O(n)$



## 7.11 全排列

### 解题思路1：回溯

**思路解析:**



**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, vector<bool> &used)
    {
        if(path.size() == nums.size())
        {
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++)
        {
            if(used[i] == true)
            {
                continue;
            }
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }

    }

    vector<vector<int>> permute(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n!)$
- 空间复杂度：$O(n)$

## 7.12 全排列II

### 解题思路1：回溯

**思路解析:**

有不懂的地方就画图，把树画出来就理解了

**题解：**

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backtracking(vector<int>& nums, vector<bool> &used)
    {
        if(path.size() == nums.size())
        {
            res.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++)
        {
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            if(used[i] == false)
            {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }

    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        res.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, used);
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n!*2^2)$
- 空间复杂度：$O(n)$



# 八.贪心算法

## 8.1 分发饼干

### 解题思路1：动态规划

**思路解析:**

局部最优解到全局最优解

**题解：**

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size() - 1;
        int result = 0;
        for(int i = g.size() - 1; i >= 0; i--)
        {
            if(index >= 0 && s[index] >= g[i])
            {
                result++;
                index--;
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlong_n)$
- 空间复杂度：$O(1)$



## 8.2 摆动序列

### 解题思路1：动态规划

**思路解析:**

在上升坡阶段，只让up增大一次，在下降坡阶段，只让down增大一次

想象一下 `nums` 数组是一系列山脉的高度点。

- ⛰️ **`up`**: 这个登山者只记录**最后一步是上坡 (`/`)** 的最长“摆动”路径经过了几个点。
- ⛰️ **`down`**: 这个登山者只记录**最后一步是下坡 (`\`)** 的最长“摆动”路径经过了几个点。

**题解：**

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int len = nums.size();
        if(len < 2) return len;
        int up = 1, down = 1；
        for(int i = 1; i < len; i++)
        {
            if(nums[i] > nums[i - 1]) up = down + 1;
            else if(nums[i] < nums[i - 1]) down = up + 1;
        }
        return max(up, down);
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 8.3 最大子数组和

### 解题思路1：贪心算法

**思路解析:**

如果碰到大的和，那么就更新result的值；如果count已经是负数了，那么就从0重新相加，由于是连续取值，所以可以达到贪心的思想

**题解：**

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int ans = INT_MIN;
        int temp = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            temp += nums[i];
            ans = max(ans, temp);
            if(temp < 0) temp = 0;
        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$





## 8.4 买卖股票的最佳时机II

### 解题思路1：贪心算法

**思路解析:**

只要上升，就把利润相加

**题解：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1; i < prices.size(); i++)
        {
            if(prices[i] - prices[i - 1] > 0)
            {
                result += prices[i] - prices[i - 1];
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 8.5 跳跃游戏

### 解题思路1：贪心算法

**思路解析:**

通过覆盖范围来确定跳跃距离

**题解：**

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;	//表示了从起点0出发，可以跳到的最远的距离
        int len = nums.size();
        if(len == 1) return true;
        for(int i = 0; i <= cover; i++)
        {
            cover = max(i + nums[i], cover);
            if(cover >= len - 1) return true;
        }
        return false;
    }
};
//下面这个更好理解，和跳跃游戏II非常相似
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int currDinstance = 0;
        int nextDistance = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            nextDistance = max(i + nums[i], nextDistance);
            if(i == currDinstance)
            {
                currDinstance = nextDistance;
                if(nextDistance >= nums.size() - 1) return true;
            }
        }
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 8.6 跳跃游戏II

### 解题思路1：贪心算法

**思路解析:**

最大边界用nextDistance来记录，当前能走到的最大边界用curDistance来记录，如果当前能走到的最大边界已经到了末尾，那么anx++，直到nextDistance包含了末尾，那么此时跳出循环，返回ans

**题解：**

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;
        int curDistance = 0;
        int ans = 0;
        int nextDistance = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            nextDistance = max(nums[i] + i, nextDistance);
            if(i == curDistance)
            {
                ans++;
                curDistance = nextDistance;
                if(nextDistance >= nums.size() - 1) break;
            }

        }
        return ans;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 8.7 K次取反后最大化的数组和

### 解题思路1：贪心算法

**思路解析:**

先按照绝对值从大到小进行排列，然后将负值变为正值，如果最后的k有剩余，那么就让最小的那个值变为负，最后返回result

这里的排序算法很巧妙，可以记一下

**题解：**

```c++
class Solution {
public:
    static bool cmp(int a, int b)
    {
        return abs(a) > abs(b);
    }

    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end(), cmp);
        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] < 0 && k > 0)
            {
                nums[i] *= -1;
                k--;
            }
        }
        if(k % 2 == 1) nums[nums.size() - 1] *= -1;
        int result = 0;
        for(int num: nums) result += num;
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(1)$



## 8.8 加油站

### 解题思路1：贪心算法

**思路解析:**

如果总油量消耗大于等于0，那么一定可以跑完这一圈的，让start在当前消耗小于0后面开始，由于总和大于0，所以后面消耗的总和一定大于前面消耗的总和

**题解：**

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSun = 0;
        int start = 0;
        for(int i = 0; i < gas.size(); i++)
        {
            curSum += (gas[i] - cost[i]);
            totalSun += (gas[i] - cost[i]);
            if(curSum < 0)
            {
                start = i + 1;
                curSum = 0;
            }
        }
        if(totalSun < 0) return -1;
        return start;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 8.9 分发糖果

### 解题思路1：贪心算法

**思路解析:**

要从前向后和从后向前两次来得到结果，注意从后向前时，要注意得到的是最大值

**题解：**

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        //从前向后
        for(int i = 1; i < ratings.size(); i++)
        {
            if(ratings[i] > ratings[i - 1])
            {
                candyVec[i] = candyVec[i - 1] + 1;
            }
        }
        //从后向前
        for(int i = ratings.size() - 2; i >= 0; i--)
        {
            if(ratings[i] > ratings[i + 1])
            {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        int result = 0;
        for(int num : candyVec) result += num;
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 8.10 柠檬水找零

### 解题思路1：正常判断

**思路解析:**

没啥意思的一道题

**题解：**

```c++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int fiveNum = 0;
        int tenNum = 0;
        for(int i = 0; i < bills.size(); i++)
        {
            if(bills[i] == 5) fiveNum++;
            if(bills[i] == 10)
            {
                if(fiveNum < 1) return false;
                else
                {
                    tenNum++;
                    fiveNum--;
                }
            }
            if(bills[i] == 20)
            {
                //五元和十元都至少有一张的时候可以找零
                if(tenNum >= 1 && fiveNum >= 1)
                {
                    fiveNum--;
                    tenNum--;
                }
                //五元大于三张并且只有五元时也可以找零
                else if(tenNum == 0 && fiveNum >=3)
                {
                    fiveNum = fiveNum - 3;
                }
                //都是10元或者五元不够的时候，返回false
                else return false;
            }
        }
        return true;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

## 8.11 根据身高重建队列

### 解题思路1：贪心算法

**思路解析:**

先按照身高排序，如果身高相同，那么按照前面人数少的来进行排序，最后再按照k的大小来插入，排序的cmp很奇妙，可以多理解一下

**题解：**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        if(a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(), people.end(), cmp);
        vector<vector<int>> que;
        for(int i = 0; i < people.size(); i++)
        {
            int position = people[i][1];
            que.insert(que.begin() + position, people[i]);
        }
        return que;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n+n^2)$
- 空间复杂度：$O(n)$



## 8.12 用最少数量的箭引爆气球

### 解题思路1：贪心算法

**思路解析:**

先按照左边界进行从小到大的排序

**题解：**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        if(points.size() == 0) return 0;
        sort(points.begin(), points.end(), cmp);
        int result = 1;
        for(int i = 1; i < points.size(); i++)
        {
            //左边界大于右边界时，一定要射出一支箭
            if(points[i][0] > points[i - 1][1]) result++;
            //如果有重叠，那么让右边界的值为两个长度的最小值
            else points[i][1] = min(points[i - 1][1], points[i][1]);
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(n)$



## 8.13 无重叠区间

### 解题思路1：贪心算法

**思路解析:**



**题解：**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if(intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);
        int result = 0;
        int end = intervals[0][1];  //让end为第一个区间的右节点
        for(int i = 1; i < intervals.size(); i++)
        {
            //如果节点i的左节点和end没有相交，那么让end为i节点的右节点
            if(intervals[i][0] >= end)
            {
                end = intervals[i][1];
            }//如果有相交，那么让end为end和i的右节点二者中的最小值
            else
            {
                end = min(end, intervals[i][1]);
                result++;
            }
        }
        return result;
    }
};
//也可以用下面的代码，这样更好理解
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), cmp);
        int res = 0;
        for(int i = 1; i < intervals.size(); i++)
        {
            if(intervals[i][0] < intervals[i - 1][1])
            {
                intervals[i][1] = min(intervals[i][1], intervals[i - 1][1]);
                res++;
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(n)$



## 8.14 划分字母区间

### 解题思路1：贪心算法

**思路解析:**

先统计每个字母出现的最远位置，然后更新迭代right和left

**题解：**

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int hash[27] = {0};
        //统计每一个字符最后出现的位置
        for(int i = 0; i < s.size(); i++)
        {
            hash[s[i] - 'a'] = i;
        }
        vector<int> res;
        int left = 0;
        int right = 0;
        for(int i = 0; i < s.size(); i++)
        {
            right = max(right, hash[s[i] - 'a']);//找到字符的最远右边界
            if(i == right)
            {
                res.push_back(right - left + 1);
                left = i + 1;
            }
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

## 8.15 合并区间

### 解题思路1：贪心算法

**思路解析:**

将压入的空间最后一位与新区间的左值进行对比

**题解：**

```c++
class Solution {
public:
    static bool cmp(const vector<int>& a, const vector<int>& b)
    {
        return a[0] < b[0];
    }

    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if(intervals.size() == 0) return res;
        //按照左节点从小到大排序
        sort(intervals.begin(), intervals.end(), cmp);
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++)
        {  
            //有重叠的情况下，合并区间
            if(res.back()[1] >= intervals[i][0])
            {
                res.back()[1] = max(res.back()[1], intervals[i][1]);
            }
            else
            {
                res.push_back(intervals[i]);    
            }
        }  
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(nlog_n)$
- 空间复杂度：$O(log_n)$



## 8.16 单调递增的数字

### 解题思路1：贪心算法

**思路解析:**

先将数字转为字符串，然后令前面的数字大于后面的数字i处记下flag，并让i-1的值减一，最后将flag后面的值全部置换为9

**题解：**

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string strNum = to_string(n);
        int flag = strNum.size();
        for(int i = strNum.size() - 1; i > 0; i--)
        {
            if(strNum[i - 1] > strNum[i])
            {
                flag = i;
                strNum[i - 1]--;
            }
        }
        for(int i = flag; i < strNum.size(); i++)
        {
            strNum[i] = '9';
        }
        return stoi(strNum);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



# 九.动态规划

动态规划类题目的解题步骤：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 9.1 斐波那契树

### 解题思路1：动态规划

**思路解析:**

确定dp的含义，确定递推公式，获得初始化，确定遍历顺序，打印dp数组纠错

**题解：**

```c++
class Solution {
public:
    int fib(int n) {
        if(n == 0) return 0;
        if(n == 1) return 1;
        vector<int> dp(n + 1);
        dp[0] = 0, dp[1] = 1;
        for(int i = 2; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$



## 9.2 爬楼梯

### 解题思路1：动态规划

**思路解析:**

dp[i]的定义：到达第i级台阶所有不同走法的总数量，注意：这里是数量，而不是步数

如果想要爬到第n阶，那么只有两种情况可以爬到第n阶：第一种就是从n-1阶爬一步、第二种就是从n-2阶爬两步。

而到达n-1阶的数量为dp[n - 1]，到达n-2阶的数量为dp[n - 2]，所以到达第n阶的数量应该是dp[n - 1] + dp[n - 2]

**题解：**

```c++
class Solution {
public:
    int climbStairs(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

## 9.3 使用最小花费爬楼梯

### 解题思路1：动态规划

**思路解析:**

dp[i]: 爬到第i层需要的最小耗费

**题解：**

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int len = cost.size();
        vector<int> dp(len + 1);
        //dp[i]代表了爬到第i层所需要的最小花费
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i <= len; i++)
        {
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[len];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

## 9.4 不同路径

### 解题思路1：动态规划

**思路解析:**

![62.不同路径1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/20201209113631392.png)

**题解：**

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int j = 0; j < n; j++) dp[0][j] = 1;
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m*n)$
- 空间复杂度：$O(m*n)$



## 9.5 不同路径II

### 解题思路1：动态规划

**思路解析:**

有障碍物的地方设置为0就好

**题解：**

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        //获得行数m和列数n
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if(obstacleGrid[0][0] == 1 || obstacleGrid[m - 1][n - 1] == 1) return 0;
        //创建m行n列的dp数组，每个位置的值都是0
        vector<vector<int>> dp(m, vector<int>(n, 0));
        //让第一列中没有障碍物的点为1
        for(int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        //让第一行中没有障碍物的点为1
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                //如果碰到了障碍物那么就跳出本次循环，否则更新dp数组
                if(obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
//下面的写法更加清晰一些：
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for(int j = 0; j < n; j++)
        {
            if(obstacleGrid[0][j] != 1)
            {
                dp[0][j] = 1;
            }else break;
        }
        for(int i = 0; i < m; i++)
        {
            if(obstacleGrid[i][0] != 1)
            {
                dp[i][0] = 1;
            }else break;
        }
        for(int i = 1; i < m; i++)
        {
            for(int j = 1; j < n; j++)
            {
                if(obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n*m)$
- 空间复杂度：$O(n*m)$



## 9.6 整数拆分

### 解题思路1：动态规划

**思路解析:**

dp[i]的定义：将正整数i拆分成至少两个正整数之和后，这些整数的最大乘积

**题解：**

```c++
class Solution {
public:
    int integerBreak(int n) {
        //创建一个长度为n+1的dp数组，默认值是0
        vector<int> dp(n + 1);
        dp[2] = 1;
        for(int i = 3; i <= n; i++)
        {
            for(int j = 1; j <= i / 2; j++)
            {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$



## 9.7 不同的二叉搜索树

### 解题思路1：动态规划

**思路解析:**

dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。

**题解：**

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= i; j++)
            {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$



## 9.8 0-1背包

1.dp[i] [j]的含义： **表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**

2.递归公式的推导抽象化如下：

- **不放物品i**：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
- **放物品i**：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

3.dp数组的初始化：

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

### 解题思路1：二维数组

**思路解析:**

dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少

两种情况，分别是放物品1 和 不放物品1，我们要取最大值（毕竟求的是最大价值）

```
dp[1][4] = max(dp[0][4], dp[0][1] + 物品1 的价值)
```

以上过程，抽象化如下：

- **不放物品i**：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
- **放物品i**：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);`

**题解：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, baggage;
    //n代表了物品的种类，baggage代表了行李箱的最大空间
    cin >> n >> baggage;
    //weight为物体的重量，cost为物体的价值
    vector<int> weight(n);
    vector<int> value(n);
    for(int i = 0; i < n; i++)
    {
        cin >> weight[i];
    }
    for(int i = 0; i < n; i++)
    {
        cin >> value[i];
    }
    //构建dp数组，dp[i][j]代表了，行李箱重量为j时，从0-i物品任取拥有的最大价值
    vector<vector<int>> dp(n, vector<int>(baggage + 1, 0));
    for(int j = 0; j <= baggage; j++)
    {
        if(j > weight[0]) dp[0][j] = value[0];
    }
    for(int i = 1; i < n; i++)
    {
        for(int j = 0; j <= baggage; j++)
        {
            if(j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[n - 1][baggage] << endl;
    return 0;
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路1：一维数组

**思路解析:**

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

**题解：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, baggage;
    //n代表了物品的种类，baggage代表了行李箱的最大空间
    cin >> n >> baggage;
    //weight为物体的重量，cost为物体的价值
    vector<int> weight(n);
    vector<int> value(n);
    for(int i = 0; i < n; i++)
    {
        cin >> weight[i];
    }
    for(int i = 0; i < n; i++)
    {
        cin >> value[i];
    }
    //构建dp数组，dp[j]代表了，最大承重为j时，最大价值
    vector<int> dp(baggage + 1, 0);
    for(int i = 0; i < n; i++)
    {
        for(int j = baggage; j >= 0; j--)
        {
            if(j < weight[i]) continue;
            else dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[baggage] << endl;
    return 0;
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.9 分割等和子集

### 解题思路1：01背包

**思路解析:**

当 dp[target] == target 的时候，背包就装满了

**题解：**

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(int num: nums) sum += num;
        if(sum % 2 == 1) return false;
        int total = sum / 2;
        vector<int> dp(100001, 0);
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = total; j >= nums[i]; j--)
            {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        if(dp[total] == total) return true;
        return false;
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$



## 9.10 最后一块石头的重量II

### 解题思路1：01背包

**思路解析:**

本题其实是尽量让石头分成重量相同的两堆（尽可能相同），相撞之后剩下的石头就是最小的。

**题解：**

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for(int num: stones) sum += num;
        int target = sum / 2;
        for(int i = 0; i < stones.size(); i++)
        {
            for(int j = target; j >= stones[i]; j--)
            {
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m*n)$
- 空间复杂度：$O(m)$



## 9.11 目标和

### 解题思路1：01背包

**思路解析:**

如果想让目标和为target，那么令正数的和为left，负数的和为right，则

left + right = sum

left - right = target

所以left = (sum + target) / 2；这个数一定是正数

dp[j]数组的定义为：填满j（包括j）这么大容积的包，有dp[j]种方法。

**题解：**

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for(int num: nums) sum += num;
        if(abs(target) > sum) return 0;	//这里必须要用绝对值，否则left可能为负数
        if((target + sum) % 2 == 1) return 0;
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;	//这里可以理解为，背包容积为0时，填满这个背包的方法只有一种，就是1
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = bagSize; j >= nums[i]; j--)
            {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(m*n)$
- 空间复杂度：$O(m)$



## 9.12 一和零

### 解题思路1：01背包

**思路解析:**

**dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]**。

**题解：**

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(string str: strs)
        {
            int oneNum = 0;
            int zeroNum = 0;
            for(char ch: str)
            {
                if(ch == '0') zeroNum++;
                if(ch == '1') oneNum++;
            }
            for(int i = m; i >= zeroNum; i--)
            {
                for(int j = n; j >= oneNum; j--)
                {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.13 完全背包

### 解题思路1：二维数组

**思路解析:**



**题解：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, baggage;
    //n代表了物品的种类，baggage代表了行李箱的最大空间
    cin >> n >> baggage;
    //weight为物体的重量，cost为物体的价值
    vector<int> weight(n);
    vector<int> value(n);
    for(int i = 0; i < n; i++)
    {
        cin >> weight[i];
        cin >> value[i];
    }
    vector<vector<int>> dp(n, vector<int>(baggage + 1, 0));
    for(int j = weight[0]; j <= baggage; j++)	//初始化这里和01背包有些不同
    {
        dp[0][j] = dp[0][j - weight[0]] + value[0];
    }
    for(int i = 1; i < n; i++)
    {
        for(int j = 0; j <= baggage; j++)
        {
            if(j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);	//递归这里和01背包有些不同，01是上一行，完全是本行
        }
    }
    cout << dp[n - 1][baggage] << endl;
    return 0;
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：一维数组

**思路解析:**



**题解：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, baggage;
    //n代表了物品的种类，baggage代表了行李箱的最大空间
    cin >> n >> baggage;
    //weight为物体的重量，cost为物体的价值
    vector<int> weight(n);
    vector<int> value(n);
    for(int i = 0; i < n; i++)
    {
        cin >> weight[i];
        cin >> value[i];
    }
    vector<int> dp(baggage + 1, 0);
    for(int i = 0; i < n; i++)
    {
        for(int j = weight[i]; j <= baggage; j++)	//01是从后向前，完全是从前向后
        {
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[baggage] << endl;
    return 0;
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.14 零钱兑换II

### 解题思路1：二维完全背包

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp(coins.size(), vector<int>(amount + 1, 0));
        for(int j = 0; j <= amount; j++)
        {
            if(j % coins[0] == 0) dp[0][j] = 1; 
        }
        for(int i = 1; i < coins.size(); i++)
        {
            for(int j = 0; j <= amount; j++)
            {
                if(j < coins[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];
            }
        }
        return dp[coins.size() - 1][amount];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路1：一维完全背包

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<uint64_t> dp(amount + 1, 0);
        dp[0] = 1;
        for(int i = 0; i < coins.size(); i++)
        {
            for(int j = coins[i]; j <= amount; j++)
            {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.15 组合总和IV

### 解题思路1：完全背包

**思路解析:**

这次的背包和物品顺序要调换过来了，这样才能得到排列的数量

**题解：**

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) // 遍历背包
        { 
            for (int j = 0; j < nums.size(); j++) // 遍历物品
            { 
                if (i - nums[j] >= 0 && dp[i] <= INT_MAX - dp[i - nums[j]]) 
                {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.16 爬楼梯

### 解题思路1：

**思路解析:**



**题解：**

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n, m;
    cin >> n >> m;
    vector<int> dp(n + 1, 0);
    dp[0] = 1;
    for(int i = 1; i <= n; i++) //遍历背包
    {
        for(int j = 1; j <= m; j++) //遍历物品
        {
            if(i - j >= 0) dp[i] += dp[i - j];
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.17 零钱兑换

### 解题思路1：先物品再背包

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：先背包再物品

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++)
        {   
            for(int j = 0; j < coins.size(); j++)
            {
                if(i >= coins[j] && dp[i - coins[j]] != INT_MAX)
                {
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

## 9.18 完全平方数

### 解题思路1：先物品再背包

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i * i <= n; i++)
        {
            for(int j = i * i; j <= n; j++)
            {
                dp[j] = min(dp[j - i * i] + 1, dp[j]);
            }
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

### 解题思路2：先背包再物品

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for(int i = 0; i <= n; i++)
        {
            for(int j = 1; j * j <= i; j++)
            {
                dp[i] = min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

## 9.19 单词拆分

### 解题思路1：动态规划

**思路解析:**



**题解：**

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for(int i = 1; i <= s.size(); i++)
        {
            for(int j = 0; j < i; j++)
            {
                string word = s.substr(j, i - j);
                if(wordSet.find(word) != wordSet.end() && dp[j])
                {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



## 9.20 打家劫舍

### 解题思路1：动态规划

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return nums[0];
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++)
        {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$





## 9.21 打家劫舍II

### 解题思路1：动态规划

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int robRange(const vector<int>& nums, int start, int end)
    {
        if(start == end) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for(int i = start + 2; i <= end; i++)
        {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }

    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2);
        int result2 = robRange(nums, 1, nums.size() - 1);
        return max(result1, result2);
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

## 9 打家劫舍III

### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(log_n)$





## 9 买卖股票的最佳时机

### 解题思路1：贪心算法

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int res = 0;
        for(int i = 0; i < prices.size(); i++)
        {
            low = min(low, prices[i]);
            res = max(res, prices[i] - low);
        }
        return res;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路2：动态规划

**思路解析:**

dp[i] [0] 表示第i天持有股票所得最多现金

dp[i] [1] 表示第i天不持有股票所得最多现金

**题解：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if(len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < len; i++)
        {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

**复杂度分析**

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$



## 9 买卖股票的最佳时机II



### 解题思路1：贪心算法

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1; i < prices.size(); i++)
        {
            if(prices[i] - prices[i - 1] > 0)
            {
                result += prices[i] - prices[i - 1];
            }
        }
        return result;
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路1：动态规划

**思路解析:**



**题解：**

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < len; i++)
        {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$



### 解题思路1：

**思路解析:**



**题解：**

```c++

```

**复杂度分析**

- 时间复杂度：$O()$
- 空间复杂度：$O()$

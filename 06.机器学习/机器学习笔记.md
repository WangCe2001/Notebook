# Numpy包

常用调用语句：

```python
import numpy as np
```

## array()——生成数组或矩阵

**1.用途：**创建数组或矩阵

**2.语法：**

```python
numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)
```

- object：必需，用于创建数组的任何对象，如列表、元组、集合、数组等。

- dtype：可选，数组所需的数据类型。如果未给出，则从输入数据中推断数据类型。
- copy：可选，默认为True。如果为True，则复制输入数据；如果为False，则使用输入数据的引用（如果可能）。
- order：可选，指定输入数组中元素的内存布局。'K’表示保持输入数组的内存布局，'C’表示以C语言风格（行优先）排列元素，'F’表示以Fortran风格（列优先）排列元素，‘A’表示以原始数据的布局排列元素（默认为’K’）。
- subok：可选，如果为True，则子类将被传递，否则返回的数组将是完全由NumPy创建的数组（默认为False）。
- ndmin：可选，指定输出数组的最小维度。如果输入数据是低维的，则会被提升到至少ndmin维（默认为0）。

**3.示例：**

```python
import numpy as np
# 示例1：从列表创建一维NumPy数组
list1 = [1, 2, 3, 4, 5]
array1 = np.array(list1)
print(array1)
# 输出：[1 2 3 4 5]

# 示例2：从列表创建二维NumPy数组（列表的列表）
list2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
array2 = np.array(list2)
print(array2)
/*
输出：
[
    [1 2 3]
    [4 5 6]
    [7 8 9]
]
*/

# 示例3：创建整数类型的NumPy数组
array3 = np.array([1.0, 2.0, 3.0], dtype=int)
print(array3)

# 示例4：创建浮点数类型的NumPy数组
array4 = np.array([1, 2, 3], dtype=float)
print(array4)

```

**4.参考链接：**

[【NumPy数组】：深入解析numpy.array()函数-CSDN博客](https://blog.csdn.net/qq_38614074/article/details/138565095?ops_request_misc=%7B%22request%5Fid%22%3A%22CE7F46D3-E1DD-471D-B0D1-A5524405279E%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=CE7F46D3-E1DD-471D-B0D1-A5524405279E&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-138565095-null-null.142^v100^pc_search_result_base6&utm_term=numpy中array&spm=1018.2226.3001.4187)

[NumPy数据分析基础之array函数-CSDN博客](https://blog.csdn.net/weixin_51065082/article/details/123069504?ops_request_misc=%7B%22request%5Fid%22%3A%22CE7F46D3-E1DD-471D-B0D1-A5524405279E%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=CE7F46D3-E1DD-471D-B0D1-A5524405279E&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123069504-null-null.142^v100^pc_search_result_base6&utm_term=numpy中array&spm=1018.2226.3001.4187)

## power()——幂运算

**1.用途：**完成幂函数的运算

**2.语法：**

```python
numpy.power(x1,x2,out=None) 
```

- `x1`：底数数组，即要进行幂运算的数组。
- `x2`：指数数组，用于指定幂运算的指数。
- `out`：一个可选参数，用于指定存储结果的数组。如果提供此参数，结果将直接存储在这个数组中，而不是返回一个新数组。

**3.示例：**

```python
import numpy as np

# 示例1：单个数的幂运算
result = np.power(2, 3)
print(result)  # 输出: 8

# 示例2：数组的幂运算
base = np.array([2, 3, 4])
exponent = np.array([2, 3, 4])
result = np.power(base, exponent)
print(result)  # 输出: [ 4 27 256]

# 示例3：广播机制：不同形状数组的幂运算
base_matrix = np.array([[2, 3], [4, 5]])
exponent_vector = np.array([2, 3])
result_matrix = np.power(base_matrix, exponent_vector)
print(result_matrix)
# 输出:
# [[ 4  27]
#  [16 125]]
```

**4.参考链接：**

[【NumPy】深入解析numpy.power()函数_np.power()函数-CSDN博客](https://blog.csdn.net/2402_83361138/article/details/137904079?ops_request_misc=%7B%22request%5Fid%22%3A%222C4048C0-80C3-49BB-8C6B-AB5673438DBC%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=2C4048C0-80C3-49BB-8C6B-AB5673438DBC&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-137904079-null-null.142^v100^pc_search_result_base6&utm_term=numpy中power&spm=1018.2226.3001.4187)

[[Python\] numpy 之 power函数介绍和使用案例_python np.power-CSDN博客](https://blog.csdn.net/u011775793/article/details/135428041?ops_request_misc=%7B%22request%5Fid%22%3A%222C4048C0-80C3-49BB-8C6B-AB5673438DBC%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=2C4048C0-80C3-49BB-8C6B-AB5673438DBC&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-135428041-null-null.142^v100^pc_search_result_base6&utm_term=numpy中power&spm=1018.2226.3001.4187)

## sum()——求和

**1.用途：**求数组或矩阵的和

**2.语法：**

```python
numpy.sum(array, axis=None, dtype=None, out=None, keepdims=False, initial=<no value>, where=<no value>)
```

- array: 必需，输入的数组。

- axis（可选）: 指定沿着哪个轴进行求和。默认为None，表示计算所有元素的总和。可以是整数（例如0表示第一维度）、负数（-1表示最后一维度）或元组（例如(0, 1)表示在前两个维度上求和）。
- dtype（可选）: 输出数组的数据类型。
- out（可选）: 结果存入的数组，用于就地修改。
- keepdims（可选）: 如果为True，则在求和后的结果中保留输入数组的维度，大小为1。
- initial（可选）: 当数组为空时的初始值。
- where（可选）: 可选的布尔数组，指定哪些元素参与计算。只有where为True的元素才会被纳入求和。

返回值：计算结果的和

**3.示例：**

```python
import numpy as np

# 示例1：生成数组arr，并求他的所有数据之和
arr = np.array([1, 2, 3, 4, 5])
total_sum = np.sum(arr)
print("Total sum of elements:", total_sum)
# 输出：Total sum of elements:15

# 示例2：计算每行之和
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
row_sums = np.sum(matrix, axis=1)
print("Sum along rows:", row_sums)
# 输出：Sum along rows：[6 15 24]

# 示例3：计算每列之和
col_sums = np.sum(matrix, axis=0)
print("Sum along columns:", col_sums)
# 输出：Sum along colums:[12 15 18]
```

**4.参考链接：**

[【NumPy】全面解析sum函数：高效数组求和操作指南_numpy sum-CSDN博客](https://blog.csdn.net/g310773517/article/details/139217426?ops_request_misc=%7B%22request%5Fid%22%3A%221840198B-BDA3-445B-BBE7-EAAA45EEDA10%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=1840198B-BDA3-445B-BBE7-EAAA45EEDA10&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139217426-null-null.142^v100^pc_search_result_base6&utm_term=numpy中sum&spm=1018.2226.3001.4187)



## matrix——矩阵

**1.用途：**以矩阵的格式生成数据，每一行的数据是元组类型

**2.语法：**

```python
import numpy as np
# 1.创建矩阵
x = np.matrix([[1,2,3], [4,5,6]])
y = np.matrix([1,2,3,4,5,6])

# 2.矩阵转置
x.T
```

![img](https://img-blog.csdnimg.cn/direct/db2e531aba964fd9b2408d971f8a5ee7.png)

**3.案例：**

```python
import numpy as np
x = np.matrix([[1,2,3], [4,5,6]])
y = np.matrix([1,2,3,4,5,6])
print(x)
print(y)
```

![fe2ac715ecb9c9a43be9d03b07384c9d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/fe2ac715ecb9c9a43be9d03b07384c9d.png)

**4.参考链接：**

[【Python】numpy——矩阵matrix_np.matrix-CSDN博客](https://blog.csdn.net/fftx_00/article/details/122267391?ops_request_misc=%7B%22request%5Fid%22%3A%221AA57926-EC82-484E-802E-912D555A7A79%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=1AA57926-EC82-484E-802E-912D555A7A79&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-122267391-null-null.142^v100^pc_search_result_base6&utm_term=numpy中的matrix函数&spm=1018.2226.3001.4187)

[掌握NumPy矩阵_在使用matrix 函数创建矩阵式,返回的是ndarray对象-CSDN博客](https://blog.csdn.net/ing11230/article/details/139635371?ops_request_misc=&request_id=&biz_id=102&utm_term=numpy中的matrix函数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-139635371.142^v100^pc_search_result_base6&spm=1018.2226.3001.4187)



## eye()——生成对角线元素为1的矩阵

**1.用途：**快速生成单位矩阵

**2.语法：**

```python
numpy.eye(N, M=None, k=0, dtype=<class 'float'>)
```

- `N`：输出的行数。
- `M`：输出的列数。如果为None，则默认为N；如果M和N都不为None，则输出形状为(N,M)。
- `k`：对角线的索引。0表示主对角线，正数表示主对角线上方的对角线，负数表示主对角线下方的对角线。
- `dtype`：输出的数据类型。

**3.示例：**

```python
import numpy as np

# 生成一个3x3的单位矩阵
I_3 = np.eye(3)
print(I_3)
# 输出:
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]

# 生成一个5x3的单位矩阵，只保留主对角线及其上方的元素
I_5x3 = np.eye(5, 3, k=0)
print(I_5x3)
# 输出:
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]
#  [0. 0. 0.]
#  [0. 0. 0.]]

# 生成一个4x4的单位矩阵，在主对角线上方生成单位1的占位
I_4_lower = np.eye(4, k=1)
print(I_4_lower)
# 输出:
# [[0. 1. 0. 0.]
#  [0. 0. 1. 0.]
#  [0. 0. 0. 1.]
#  [0. 0. 0. 0.]]

# 指定数据类型为整数
I_int = np.eye(2, dtype=int)
print(I_int)
# 输出:
# [[1 0]
#  [0 1]]

```

**4.参考链接：**

[【NumPy】深入解析numpy.eye()函数_numpy.eye函数-CSDN博客](https://blog.csdn.net/2402_83361138/article/details/137894830?ops_request_misc=&request_id=&biz_id=102&utm_term=numpy中的eye函数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-137894830.142^v100^pc_search_result_base6&spm=1018.2226.3001.4187)

## shape()——查看数值的维度

**1.用途：**

用来读取矩阵的维度，以元组的形式返回数据

**2.语法：**

```python
np.shape(数据)
数据.shape
```

如果括号内为==0==，则获得第一维度，对于二维数组来说就是==行数==；

括号内为==1==，则获得第二维度，对于二维数组来说就是==列数==。

**3.案例：**

```python
import numpy as np
a = np.eye(4,3)
print(a)
输出结果：[[ 1.,  0.,  0.],
          [ 0.,  1.,  0.],
          [ 0.,  0.,  1.],
          [ 0.,  0.,  0.]]

print(a.shape)
输出结果：(4, 3)

print(np.shape(a))
输出结果：(4, 3)

print(a.shape[0])
输出结果：4

print(a.shape[1])
输出结果：3

```

**4.参考链接：**

[Python numpy函数：shape用法_numpy shape[0\]-CSDN博客](https://blog.csdn.net/qq_27636147/article/details/88553426?ops_request_misc=%7B%22request%5Fid%22%3A%2205B73C7C-4F2D-49FB-B0A7-0FA77ACB8714%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=05B73C7C-4F2D-49FB-B0A7-0FA77ACB8714&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-88553426-null-null.142^v100^pc_search_result_base6&utm_term=numpy库中的shape函数&spm=1018.2226.3001.4187)

[numpy.shape()函数_np.shape-CSDN博客](https://blog.csdn.net/tumantou2hao/article/details/88293029?ops_request_misc=%7B%22request%5Fid%22%3A%2205B73C7C-4F2D-49FB-B0A7-0FA77ACB8714%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=05B73C7C-4F2D-49FB-B0A7-0FA77ACB8714&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-88293029-null-null.142^v100^pc_search_result_base6&utm_term=numpy库中的shape函数&spm=1018.2226.3001.4187)



## zeros()——创建数据全为零的矩阵

**1.用途：**用来生成数据元素全为0的矩阵

**2.语法：**

```python
numpy.zeros(shape, dtype=float, order='C')
```

- shape：一个整数或者整数元组，指定了输出数组的形状。例如，shape=(3,)将创建一个长度为3的一维数组，shape=(2, 3)将创建一个2行3列的二维数组。

- dtype：可选参数，用于指定数组中元素的数据类型。默认是float64，但可以根据需要设置为其他类型，如int、float32等。
- order：可选参数，指定数组在内存中的存储顺序，通常是’C’（按行存储）或’F’（按列存储）。在大多数情况下，我们不需要改变这个参数。

**3.示例：**

```python
import numpy as np

# 创建一维全零数组
zeros_array_1d = np.zeros(5)
print(zeros_array_1d)
# 输出: [0. 0. 0. 0. 0.]

# 创建二维全零数组（矩阵）
zeros_array_2d = np.zeros((3, 4))
print(zeros_array_2d)
# 输出:
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

```

**4.参考链接：**

[【NumPy】深入解析numpy.zeros()函数-CSDN博客](https://blog.csdn.net/2402_83361138/article/details/137894511?ops_request_misc=%7B%22request%5Fid%22%3A%228F540EBB-6913-4670-9E97-FC3DB51F9097%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=8F540EBB-6913-4670-9E97-FC3DB51F9097&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-137894511-null-null.142^v100^pc_search_result_base6&utm_term=numpy库中的zeros函数&spm=1018.2226.3001.4187)

## ravel()——将多维数据降维成一维数组

**1.用途：**将多维数组以==展平视图==的形式降维成一维数组，无论原始数组的形状如何，np.ravel()都能将其转换为一维数组，同时保持元素顺序不变

由于返回的是展平视图，而不是副本，这意味着对np.ravel()返回的一维数组所做的任何修改都会==直接反映到原始数组上==

**2.语法：**

```python
np.ravel(数据)
```

**3.示例：**

```python
import numpy as np

# 创建一个二维数组
arr_2d = np.array([[1, 2, 3], [4, 5, 6]])

# 使用np.ravel()展平数组
arr_1d = np.ravel(arr_2d)

print("原始二维数组:")
print(arr_2d)
print(f"使用函数输出:\n{arr_2d.ravel()}")
print("\n展平后的一维数组:")
print(arr_1d)


# 输出结果：

# 原始二维数组:
# [[1 2 3]
#  [4 5 6]]

# 使用函数输出：
# [1 2 3 4 5 6]

# 展平后的一维数组:
# [1 2 3 4 5 6]

```

**4.参考链接：**

[【Numpy】一文向您详细介绍 np.ravel()-CSDN博客](https://blog.csdn.net/qq_41813454/article/details/137842159?ops_request_misc=%7B%22request%5Fid%22%3A%22D9A17A9B-10B1-4FED-A79F-DCCA8CD37548%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=D9A17A9B-10B1-4FED-A79F-DCCA8CD37548&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-137842159-null-null.142^v100^pc_search_result_base6&utm_term=numpy库中的ravel函数&spm=1018.2226.3001.4187)



## multiply()——数组元素乘法运算

**1.用途：**用于数组元素乘法运算

**2.语法：**

```python
numpy.multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
```

- `x1`和`x2`：要进行乘法运算的两个输入数组。
- `out`：用于存放输出结果的数组，这是一个可选参数。
- `where`：定义哪些元素需要参与运算的条件数组，同样是可选参数。
- `casting`、`order`、`dtype`、`subok`等：其他可选参数，用于控制运算过程中的类型转换、顺序、数据类型等。

与add方法类似，multiply方法也支持广播机制，允许对形状不匹配的数组进行乘法运算

**3.示例：**

```python
import numpy as np

# 创建两个一维数组
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 使用multiply方法进行乘法运算
c = np.multiply(a, b)
print(c)  # 输出：[ 4 10 18]

————————————————————————————————
# 创建一个二维数组和一个一维数组
A = np.array([[1, 2], [3, 4]])
b = np.array([5, 6])

# 使用multiply方法进行乘法运算
C = np.multiply(A, b)
print(C)
# 输出：
# [[ 5 12]
#  [15 24]]

```

**4.参考链接：**

[【NumPy】深入解析numpy中的multiply方法_numpy multiply-CSDN博客](https://blog.csdn.net/2402_83361138/article/details/138128173?ops_request_misc=&request_id=&biz_id=102&utm_term=numpy库中的multiply函数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-138128173.142^v100^pc_search_result_base6&spm=1018.2226.3001.4187)



## linespace()——生成线性等间距序列

**1.用途：**在线性区域中生成等间距的序列

**2.语法：**

```python
numpy.linspace(start, end, num=num_points,endpoint=False,retstep=True,axis=0,dtype=int)
```

- 对应的序列在【start,end】，共有num_points个元素

- endpoint默认为True。如果设置为False，对应的序列在【start,end），通俗的说不包括最后一个元素，同样共有num_points个元素
- retstep默认为False。如果设置为True，则返回的序列结果为一个元组，对应的序列在【start,end】
- axis设置轴来存储，只可数组类型才可编译。默认为0，在开始处插入新轴。为-1，为序列末尾轴。
- dtype默认类型为int，很多时候输出为float类型



**3.示例：**

```python
import numpy as np
import matplotlib.pyplot as plt
x1 = np.linspace(-5, 5, 5)
# 让y直接为0
y = np.zeros(5)
# 画图，具体用*号表示
plt.plot(x1, y, '*')
# 设置当前轴的y限制
plt.ylim([-0.5, 0.5])
plt.show()
# 输出 [-5.  -2.5  0.   2.5  5. ]
print(x1)
# 输出的长度为 5 
print(len(x1))
```



![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b3db4b0beb2434771610b6058ae89e72.png)

**4.参考链接：**

[Python Numpy 关于 linspace()函数 使用详解（全）-CSDN博客](https://blog.csdn.net/weixin_47872288/article/details/128730985?ops_request_misc=%7B%22request%5Fid%22%3A%2255BE6931-CADA-4288-9BB7-F29524454000%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=55BE6931-CADA-4288-9BB7-F29524454000&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-128730985-null-null.142^v100^pc_search_result_base6&utm_term=numpy库中的linspace函数&spm=1018.2226.3001.4187)

[python numpy 中linspace函数_np.linspace-CSDN博客](https://blog.csdn.net/neweastsun/article/details/99676029?ops_request_misc=&request_id=&biz_id=102&utm_term=numpy库中的linspace函数&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-99676029.142^v100^pc_search_result_base6&spm=1018.2226.3001.4187)

# Pandas包

常用调用语句：

```python
import pandas as pd
```

## read_csv()——读取数据

**1.用途：**读取CSV格式的数据。CSV文件是一种简单的文件格式，用于存储表格数据，其中每个字段通常==由逗号分隔==

**2.语法：**

```python
pd.read_csv(参数)
```

常用参数：

- path：文件路径或文件对象。
- sep：字段分隔符，默认为逗号,。
- header：指定表头行，默认为0。
- name：类似于数组结构，选择性使用。这是要使用的列名称列表，与header共同使用
- index_col：用作行索引的列名。
- usecols：需要读取的列名列表或索引。
- dtype：列的数据类型。

**3.示例：**

```python
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data1.txt'
data = pd.read_csv(path,header=None,names=['Population','Profit'])
print(data.head())
```

得到一个如下所示的列表：

![e49d091da7134f2264124d52ed61ab63](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/e49d091da7134f2264124d52ed61ab63.png)

即path路径下的文件所有信息

**4.参考链接：**

[详解python中的pandas.read_csv()函数_pythonpandas读取csv文件-CSDN博客](https://blog.csdn.net/weixin_51484460/article/details/139579106?ops_request_misc=%7B%22request%5Fid%22%3A%22452A3FA1-E9D5-464D-81CB-0A083E3475AF%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=452A3FA1-E9D5-464D-81CB-0A083E3475AF&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-139579106-null-null.142^v100^pc_search_result_base6&utm_term=pandas中的read_csv函数&spm=1018.2226.3001.4187)

## plot()——画图

**1.用途**：绘制折线图、散点图等

**2.语法：**

```python
data.plot(参数)
```

常用参数：

- kind='str'：决定图的性质，比如line代表连续图(默认值)，scatter代表散点图
- x：x轴的数据来源，默认为空
- y：y轴的数据来源
- figsize=(宽度，高度)：生成图的尺寸

**3.示例：**

```python
# 6.将已有数据绘制离散图,kind决定是离散图，x轴是population的数据，y轴是profit的数据，figsize决定生成的图标尺寸
data.plot(kind='scatter', x='Population', y='Profit', figsize=(12,8))
# 7.显示图像
plt.show()
```

**4.参考链接：**

[pandas绘图plot函数_pandas plot-CSDN博客](https://blog.csdn.net/weixin_42322206/article/details/124228797?ops_request_misc=%7B%22request%5Fid%22%3A%22D76BC988-9804-4070-AD75-CF2A2CB1FB12%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=D76BC988-9804-4070-AD75-CF2A2CB1FB12&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-124228797-null-null.142^v100^pc_search_result_base6&utm_term=python中pandas的plot函数&spm=1018.2226.3001.4187)

## insert()——插入数据

**1.用途：**添加一列数据

**2.语法：**

```python
data.insert(loc, column, value,allow_duplicates = False)
```

参数：

- loc：必要字段，int类型数据，表示插入新列的列位置，原来在该位置的列将向右移。


- column：必要字段，插入新列的列名。


- value：必要字段，新列插入的值。如果仅提供一个值，将为所有行设置相同的值。可以是int，string，float等，甚至可以是series /值列表。

- allow_duplicates：布尔值，用于检查是否存在具有相同名称的列。默认为False，不允许与已有的列名重复。



**3.示例：**

```python
# 6.在训练集中插入一列，以便我们可以使用向量化的解决方案来计算代价和梯度
data.insert(0,'Ones',1)
print(data)
```



![cca009e8ff92924674ca93c359303520](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/cca009e8ff92924674ca93c359303520.png)



**4.参考链接：**

[pandas添加新列的5种常见方法_pandas insert-CSDN博客](https://blog.csdn.net/lzjhyhf/article/details/129205949?ops_request_misc=%7B%22request%5Fid%22%3A%2286340DCB-E59A-45A1-A9DA-7EA195EDD27E%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=86340DCB-E59A-45A1-A9DA-7EA195EDD27E&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129205949-null-null.142^v100^pc_search_result_base6&utm_term=pandas中insert函数&spm=1018.2226.3001.4187)

## shape()——返回行数或列数

**1.用途：**通过shape函数可以以==元组==形式返回pandas结构矩阵的行数和列数

**2.语法：**

```python
data.shape		#返回行数和列数
data.shape[0]	#只返回行数
data.shape[1]	#只返回列数
```

**3.示例：**

```python
# 设置cols是变量的列数
cols = data.shape[1]
print(cols)
```

![979f52d9291f6ceb3a12cb8715a7821f](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/979f52d9291f6ceb3a12cb8715a7821f.png)

**4.参考链接：**

[Python：Pandas中的.head函数和.shape函数的详细解释_pandas shape()函数-CSDN博客](https://blog.csdn.net/pantingd/article/details/105946565?ops_request_misc=%7B%22request%5Fid%22%3A%22321BF346-1BB7-47F2-B37E-B896AE76E042%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&request_id=321BF346-1BB7-47F2-B37E-B896AE76E042&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105946565-null-null.142^v100^pc_search_result_base6&utm_term=pandas中shape函数&spm=1018.2226.3001.4187)



## iloc()——数据切割

**1。用途：**

对已有的数据进行分块切割，==第一行默认为0==。

**2.语法：**

```python
data.iloc[row_indexer, column_indexer]
```

- `row_indexer`: 行的整数位置或切片。
- `column_indexer`: 列的整数位置或切片。
- 以==左闭右开==的方式进行的切片
- 如果想得到两边的数据都能切割到，需要使用.loc()函数

**3.示例1：**

```python
import pandas as pd

# 创建一个示例 DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David'],
        'Age': [25, 30, 35, 40],
        'City': ['New York', 'San Francisco', 'Los Angeles', 'Chicago']}

df = pd.DataFrame(data)

print("数据df样式为：")
print(df)
# 使用 iloc 获取特定行和列的数据
# 获取第二行（索引为1）的所有列数据
row_1 = df.iloc[1, :]

# 获取第一列（索引为0）的所有行数据
column_0 = df.iloc[:, 0]

# 获取第二行到第四行（索引为1到3）的第一列和第二列的数据
subset = df.iloc[1:4, 0:2]

print("\nRow 1:")
print(row_1)
print("\nColumn 0:")
print(column_0)
print("\nSubset:")
print(subset)
```

![6a93f2efecfc5df2d6f2be6ef4cfe4fe](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6a93f2efecfc5df2d6f2be6ef4cfe4fe.png)

**示例2：**

```python
"""
此时的数据一共有三列
第一列的数据以Ones作为列名
第二列的数据以Population作为列名
第三列的数据以Profit作为列名
下面两条语句令：
            x获得行数为所有行，列数为前两列的数据
            y获得行数为所有行，列数为最后一列的数据
"""
x = data.iloc[:,0:cols-1]
y = data.iloc[:,cols-1:cols]
# 测试一下x的数据和y的数据是否读取正确
print(x.head())
print(y.head())
```

![40ab5f09834e9f44986f75f157c3161c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/40ab5f09834e9f44986f75f157c3161c.png)

**4.参考链接：**

[pandas的iloc函数_pandas iloc-CSDN博客](https://blog.csdn.net/weixin_47552564/article/details/135567755?ops_request_misc=%7B%22request%5Fid%22%3A%221C83F9B7-E704-4195-8E1F-3F280FFB85C8%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=1C83F9B7-E704-4195-8E1F-3F280FFB85C8&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-135567755-null-null.142^v100^pc_search_result_base6&utm_term=pandas中iloc函数&spm=1018.2226.3001.4187)

[【python数据分析基础】—pandas中loc()与iloc()的介绍与区别_iloc函数-CSDN博客](https://blog.csdn.net/sodaloveer/article/details/133032337?ops_request_misc=%7B%22request%5Fid%22%3A%228EDD90F1-9285-453B-B5D6-7752DA8DC673%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=8EDD90F1-9285-453B-B5D6-7752DA8DC673&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-133032337-null-null.142^v100^pc_search_result_base6&utm_term=pandas中iloc函数&spm=1018.2226.3001.4187)

# Matplotlib数据可视化库

常用调用语句：

```python
import matplotlib.pyplot as plt
```

## show()——显示图形

**1.用途：**将后台数据以图像显示

**2.语法：**

```
plt.show()
```

**3.示例：**

```python
# 6.将已有数据绘制离散图,kind决定是离散图，x轴是population的数据，y轴是profit的数据，figsize决定生成的图标尺寸
data.plot(kind='scatter', x='Population', y='Profit', figsize=(4,2))
# 7.显示图像
plt.show()
```





## fig,ax = plt.subplots()——画多表图

**1.用途：**创建一个新的图形，并返回一个包含一个或多个子图的figure对象，和一个或多个axes对象

**2.语法：**

```python

```



**3.案例：**

```python

```





**4.参考链接：**



# week1

## 1.绘制离散图

通过导入数据，以离散图的形式将数据可视化

```python
# 1.导入第三方库
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# 2.用path记录需要的数据路径
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data1.txt'
# 3.将数据读入data，并将数据头标题设置为Population和Profit
data = pd.read_csv(path,header=None,names=['Population','Profit'])
# 4.使用列表的head函数，如果没有数值则默认为输出前5行
print(data.head())
# 5.输出数据的有关信息，比如总和，最大值，最小值，百分比等
print(data.describe())
# 6.将已有数据绘制离散图,kind决定是离散图，x轴是population的数据，y轴是profit的数据，figsize决定生成的图标尺寸
data.plot(kind='scatter', x='Population', y='Profit', figsize=(12,8))
# 7.显示图像
plt.show()
```

此时导入的数据大致如下图所示：包含了人口和利润

![65b0b1e4de10a5c942b1f706a7c9954e](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/65b0b1e4de10a5c942b1f706a7c9954e.png)

输出为：

![ebc0996e0d98daf6c05cc4269022ae73](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/ebc0996e0d98daf6c05cc4269022ae73.png)



## 2.代价函数



```python
# 1.导入第三方库
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 2.定义代价函数J，起名为computeCost
def computeCost(X,y,theta):
    """
    传入矩阵X，矩阵y，矩阵theta，使用代价函数公式计算数值，并返回其和的值
    为了使传入的矩阵X和theta进行计算，需要对矩阵theta在计算时进行转置
    :param X: 示例中传入的矩阵为97*2
    :param y: 示例中传入的矩阵为97*1
    :param theta: 实例中传入的矩阵为1*2
    :return: 返回的是代价函数计算的值
    """
    inner = np.power(((X*theta.T) - y),2)
    return np.sum(inner) / (2 * len(X))

# 3.用path记录需要的数据路径
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data1.txt'
# 4.将数据读入data，并将数据头标题设置为Population和Profit
data = pd.read_csv(path,header=None,names=['Population','Profit'])
# 5.在训练集中插入一列，以便我们可以使用向量化的解决方案来计算代价和梯度，此时在数据中的第一列插入了数值全为1的数据
# 插入的这一列元素是因为theat定义时是一个1*2的矩阵，即包含了theat0和theat1，如果不插入这一列，那么theat0将无法计算
# 不插入这一列的话，相当于只迭代了theat1，只得到了一个过原点的直线
data.insert(0,'Ones',1)
# 6.设置cols记录变量的列数，此时的列数cols的数值为3
cols = data.shape[1]
"""
7.此时的数据一共有三列
第一列的数据以Ones作为列名
第二列的数据以Population作为列名
第三列的数据以Profit作为列名
下面两条语句令：
            x获得行数为所有行，列数为前两列的数据
            y获得行数为所有行，列数为最后一列的数据
"""
X = data.iloc[:,0:cols-1]
y = data.iloc[:,cols-1:cols]

"""
8.代价函数使用的是numpy矩阵格式的数据，所以我们需要使用.vaules函数，使数据转换为numpy矩阵，然后才能使用它们。我们还需要初始化theta
此时矩阵X的维度是97*2
矩阵y的维度是97*1
矩阵theta的维度是1*2，且初始值都为0
"""
X = np.matrix(X.values)
y = np.matrix(y.values)
theta = np.matrix(np.array([0,0]))

# 9.调用代价函数
computeCost(X,y,theta)
```

语句5插入前的数据data为：

![57ff353b674d1c4de16a75c0880a32a9](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/57ff353b674d1c4de16a75c0880a32a9.png)

语句5插入后的数据data为：

![98cd9c70e06f126cfca174930fbbc3d5](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/98cd9c70e06f126cfca174930fbbc3d5.png)

语句8后得到的数据X：

![2c40c9f6ae425b56b32d2c4e7564d257](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2c40c9f6ae425b56b32d2c4e7564d257.png)

数据theta：

![306d8b5fe5ecbaa0550ec07078518517](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/306d8b5fe5ecbaa0550ec07078518517.png)



## 3.批量梯度下降

代码：

```python
def gradientDescent(X, y, theta, alpha, iters):
    temp = np.matrix(np.zeros(theta.shape))
    parameters = int(theta.ravel().shape[1])
    cost = np.zeros(iters)
    
    for i in range(iters):
        error = (X * theta.T) - y
        
        for j in range(parameters):
            term = np.multiply(error, X[:,j])
            temp[0,j] = theta[0,j] - ((alpha / len(X)) * np.sum(term))
            
        theta = temp
        cost[i] = computeCost(X, y, theta)
        
    return theta, cost
```

解释：

![38a6db1ec05385a4b7639edcf7634c17_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/38a6db1ec05385a4b7639edcf7634c17_720.jpg)





![370fd49488e9624c36bd67318321be86_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/370fd49488e9624c36bd67318321be86_720.jpg)



## 4.绘制拟合线性函数图，代价函数随迭代次数的变化图

代码：

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def computeCost(X, y, theta):
    """
        传入矩阵X，矩阵y，矩阵theta，使用代价函数公式计算数值，并返回其和的值
        为了使传入的矩阵X和theta进行计算，需要对矩阵theta在计算时进行转置
        :param X: 示例中传入的矩阵为97*2
        :param y: 示例中传入的矩阵为97*1
        :param theta: 实例中传入的矩阵为1*2
        :return: 返回的是代价函数计算的值
        """
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))
def gradientDescent(X, y, theta, alpha, iters):
    """
    通过不断迭代更新theta的值，使代价函数的值变为最低
    :param X: 原始数据
    :param y: 期望数据
    :param theta: 迭代数据
    :param alpha: 学习率
    :param iters: 迭代次数
    :return: 迭代后的theta值，与每次迭代过程中代价函数的具体值
    """
    # 生成一个暂时存储theta的矩阵temp
    temp = np.matrix(np.zeros(theta.shape))
    # 记录需要更新的theta值个数值
    parameters = int(theta.ravel().shape[1])
    # 记录每次迭代过程中生成的代价函数值
    cost = np.zeros(iters)
    # 外出for循环决定了迭代次数
    for i in range(iters):
        # error记录了本次迭代过程中梯度下降函数中需要的那个差值
        error = (X * theta.T) - y
        # 内层for循环决定了每次迭代过程中，对每一个theta都进行更新
        for j in range(parameters):
            # term代表了梯度下降函数中求导后与外层xi的相乘
            term = np.multiply(error, X[:, j])
            # 通过公式更新此时的theta(j)
            temp[0, j] = theta[0, j] - ((alpha / len(X)) * np.sum(term))
        # 将theta变为更新后的数值
        theta = temp
        # 记录本次迭代过程中生成的代价函数值
        cost[i] = computeCost(X, y, theta)
    return theta, cost

# 1.用path记录需要的数据路径
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data1.txt'
# 2.将数据读入data，并将数据头标题设置为Population和Profit
data = pd.read_csv(path,header=None,names=['Population','Profit'])

# 3.在训练集中插入一列，以便我们可以使用向量化的解决方案来计算代价和梯度，此时在数据中的第一列插入了数值全为1的数据
data.insert(0,'Ones',1)
# 4.设置cols记录变量的列数，此时的列数cols的数值为3
cols = data.shape[1]
"""
5.此时的数据一共有三列
第一列的数据以Ones作为列名
第二列的数据以Population作为列名
第三列的数据以Profit作为列名
下面两条语句令：
            x获得行数为所有行，列数为前两列的数据
            y获得行数为所有行，列数为最后一列的数据
"""
X = data.iloc[:,0:cols-1]
y = data.iloc[:,cols-1:cols]

"""
6.代价函数应该是numpy矩阵，所以我们需要转换X和Y，然后才能使用它们。我们还需要初始化theta
此时矩阵X的维度是97*2
矩阵y的维度是97*1
矩阵theta的维度是1*2，且初始值都为0
"""
X = np.matrix(X.values)
y = np.matrix(y.values)
theta = np.matrix(np.array([0,0]))

# 7.定义学习率为alpha=0.01，迭代次数iters=1000
alpha = 0.01
iters = 1000
# 8.用g接受迭代后的theta值，用cost接受迭代过程中所有代价函数产生的值
g, cost = gradientDescent(X, y, theta, alpha, iters)
# 9.x轴以population的最小值为起点，最大值为终点，100个元素
x = np.linspace(data.Population.min(), data.Population.max(), 100)
# 10.拟合函数f=theta(0)+theta(1)*x
f = g[0, 0] + (g[0, 1] * x)
# 11.绘制拟合曲线图
fig, ax = plt.subplots(figsize=(12,8))
ax.plot(x, f, 'r', label='Prediction')
ax.scatter(data.Population, data.Profit, label='Traning Data')
ax.legend(loc=2)
ax.set_xlabel('Population')
ax.set_ylabel('Profit')
ax.set_title('Predicted Profit vs. Population Size')
plt.show()
# 12.绘制x轴为迭代次数，y轴为代价函数图
fig, ax = plt.subplots(figsize=(12,8))
ax.plot(np.arange(iters), cost, 'r')
ax.set_xlabel('Iterations')
ax.set_ylabel('Cost')
ax.set_title('Error vs. Training Epoch')
plt.show()
```

输出的线性模型：

![7661509aa088cbc3b8db7212aedcda7c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/7661509aa088cbc3b8db7212aedcda7c.png)

输出的代价函数：

![21cf64b36d3b03f9efe69b8aebcd92f0](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/21cf64b36d3b03f9efe69b8aebcd92f0.png)



## 5.多变量线性回归

导入多变量情况：此时数据包括了两个变量（房子的大小，卧室的数量）和目标（房子的价格）

![dda3af78bfbe93637c1722620a73bbdc](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/dda3af78bfbe93637c1722620a73bbdc.png)

代码：

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def computeCost(X, y, theta):
    """
        传入矩阵X，矩阵y，矩阵theta，使用代价函数公式计算数值，并返回其和的值
        为了使传入的矩阵X和theta进行计算，需要对矩阵theta在计算时进行转置
        :param X: 示例中传入的矩阵为97*2
        :param y: 示例中传入的矩阵为97*1
        :param theta: 实例中传入的矩阵为1*2
        :return: 返回的是代价函数计算的值
        """
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))
def gradientDescent(X, y, theta, alpha, iters):
    """
    通过不断迭代更新theta的值，使代价函数的值变为最低
    :param X: 原始数据
    :param y: 期望数据
    :param theta: 迭代数据
    :param alpha: 学习率
    :param iters: 迭代次数
    :return: 迭代后的theta值，与每次迭代过程中代价函数的具体值
    """
    # 生成一个暂时存储theta的矩阵temp
    temp = np.matrix(np.zeros(theta.shape))
    # 记录需要更新的theta值个数值
    parameters = int(theta.ravel().shape[1])
    # 记录每次迭代过程中生成的代价函数值
    cost = np.zeros(iters)
    # 外出for循环决定了迭代次数
    for i in range(iters):
        # error记录了本次迭代过程中梯度下降函数中需要的那个差值
        error = (X * theta.T) - y
        # 内层for循环决定了每次迭代过程中，对每一个theta都进行更新
        for j in range(parameters):
            # term代表了梯度下降函数中求导后与外层xi的相乘
            term = np.multiply(error, X[:, j])
            # 通过公式更新此时的theta(j)
            temp[0, j] = theta[0, j] - ((alpha / len(X)) * np.sum(term))
        # 将theta变为更新后的数值
        theta = temp
        # 记录本次迭代过程中生成的代价函数值
        cost[i] = computeCost(X, y, theta)
    return theta, cost

# 1.用path记录需要的数据路径
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data2.txt'
# 2.将数据读入data，并将数据头标题设置为Population和Profit
data = pd.read_csv(path,header=None,names=['Size','Bedrooms','Price'])
print(type(data))
# 3.特征归一化，此处一定要进行数据的归一化处理，否则程序会溢出报错
data = (data - data.mean()) / data.std()
# 4.在训练集中插入一列，以便我们可以使用向量化的解决方案来计算代价和梯度，此时在数据中的第一列插入了数值全为1的数据
data.insert(0,'Ones',1)
# 5.设置cols记录变量的列数，此时的列数cols的数值为4
cols = data.shape[1]
"""
6.此时的数据一共有三列
第一列的数据以Ones作为列名
第二列的数据以Population作为列名
第三列的数据以Profit作为列名
下面两条语句令：
            x获得行数为所有行，列数为前三列的数据
            y获得行数为所有行，列数为最后一列的数据
"""
X = data.iloc[:,0:cols-1]
y = data.iloc[:,cols-1:cols]

"""
7.代价函数应该是numpy矩阵，所以我们需要转换X和Y，然后才能使用它们。我们还需要初始化theta
此时矩阵X的维度是97*3
矩阵y的维度是97*1
矩阵theta的维度是1*3，且初始值都为0
"""
X = np.matrix(X.values)
y = np.matrix(y.values)
theta = np.matrix(np.array([0,0,0]))

# 8.定义学习率为alpha=0.01，迭代次数iters=1000
alpha = 0.01
iters = 1000
# 9.用g接受迭代后的theta值，用cost接受迭代过程中所有代价函数产生的值
g, cost = gradientDescent(X, y, theta, alpha, iters)
# 10.绘制x轴为迭代次数，y轴为代价函数图
fig, ax = plt.subplots(figsize=(12,8))
ax.plot(np.arange(iters), cost, 'r')
ax.set_xlabel('Iterations')
ax.set_ylabel('Cost')
ax.set_title('Error vs. Training Epoch')
plt.show()
```

输出结果：

![1a871c72defec8e97d362822a1be758d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/1a871c72defec8e97d362822a1be758d.png)





## 6.使用scikit-learn进行模型预测

代码：

```python
# 1.导入第三方库
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn import linear_model
# 1.用path记录需要的数据路径
path = 'D:/计算机自学/07.机器学习/黄海广CSDN资料/Coursera-ML-AndrewNg-Notes-master/code/ex1-linear regression/ex1data1.txt'
# 2.将数据读入data，并将数据头标题设置为Population和Profit
data = pd.read_csv(path,header=None,names=['Population','Profit'])
# 3.设置cols记录变量的列数，此时的列数cols的数值为2
cols = data.shape[1]
"""
4.下面两条语句令：
            x获得行数为所有行，第一列的数据
            y获得行数为所有行，第二列的数据
"""
X = data.iloc[:,0:cols-1]
y = data.iloc[:,cols-1:cols]
# 5.使用线性回归模型，将数据X与y传入
model = linear_model.LinearRegression()
model.fit(X,y)
# 6.列出横轴数据与曲线
x = np.array(X)
f = model.predict(X).flatten()
# 7.画图
fig, ax = plt.subplots(figsize=(12,8))
ax.plot(x, f, 'r', label='Prediction')
ax.scatter(data.Population, data.Profit, label='Traning Data')
ax.legend(loc=2)
ax.set_xlabel('Population')
ax.set_ylabel('Profit')
ax.set_title('Predicted Profit vs. Population Size')
plt.show()
```

输出：

![9538b5b7641442c1b3627b68408a5524](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/9538b5b7641442c1b3627b68408a5524.png)





# week2






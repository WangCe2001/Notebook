# 一. 数据

## 1.1 数据的基本概念和术语

**1.数据：**

数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合

**2.数据元素：**

是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录

**3.数据项**：

一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位

**4.数据对象**：

是性质相同的数据元素的集合，是数据的子集

**5.数据结构**：

相互之间存在一种或多种特定关系的数据元素的集合

## 1.2 逻辑结构

逻辑结构：是指数据对象中数据元素之间的相互关系

**1.集合结构**：

集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/K(R0(EW25WSRYWZ9GXM0K)Q.png)

**2.线性结构**：

线性结构中的数据之间是一对一的关系

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024152.png)

**3.树形结构**：

树形结构中的数据元素之间存在一种一对多的层次关系

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024153.png)

**4.图形结构**：

图形结构的数据元素是多对多的关系

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024154.png)

## 1.3 物理结构

物理结构：数据的逻辑结构在计算机中的存储形式

**1.顺序存储结构**：

把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024155.png)

**2.链式存储结构**：

把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024156.png)

## 1.4 抽象数据类型（Abstract Data Type）

数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称

抽象数据类型（ADT）：是指一个数学模型及定义在该模型上的一组操作

抽象数据类型的标准格式：

```c
ADT 抽象数据类型名
Data
    数据元素之间逻辑关系的定义
Operation
    操作1
    	初始条件
    	操作结果描述
    操作2
    	......
    操作n
    	......
endADT
```

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024157.png)

# 二. 算法

## 2.1 算法的特性

**1.输入输出**：

算法具有零个或多个输入，至少有一个或多个输出

**2.有穷性**：

算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成

**3.确定性**：

算法的每一步骤都具有确定的含义

**4.可行性**：

算法的每一步都必须是可行的，也就是说，每一步都能通过执行有限次数完成。

## 2.2 算法设计的要求

**1.正确性**：

算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案

**2.可读性**：

算法设计的另一目的是为了便于阅读、理解和交流

**3.健壮性**：

当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果

**4.时间效率高和存储量低**：

## 2.3 算法效率的度量方法

**1.事后统计方法**：

**2.事前分析估算方法**：

## 2.4 时间复杂度（T(n)=O(f(n))）

推到大O阶：

```
1.用常数1取代运行时间中的所有加法常数

2.在修改后的运行次数函数中，只保留最高阶项

3.如果最高阶项存在且不是1，则去除与这个项相乘的常数
```

最终得到的结果就是大0阶

常见时间复杂度：

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024158.png)

常用的时间复杂度所耗费的时间从小到大依次是：

![](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2024159.png)

一般没有特殊说明的情况下，都是指最坏时间复杂度

## 2.5 空间复杂度（S(n)=O(f(n))）

当不限定使用”复杂度“时，通常都是指时间复杂度。



# 三. 线性表

线性表：零个或多个元素的有限序列

## 3.1 线性表定义和特点

|            |                            顺序表                            |                             链表                             |
| :--------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  存储空间  |              预先分配，可能会导致空间闲置或溢出              |              动态分配，不会出现空间闲置或者溢出              |
|  存储密度  |       存储密度为1，逻辑关系等于存储关系，没有额外开销        |     存储密度小于1，要借助指针域来表示元素之间的逻辑关系      |
|  存取元素  |           随机存取，按位置访问元素的时间复杂度O(1)           |         顺序存取，访问某位置的元素的时间复杂度为O(n)         |
| 插入、删除 | 插入和删除都要移动大量的元素。平均移动元素约为表的一半。时间复杂度O(n) | 不需要移动元素，只需要改变指针位置，继而改变结点之间的链接关系。时间复杂度O(1) |
|  适用情况  | 1.表长变化不大，或者事先就能确定变化的范围<br />2.很少进行插入和删除，需要下标访问元素 |            1.长度变化较大<br />2.频繁的插入和删除            |
|            |                 *这不就是vector的使用特点吗*                 |                  *这不就是list的使用特点吗*                  |

1.线性表：具有相同特性的数据元素的一个有限序列

**零个或多个数据元素的有限序列，第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继**

2.线性表元素的个数n（n>=0)定义为线性表的长度，当n=0时，称为空表

如a1是第一个数据元素，an是最后一个数据元素，ai是第i个数据元素，称==i为数据元素ai在线性表中的位序==

注意：==逻辑位序==和==物理位序==相差1，逻辑位序比物理位序大1.

3.存储密度：

![7f8a037516bf2e54db9f92d90ac7ceac](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/7f8a037516bf2e54db9f92d90ac7ceac.png)

## 3.2 线性表的抽象数据类型

线性表的抽象数据类型定义如下：

```c
ADT 线性表(List)
Data
    线性表的数据对象集合为{a1,a2,...,an}，每个元素的类型均为DataType。其中
    除了第一个元素a1外，每一个元素有且只有一个直接前驱元素
    除了最后一个元素an外，每一个元素有且只有一个直接后继元素
    数据元素之间的关系是一对一的关系
Operation
    InitList(*L):初始化操作，建立一个空的线性表L
    DestroyList(&L);销毁线性表L
    ListEmpty(L):若线性表为空，返回true，否则返回false
    ClearList(*L):将线性表清空
    GetElem(L,i,*e):将线性表L中的第i个位置元素值返回给e
    LocateElem(L,e):在线性表中查找与给定值e相等的元素，如果查找成功，返回元素在表中序号；否则，返回0表示失败
    ListInsert(*L,i,e):在线性表L中的第i个位置插入新元素e
    LisiDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值
    LisiLength(L):返回线性表L的元素个数
endADT
```



若想要实现A=A+B的效果，可用如下代码实现：

```c
void unionL(SqList *La,SqList Lb)
{
    int La_Len,Lb_Len,i;
    ElemType e;
    La_Len=ListLength(*La);
    Lb_Len=ListLenght(Lb);
    for(i=1;i<=Lb_Len;i++)
    {
        GetElem(Lb,i,&e);
        if(!LocateElem(*La,e))
        ListInsert(La,++La_Len,e)
    }
}
```



如果需要被改动，则需要传递指向这个参数的指针

如果不用被改动，可以直接传递这个参数



## 3.3 线性表的顺序存储结构

1.顺序存储定义：

**线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素**

一维数组即是顺序存储结构的代表

2.在任意时刻，线性表的长度应该小于等于数组的长度，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度

假设每个数据元素占用的是c个存储单元，那么地址计算公式为：（LOC表示获得存储位置的函数）

```c
LOC(ai+1)=LOC(ai)+c
```

或

```c
LOC(ai)=LOC(a1)+(i-1)*c
```

通过以上公式可以随时算出线性表中任意位置的地址，不管是第一个还是最后一个都是相同的时间

故线性表的存取时间性能为==O(1)==。我们通常把具有这一特点的存储结构称为==随机存取结构==

3.线性表顺序存储的结构代码：

```c
#define MAXSIZE 100;
typedef struct
{
    ElemType *elem;	或为  ElemType data[MAXSIZE];
    int length;
}Sqlist;

//线性表的成员：
L.elem[0],L.elem[1]
```

## 3.4 顺序存储结构的相关操作

1.线性表的定义

~~~cpp
struct SqList
{
    ElemType *elem;//顺序线性表的表头
    int length;//顺序线性表的长度
};
~~~

2.线性表的初始化

~~~cpp
//1.引用一个顺序表
//2.将数据动态初始化为一个数组，长度为最大值；其中链表elem指针指向数组的首元素
//3.将线性表内数据元素个数初始化为0
//4.如果初始化成功，返回true；否则返回false
bool InitList(SqList &L)
{
    L.elem = new ElemType[MAXSIZE]; //在堆区开辟内存
    if(!L.elem)
    {
        cerr<<"error"<<endl;
        return false;
    }
    L.length = 0;//设定线性表长度为0
    return 1;
}
~~~

3.线性表的销毁

~~~cpp
//1.引用传入一个顺序表
//2.如果顺序表中的指针还有数值，则释放指针
void DestroyList(SqList &L)
{
    if(L.elem)
    {
        delete L.elem;
    }
}
~~~

4.线性表的清空

~~~cpp
void CLearList(SqList &L)
{
    //令线性表中的长度为0
    L.length = 0;
}
~~~

5.判断线性表是否为空

~~~cpp
bool IsEmpty(const SqList &L)
{
    //如果长度非0，则返回true；如果长度为0，则返回false
    return static_cast<bool>(L.length);
}
~~~

6.线性表的取值

~~~cpp
//1.传入一个引用的线性表，取值的位序，取值的返回
//2.如果位序小于1或者大于最大值则返回false
//3.如果位序正确，令e为实际位序i的值，并且函数返回true
bool GetELem(const SqList &L, const size_t i, ElemType &e)
{
    if(i<1 || i>MAXSIZE)
    {
        cerr<<"out of range"<<endl;
        return false;
    }
    e = L.elem[i-1];
    return true;
}
~~~

7.线性表的查找

~~~cpp
//1.传入一个线性表和要查找的值
//2.从第0号开始查询线性表中的元素，如果查找成功，返回这个值的逻辑位序
//3.如果没找到，则返回0
int LocateList(const SqList &L, const ElemType &e)
{
    for(int i = 0; i<L.length; ++i)
    {
        if(L.elem[i] == e)
        {
            return i+1; //查找成功，返回其查找元素的第一个下标值
        }
    }
    return 0; //未能找到对应元素，返回0
    //算法时间复杂度：O(n)
}
~~~

8.线性表的插入

~~~cpp
//1.传入要被插入的线性表，要插入的值，插入的逻辑位序
//2.如果此时的线性表长度已经到达最大值或者插入的位置i不符合规定，则返回false
//3.如果此时线性表内有数值，则要将i之后包括i的值都向后挪一位，将第i个位置空出来
//4.将e的值赋给第i位，并将表长加1，最后函数返回true
bool InsertList(SqList &L, const ElemType &e, const int &i)
{
    //判断线性表长度是否小于最大长度MAXSIZE
    if(L.length == MAXSIZE)
    {
        cerr<<"can not insert!"<<endl;
        return false;
    }
    if(i<0 || i>L.length)
    {
        cerr << "wrong insert position!" << endl;
        return false;
    }
    if(L.length > 0)
    {
        //将位于插入位置之后的元素依次向后挪动一位
        for (int p = L.length - 1; p >= i; --p)
        {
            L.elem[p + 1] = L.elem[p];
        }
    }
    //插入元素
    L.elem[i] = e;
    //线性表长度+1
    L.length += 1;
    return true;
    //算法时间复杂度：O(n)
}
~~~

9.线性表的删除

~~~cpp
//1.传入要操作的线性表L和要删除的元素位置i
//2.如果传入的位置i不符合规定或此时的线性表L的长度以为0，则返回false
//3.将要删除位置之后的元素依次向前挪动一位
//4.将表长-1并返回true
bool EraseList(SqList &L, const int &i)
{
    //异常判断
    if(i<0 || i>L.length)
    {
        cerr << "wrong erase position!" << endl;
        return false;
    }
    if(L.length == 0)
    {
        cerr << "List has no length" << endl;
        return false;
    }
    //将位于删除位置之后的元素依次向前挪动一位
    for (int p = i + 1; p < L.length; ++p)
    {
        L.elem[p - 1] = L.elem[p];
    }
    //线性表长度-1
    L.length -= 1;
    return true;
    //算法时间复杂度：O(n)
}
~~~

顺序线性表的插入、删除、查找时间复杂度都是O(n)，但是取值的时间复杂度是O(1).



## 3.5 线性表的链式存储结构

1.我们把存储数据元素信息的域称为**数据域**，存储直接后继位置的域称为**指针域**。

指针域中存储的信息称为**指针**或**链**，这两部分信息组成数据元素ai的存储映像，称为**结点(Node)**。

![7049d85777e0cc055fa129a40c495fbc](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/7049d85777e0cc055fa129a40c495fbc.png)

==结点由存放数据元素的**数据域**和存放后继元素结点地址的**指针域**组成==

2.n个结点链结成一个链表，即为线性表的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做**单链表**。

3.我们把链表中第一个结点的存储位置叫做**头指针**。

4.线性链表的最后一个结点指针为"**空**"，通过用**NULL**或"**^**"符号表示。

5.有时，会在单链表的第一个结点前附设一个结点，称为**头结点**。

6.单链表存储的结构代码：

```c++
typedef struct Lnode
{
    ElemType data;//结点的数据域
    struct Lnode *next;//结点的指针域
}Lnode,*LinkList;
```

## 3.6 链式存储结构的相关操作

1.链表的定义

~~~cpp
typedef struct Lnode
{
    ElemType data;//结点的数据域
    struct Lnode *next;//结点的指针域
}Lnode,*LinkList;
~~~

2.链表的初始化

~~~cpp
//1.传入一个链表指针引用，利用new为指针分配动态空间
//2.将指针L中的指针域指向空
bool InitList(LinkList &L)//插入题外话：LinkList &L等价于 Lnode *&L，Lnode *&L是一个指向指针的引用
{
    L = new Lnode; //堆区开辟一个头结点，结点的数据类型为Lnode
    L->next = nullptr;  //空表，也就是说头结点的指针指向为空
    return true;
}
~~~

3.头插法创建单向链表

~~~cpp
//1.传入被插入的链表L和插入的个数n
//2.使用new开辟一个新的指针p指向新的空链表
//3.对这个新的空链表输入数据
//4.令这个空链表指向原先头结点指向的下一个结点，并令头结点指向这个新的结点p
void CreatListHead(LinkList &L, const size_t n)
{
    for (int i = 0; i < n; ++i)
    {
        Lnode *p = new Lnode;
        cin >> p->data;
        p->next = L->next;
        L->next = p; 
    }
}
~~~

![aaa159ca84b50e70fffb6dcdcf7bb5dc](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/aaa159ca84b50e70fffb6dcdcf7bb5dc.png)

4.尾插法创建单向链表

~~~cpp
//1.传入被插入的链表L和插入的个数n
//2.新创造一个尾指针指向链表L的末尾
//3.利用关键字new新开辟一个指针p指向新结点
//4.向新节点中输入数据
//5.令新节点的指针域为空，令L尾指针的指针域指向，令尾指针r等于p
void CreatListTail(LinkList &L, const size_t n)
{
    Lnode *r = L;
    for (int i = 0; i < n; ++i)
    {
        Lnode *p = new Lnode;
        cin >> p->data;
        p->next = r->next;
        r->next = p;
        r = p;
    }
}
~~~

![5b45b74b265094ee9cb244ef44d6954f](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/5b45b74b265094ee9cb244ef44d6954f.png)

5.判断链表是否为空

~~~cpp
//1.传入链表L
//2.看链表L的头指针的next域指向是否为空，如果为空则说明是空链表返回true，否则则说明不是空链表，返回false
bool IsEmpty(const LinkList &L)
{
    if(L->next)//非空
    {
        return false;
    }
    else 
    {
        return true;
    }
}
~~~

6.销毁链表

~~~cpp
//1.传入要操作的链表L
//2.如果链表L为空链表，则无需销毁，并返回false
//3.如果链表不是空链表，则令指针temp指向头指针的下一个位置，然程序从头开始删除指针
//4.删除头指针L后，再令L等于temp指向的位置，达到反复删除的效果
//5.都删除成功后，函数返回true
bool DestroyList(LinkList &L)
{
    //判断链表是否为空
    if(IsEmpty(L))
    {
        cerr << "empty List!" << endl;
        return false;
    }
    while (L)//链表还未到达尾端
    {
        Lnode* temp = L->next;//将头指针指向下一个结点
        delete L;
        L = temp;
    }
    return true;
}
~~~

![cb7cb397c91a5a1296046b58cd09389c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/cb7cb397c91a5a1296046b58cd09389c.jpg)

7.统计链表长度

~~~cpp
//1.传入链表L
//2.创建指针p指向头结点后面的第一个结点
//3.当p的指针域不为空时，计数器加1
//4.返回计数值
size_t GetLength(const LinkList &L)
{
    Lnode *p;
    p = L->next;
    size_t cnt = 0;
    while (p)
    {
        ++cnt;
        p = p->next;
    }
    return cnt;
}
//算法的时间复杂度为O(n)
~~~

8.取链表中第i个元素的值

~~~cpp
//1.传入链表L，位置i，确认值e
//2.如果位置i不符合规定，返回false
//3.创建指针p指向头结点后面的那个结点
//4.一直让指针p向后移，直到移动到了预定位置，并让e等于这个位置的值，返回true
//5.如果i的值大于链表长度，返回false
bool GetElem(const LinkList &L, const int &i, ElemType &e)
{
    if(i < 0)
    {
        cerr << "out of range" << endl;
        return false;
    }
    Lnode *p = L->next;
    for (int j = 1; j < i + 1; ++j)
    {
        p = p->next;
        if(!p)
        {
            cerr << "out of range" << endl;
            return false;//如果此时p为空，意味着已经到达链表尾端，停止循环
        }
    }
    e = p->data;
    return true;
}
~~~

9.按值查找链表

~~~cpp
//1.传入链表L和查找的值e
//2.建立指针p指向头结点后面的第一个结点
//3.如果此时结点的值与对应值相同则返回计数值，否则计数值+1，p指向下一个结点
//4.如果p指向到最后一个结点还没有找到对应值，返回0
size_t LocateElem(LinkList &L, ElemType &e)
{
    Lnode *p = L->next;
    size_t cnt = 1;
    while (p)
    {
        if (p->data == e)
        {
            return cnt;
        }
        ++cnt;
        p = p->next;
    }
    cerr << "not found" << endl;
    return 0;
}
~~~

10.在链表中插入元素

~~~cpp
//1.传入链表L，位置i，数值e
//2.创建指针p指向头指针L
//3.如果插入的位置正确，令指针p指向位置i
//4.如果插入的位置错误，则返回false
//5.创建新指针insert，并为其添加数值e
//6.令insert指针域为p->next，并令p->next指向insert，返回true
bool InsertList(LinkList &L, const int &i, const ElemType &e)
{
    Lnode *p = L;
    int j = 0;
    while(p && j < i-1)
    {
        p = p->next;
        ++j;
    }
    //异常判断
    if(!p || i<0)
    {
        cerr << "out of range" << endl;
        return false;
    }
    LinkList insert = new Lnode;
    insert->data = e;
    insert->next = p->next;
    p->next = insert;
    return true;
}
//算法的时间复杂度为O(n)
~~~

11.删除链表的某个结点

~~~cpp
//1.传入链表L和位置i
//2.创建指针p指向头结点
//3.如果位置正确，令指针p指向位置i；如果位置错误，返回false
//4.创建指针q指向i+1的位置
//5.令指针q指向i+2的为位置
//6.删除指针q，并返回true
bool EraseList(LinkList &L, const int &i)
{
    Lnode *p = L;
    int j = 0;
    while (p->next && j < i - 1)
    {
        p = p->next;
        ++j;
    }
    if (!(p->next) || i < 0)
    {
        cerr << "out of range" << endl;
        return false;
    }
    Lnode *q = p->next;
    p->next = p->next->next;
    delete q;
    return true;
}
~~~

12.两个有序链表的合并

~~~cpp
//1.传入有序链表La，Lb，接受链表Lc
//2.创建指针pa指向La头结点后的第一个结点，pb指向Lb头结点后的第一个结点
//3.令Lc的头指针指向La的头指针
//4.创建指针pc指向Lc的头结点
//5.当pa和pb都并未指向末尾时进入循环，如果有一个以及指向了末尾则退出循环
//6.比较此时pa数据域和pb数据域的数据大小，谁的小就让pc指向谁，并令对应的pa/pb指针向后移位
//7.当有一方以及指到末尾后，判断哪个还有剩余，将pc指向剩余的第一个结点指针
//8.由于Lc本身指向的就是La，所以最后可以释放掉Lb
void MergeList(LinkList &La, LinkList &Lb, LinkList &Lc)
{
    Lnode *pa = La->next;
    Lnode *pb = Lb->next;
    Lc = La;
    Lnode *pc = Lc;
    while (pa && pb)
    {
        if (pa->data <= pb->data) //尾插法，插入元素
        {
            //pc的指针域指向小元素的地址
            pc->next = pa;
            //移动pc指针，使得pc永远都指向最后链表Lc的最后一个元素
            pc = pc->next;
            //pa的元素使用过后，要向后移动pa
            pa = pa->next;
        }
        else
        {
            //pc的指针域指向小元素的地址
            pc->next = pb;
            //移动pc指针，使得pc永远都指向最后链表Lc的最后一个元素
            pc = pc->next;
            //pb的元素使用过后，要向后移动pa
            pb = pb->next;
        }
    }
    //上面的while循环执行完毕后，较长的链表还会余留一段元素，这段元素的起始地址就是pa（或pb
    pc->next = (pa ? pa : pb);
    //链表合并完毕，释放Lb的头结点
    delete Lb;
}
~~~

> ​		这个算法的时间复杂度为O(n)，但是空间复杂度为O(1)
> ​		自我感觉，这个算法的思想十分巧妙。La和Lb是两条有序链表，众所周知链表的元素的逻辑关系是通过指针域实现的。这个算法巧妙的地方在于：不需要在堆区（heap）申请新的内存空间组成合并链表，而就根据原有元素的地址，重新构建一组逻辑关系。总而言之，就是通过改变现有结点指针的指向，构造出一条新的链表

***稀疏多项式的相加***

> 也即“合并两个有序链表”的变形

~~~cpp
//1.传入有序链表La，Lb，接受链表Lc
//2.创建指针pa指向La头结点后的第一个结点，pb指向Lb头结点后的第一个结点
//3.令Lc的头指针指向La的头指针
//4.创建指针pc指向Lc的头结点
//5.当pa和pb都并未指向末尾时进入循环，如果有一个以及指向了末尾则退出循环
//6.比较此时pa数据域和pb数据域的指数大小，谁的小就让pc指向谁，并令对应的pa/pb指针向后移位
//7.如果相对则令对应的系数相加，由于Lc就是在La上操作，所以将相加的值返回给La的系数，并令pc指向现在的pa位置，然后令pa和pb分别向后移动一位
//8.当有一方以及指到末尾后，判断哪个还有剩余，将pc指向剩余的第一个结点指针
//9.由于Lc本身指向的就是La，所以最后可以释放掉Lb
void SPO_II(LinkList &La, LinkList &Lb, LinkList &Lc)
{
    Lnode *pa = La->next;
    Lnode *pb = Lb->next;
    Lc = La;
    Lnode *pc = Lc;
    while(pa && pb)
    {
        if(pa->data.index < pb->data.index)
        {
            pc->next = pa;
            pc = pc->next;
            pa = pa->next;
        }
        else if(pa->data.index > pb->data.index)
        {
            pc->next = pb;
            pc = pc->next;
            pb = pb->next;
        }
        else if(pa->data.index == pb->data.index)
        {
            pa->data.coef += pb->data.coef;
            pc->next = pa;
            pc = pc->next;
            pa = pa->next;
            pb = pb->next;
        }
    }
    pc->next = (pa ? pa : pb);
    delete Lb;
}
~~~

## 3.7 循环链表和双向链表

一.循环链表：

![16c599c714b78312a158cc1d2f60931f](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/16c599c714b78312a158cc1d2f60931f.png)

1.在循环链表中，通过判断p->next是否等于**头指针**来判断循环是否结束

2.循环链表中通常通过添加**尾指针**来辅助操作 

二.双向链表：

![d69dc222a9df752685b70264cbed57b4](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/d69dc222a9df752685b70264cbed57b4.png)

1.双向链表是在单链表的每个结点中，再设置一个指向其**前驱节点**的指针域

2.双向链表插入时要注意顺序

![8c6bd8dfd801c43a21c40dec89c268ff](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/8c6bd8dfd801c43a21c40dec89c268ff.png)

## 3.8 循环链表和双向链表的相关操作

1.循环链表的定义

~~~cpp
typedef struct CLnode
{
    ElemType data;
    CLnode *next;
}*CircList;
~~~

2.循环链表的初始化

~~~cpp
//1.传入链表L
//2.令头指针指向自己，完成一个循环链表的初始化
void InitList(CircList &L)
{
    L = new CLnode;
    L->next = L;
}
~~~

==循环链表的基本操作和单链表基本上相同，唯一不同的是，由于循环链表的最后一个结点的next不再是空指针，而是指向头结点，因此，循环中的结束条件要发生变化==

~~~cpp
单链表--------------循环链表
while(p)--------->while(p!=L)
while(p->next)--->while(p->next!=L)
~~~

----

1.双向链表的定义

~~~cpp
typedef struct DuLnode
{
    ElemType data;
    DuLnode *prior, *next;
} * DuLinkList;
~~~

2.双向链表的初始化

~~~cpp
//1.传入链表L
//2.令头指针和尾指针指向空指针
void InitList(DuLinkList &L)
{
    L = new DuLnode;
    L->prior = nullptr;
    L->next = nullptr;
}
~~~

3.头插法创建双向链表

~~~cpp
//1.传入链表L和数量n
//2.创建动态指针p
//3.向指针p内读入数据data
//4.令指针p的前继指向L，后继指向L->next
//5.令L->next->prior指向p，L->next指向p
void CreatListHead(DuLinkList &L, const size_t n)
{
    for (int i = 0; i < n; ++i)
    {
        DuLnode *p = new DuLnode;
        cin >> p->data;
        p->prior = L;
        p->next = L->next;
        L->next->prior = p;
        L->next = p;
    }
}
~~~

![cd8d7783c6a5dda3ba18bd1d3273f65e](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/cd8d7783c6a5dda3ba18bd1d3273f65e.png)

4.尾插法创建双向链表

~~~cpp
//1.传入链表L和数量n
//2.创建动态指针p并向其读入数据
//3.令p的前继指向尾结点，p的后继指向头结点
//4.令尾结点指向p，尾指针也指向p
void CreatListTail(DuLinkList &L, const size_t n)
{
    DuLnode *r = L;
    for (int i = 0; i < n; ++i)
    {
        DuLnode *p = new DuLnode;
        cin >> p->data;
        p->prior = r;
        p->next = r->next;
        r->next = p;
        r->next->prior = p;
        r = p;
    }
}
~~~

![5fe81565f5b4687d9b6766af0291babd_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/5fe81565f5b4687d9b6766af0291babd_720.jpg)

5.在双向链表的第i个位置插入元素

~~~cpp
bool ListInsert_DuL(DuLinkList &L, const int i, const ElemType &e)
{
    //移动指针到i处
    DuLnode *p = L->next;
    int j = 1;
    while (p->next && j < i)
    {
        ++j;
        p = p->next;
    }
    if (j < i || j < 1) //如果i在链表范围内，上面的while循环的终止条件就是j<i
    {
        cerr << "out of range" << endl;
        return false;
    }
    //在堆区创建要插入的结点
    DuLnode *s = new DuLnode;
    s->data = e;
    //重新建立链接关系
    s->prior = p->prior; //第一步：s的前趋等于p的前趋
    p->prior->next = s;  //第二步，用p的前趋结点的next指向插入元素s，更改了第一条链
    s->next = p;         //第三步：s的后继指向p
    p->prior = s;        //第四步：p的前趋改为指向s，更改了第二条链
    //return
    return true;
}
~~~

6.删除双向链表中的某个元素

~~~cpp
//1.传入链表L，位置i
//2.创建指针p指向头结点后面的第一个结点
//3.令指针p指向位置i，如果位置有误，则返回false
//4.令i结点前驱的后继为i结点的后继，i结点后继的前驱为i结点的前驱
bool ListErase_DuL(DuLinkList &L, const int i)
{
    //移动指针到i处
    DuLnode *p = L->next;
    int j = 1;
    while (p->next && j < i)
    {
        ++j;
        p = p->next;
    }
    if (j < i || j < 1) //如果i在链表范围内，上面的while循环的终止条件就是j<i
    {
        cerr << "out of range" << endl;
        return false;
    }
    //改变链接关系
    p->prior->next = p->next;//p的前趋结点的next等于p的后继
    if ((p->next))//如果删除的不是最后一个元素
    {
        p->next->prior = p->prior;
    }
    //释放p
    delete p;
    //结束
    return true;
}
~~~

![c7d8119ffae1219a996a859543519648_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/c7d8119ffae1219a996a859543519648_720.jpg)

## 3.9 三个案例分析

> 案例一：一元多项式运算
>
> 案例二：稀疏多项式运算
>
> 案例三：图书馆管理系统

***案例一：一元多项式的合并 -顺序链表版***

~~~cpp
//1.传入链表L1，L2和返回链表L3
//2.将L1和L2共有的系数放入L3
//3.将L1或L2中剩余的那个系数放入L3
void PolyOperate(SqList &L1, SqList &L2, SqList &L3)
{
    for (int i = 0; i < L1.length && i < L2.length; ++i)
    {
        L3.elem[i] = L1.elem[i] + L2.elem[i];
        L3.length += 1;
    }
    if (L1.length <= L2.length)
    {
        for (int j = L1.length; j < L2.length; ++j)
        {
            L3.elem[j] = L2.elem[j];
            L3.length += 1;
        }
    }
    else
    {
        for (int j = L2.length; j < L1.length; ++j)
        {
            L3.elem[j] = L1.elem[j];
            L3.length += 1;
        }
    }
}
~~~

***稀疏多项式的相加***

> 也即“合并两个有序顺序表”的变形

~~~cpp
//1.传入顺序表L1和L2，传入返回顺序表L3
//2.分别创建L1和L2的指针指向顺序表L1与L2的首部和尾部
//3.创建指针p3指向顺序表的首部
//4.当L1和L2都未指到尾部时进入循环
//5.比较大小，令小的数据传入顺序表L3
//6.将L1或是L2剩余的部分继续接入顺序表L3
void SQL_I(SqList &L1, SqList &L2, SqList &L3)
{
    ElemType *p1 = L1.elem;
    ElemType *p1_last = L1.elem + L1.length - 1;
    ElemType *p2 = L2.elem;
    ElemType *p2_last = L2.elem + L2.length - 1;
    ElemType *p3 = L3.elem;
    while (p1 <= p1_last && p2 <= p2_last)
    {
        if (p1->index < p2->index)
        {
            p3->index = p1->index;
            p3->coef = p1->coef;
            ++p1;
            ++p3;
            ++L3.length;
        }
        else if (p1->index > p2->index)
        {
            p3->index = p2->index;
            p3->coef = p2->coef;
            ++p2;
            ++p3;
            ++L3.length;
        }
        else if (p1->index == p2->index)
        {
            p3->index = p1->index;
            p3->coef = p1->coef + p2->coef;
            ++p1;
            ++p2;
            ++p3;
            ++L3.length;
        }
    }
    while (p1 <= p1_last)
    {
        p3->index = p1->index;
        p3->coef = p1->coef;
        ++p1;
        ++p3;
        ++L3.length;
    }
    while (p2 <= p2_last)
    {
        p3->index = p2->index;
        p3->coef = p2->coef;
        ++p2;
        ++p3;
        ++L3.length;
    }
}
~~~

***稀疏多项式的相加***

> 也即“合并两个有序链表”的变形

~~~cpp
//1.传入链表La，Lb和返回链表Lc
//2.分别令pa，pb指向头结点后面的第一个结点
//3.令pc指向la的第一个结点
//4.比较系数的大小，谁小就令pc->next指向谁，4；相同就令系数相加
//5.将剩余的系数接入链表
//6.删除链表Lb
void SPO_II(LinkList &La, LinkList &Lb, LinkList &Lc)
{
    Lnode *pa = La->next;
    Lnode *pb = Lb->next;
    Lc = La;
    Lnode *pc = Lc;
    while(pa && pb)
    {
        if(pa->data.index < pb->data.index)
        {
            pc->next = pa;
            pc = pc->next;
            pa = pa->next;
        }
        else if(pa->data.index > pb->data.index)
        {
            pc->next = pb;
            pc = pc->next;
            pb = pb->next;
        }
        else if(pa->data.index == pb->data.index)
        {
            pa->data.coef += pb->data.coef;
            pc->next = pa;
            pc = pc->next;
            pa = pa->next;
            pb = pb->next;
        }
    }
    pc->next = (pa ? pa : pb);
    delete Lb;
}
~~~

***图书管理系统 - 单链表实现***

*结构体定义*

~~~cpp
typedef struct Book
{
    string isbn;
    string name;
    float price;
} ElemType;
struct Lnode
{
    ElemType data;
    Lnode *next;
} *LinkList;
~~~

其他操作，例如对图书的添加、删除、查找等操作，和单链表基本上一样的，这里就不赘述了。不过，受到《C++ Primer》的启发，我们可以添加两个这样的函数，简化程序：

~~~cpp
//使用read函数向ElemType的对象写入数据
istream &read(istream &in, ElemType &rhs)
{
    in>>rhs.isbn;
    in>>rhs.name;
    in>>rhs.price;
    return in;
}
~~~

~~~cpp
//使用print函数打印ElemType对象
ostream &print(ostream &out, ElemType &rhs)
{
    out<<rhs.isbn<<" "
        <<rhs.name<<" "
        <<rhs.price<<endl;
    return out;
}
~~~

如何使用这两个函数？

~~~cpp 
//读
read(cin, L->data);
//写
print(cout, L->data);
~~~

本篇完~





# 四. 栈与队列

栈与队列：

栈是限定仅在表尾进行插入和删除操作的线性表

队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表

## 4.1 栈的定义

1.栈(stack)是限定仅在表尾进行插入和删除操作的线性表

2.我们把允许插入和删除的一端称为==栈顶(top)==，另一端称为==栈底(bottom)==，不含任何数据元素的栈称为空栈。

栈又称为==后进先出==(Last In First Out)的线性表，简称LIFO结构。

==表尾是栈顶==，表底是固定的，最先进栈的只能在栈底。

3.栈的==插入==操作叫做==进栈==，也称压栈、入栈，栈的==删除==操作叫做==出栈==，也称弹栈



## 4.2 栈的顺序存储结构及实现

1.==下标为0==的一端作为==栈底==，因为首元素都存在栈底。

​	定义==top指针==，指示==栈顶元素之上==的下标位置。

​	另设==base指针==，指示==栈底元素==在顺序栈中的位置。

​	用==stacksize==表示栈可使用的==最大容量==

![2c672a5f9e37e7731facd6910ea6e412](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2c672a5f9e37e7731facd6910ea6e412.png)

2.==空栈==：base==top

​	==栈满==：top-base==stacksize



----

1.顺序栈的定义

~~~cpp
struct SqStack
{
    ElemType *base;
    ElemType *top;
    int stacksize;
};
~~~

2.顺序栈的初始化

~~~cpp
//1.传入顺序栈S
//2.令栈的底指针base指向新开辟的数组的首地址
//3.如果开辟失败，返回false
//4.如果开辟成功，则令顶指针top与base指向相同，表明这是一个空栈
//5.赋予顺序栈容量
bool InitStack(SqStack &S)
{
    S.base = new ElemType[MAXSIZE];
    if (!S.base)
    {
        cerr << "failed to get memory" << endl;
        return false;
    }
    S.top = S.base;
    S.stacksize = MAXSIZE;
    return true;
}
~~~

3.压栈

~~~cpp 
//1.传入顺序栈S，和要被压栈的数据e
//2.首先判断栈是否满，如果满则返回false
//3.如果栈未满，则令top指向的位置赋值e，并令top指针上移一位，返回true
bool Push(SqStack &S, ElemType &e)
{
    //判断栈是否已满
    if((S.top-S.base) == S.stacksize)
    {
        cerr << "full of stack" << endl;
        return false;
    }
    *(S.top) = e;
    ++(S.top);
    return true;
}
~~~

4.创建一个栈

~~~cpp
//1.传入要创建的顺序栈S，和栈的大小n
//2.使用for循环压栈n个元素
//3.使用if判断压栈是否成功，如果压栈成功则不会进入if内的语句
//4.全部压栈成功后，返回true
bool CreatStack(SqStack &S, const int n)
{
    for (int i = 0; i < n;++i)
    {
        ElemType input;
        cin >> input;
        if(!Push(S,input))
        {
            cerr << "error happend at-" << i << endl;
            return false;
        }
    }
    return true;
}
~~~

5.弹栈

~~~cpp
//1.传入要弹栈的顺序栈S和被弹栈的接受数据e
//2.判断顺序栈S是否为空，如果为空，则进入if函数，输出false
//3.如果不为空，由于top指向数据的上一个位置，所以先令top指针下移
//4.用e接受此时top指针指向的数据
bool Pop(SqStack &S, ElemType &e)
{
    if(S.top == S.base)
    {
        cerr << "empty stack!error" << endl;
        return false;
    }
    --(S.top);
    e = *(S.top);
    return true;
}
~~~

6.判断顺序栈是否为空

~~~cpp
//1。传入要判断的顺序表S
//2.如果顶指针与底指针指向相同，则说明此时顺序栈为空，返回true
//3.如果不为空则返回false
bool IsEmpty(SqStack &S)
{
    if (S.base == S.top)
    {
        return true;
    }
    else
    {
        return false;
    }
}
~~~

7.获取栈的元素个数

~~~cpp
//1.传入顺序栈S
//2.此时顺序栈内的元素个数等于top-base转换为int型的个数
int StackLength(SqStack &S)
{
    return static_cast<int>(S.top - S.base);
}
~~~

8.清空顺序栈

~~~cpp
//1.传入顺序栈S
//2.如果底指针存在，则令top指针与base指针指向同一位置，返回true
//3.如果底指针不存在，则返回false
bool ClearStack(SqStack &S)
{
    if(S.base)
    {
        S.top = S.base;
        return true;
    }
    else
    {
        return false;
    }
}
~~~

9.销毁顺序栈

~~~cpp
//1.传入顺序栈S
//2.由于base指针指向数组的底部，所以删除base指针指向的数组
//3.令stacksize为0
//4.令top指针和base指针都指向空
void DestoyStack(SqStack &S)
{
    if(S.base)
    {
        delete[] S.base;
        S.stacksize = 0;
        S.base = S.top = nullptr;
    }
}
~~~

## 4.3 栈的链式存储结构及实现

1.栈顶放在单链表的头部，通常对于链栈来说，是不需要头结点的

2.链表的空是指top=NULL的时候

![2c1426718bb6e211f2b646b8abf67adf](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2c1426718bb6e211f2b646b8abf67adf.png)

---

1.链式栈的定义

~~~cpp
typedef struct StackNode
{
    ElemType data;
    StackNode *next;
} * LinkStack;
~~~

2.栈的初始化

~~~cpp
//1.传入链栈指针S的引用
//2.令栈顶指针指向空
void InitStack(LinkStack &S)
{
	S=NULL;
    return OK;
}
~~~

2.压栈

~~~cpp
//1.传入链栈S和数据e
//2.创建临时指针temp指向一个新的结点，并将这个结点的数据赋值为e
//3.令新结点指向S此时的位置
//4.令指针S指向tmep此时的位置
void Push(LinkStack &S, const ElemType &e)
{
    //插入元素
    StackNode *temp = new StackNode;
    temp->data = e;
    temp->next = S;
    S = temp;
}
~~~

3.弹栈

~~~cpp
//1.传入链栈S和传出数据e
//2.令e等于此时S指向的数据
//3.创建新指针p指向此时S指向的结点
//4.令S指向下一节点
//5.删除结点p
void Pop(LinkStack &S, ElemType &e)
{
    e = S->data;
    StackNode* p = new StackNode;
    p = S;
    S = S->next;
    delete p;
}
~~~

4.创建栈

~~~cpp
//1.传入链栈S和栈内个数n
//2.使用for循环进行循环压栈
void CreatStack(LinkStack &S, const int n)
{
    ElemType input;
    for (int i = 0; i < n;++i)
    {
        cin >> input;
        Push(S, input);
    }
}
~~~

5.判断栈是否为空

~~~cpp
//1.传入链栈S
//2.如果此时S指向为空，则是空栈，并返回true
bool IsEmpty(LinkStack &S)
{
    if(S==NULL)
    {
        return true;
    }
    else 
    {
        return false;
    }
}
~~~

## 4.4 队列的定义

1.队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表

2.队列是一种==先行先出==(First In First Out)的线性表，简称FIFO，允许==插入==的一端称为==队尾==，允许==删除==的一端称为==队头==

3.插入数据只能在队尾进行，称为入队；删除数据只能在队头进行，称为出队。

![fd5034cdc8946ffdb0bcf3ca79cf84a4](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/fd5034cdc8946ffdb0bcf3ca79cf84a4.png)





## 4.5 队列的顺序结构及实现

1.队列使用elem存储数据，front指向首元素，rear指向尾元素上面的地址

2.顺序队列一般使用==少用一个元素空间==的==循环队列==，来防止数据的溢出

3.队空： front == rear

队满： (rear + 1) % MAXQSIZE == front

队列长度： (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE

![f886b7df0d4a87874e29167a62dacbcf](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/f886b7df0d4a87874e29167a62dacbcf.png)

----------------

1.顺序队列定义

~~~cpp
struct SqQueue
{
    ElemType *elem;
    int front;
    int rear;
};
~~~

2.顺序队列初始化

~~~cpp
//1.传入顺序队列Q
//2.为数据分配空间
//3.令首尾指针相同并同时为0
void InitQueue(SqQueue &Q)
{
    Q.elem = new ElemType[MAXSIZE];
    Q.front = Q.rear = 0;
}
~~~

3.判断队是否为空

~~~cpp
//1.传入顺序队列Q
//2.如果首位指针相同，则说明为空，此时返回true
//3.如果不相同，说明此时不为空，返回false
bool IsEmpty(SqQueue &Q)
{
    if (Q.front == Q.rear)
        return true;
    else
        return false;
}
~~~

4.判断是否满队

~~~cpp
//1.传入顺序队列Q
//2.使用公式计算此时是否相同
//3.如果相同，说明以满，返回true
//4.若不相同，在返回false
bool IsFull(SqQueue &Q)
{
    auto rear_next = (Q.rear + 1) % MAXSIZE;
    if (rear_next == Q.front)
        return true;
    else
        return false;
}
~~~

5.进队

~~~cpp
//1.传入顺序队列Q和数据e
//2.首先判断队列是否已满，若满则返回false
//3.若此时未满，则令此时rear指向的位置赋值数据e
//4.将rear指向+1
bool InsertQueue(SqQueue &Q, const ElemType &e)
{
    //如果队尾+1等于队头，表明队已经满了（该队列是少用一个空间的循环队列，满队和空队的判断条件不一致）
    if (IsFull(Q))
    {
        cerr << "full of Queue" << endl;
        return false;
    }
    Q.elem[Q.rear] = e;
    Q.rear = (Q.rear + 1) % MAXSIZE;
    return true;
}
~~~

6.批量进队

~~~cpp
//1.传入顺序队列Q和个数n
//2.使用for循环压栈n个数据
void CreatQueue(SqQueue &Q, const int n)
{
    cout << "input msg" << endl;
    ElemType input;
    for (int i = 0; i < n;++i)
    {
        cin >> input;
        InsertQueue(Q, input);
    }
}
~~~

7.出队

~~~cpp
//1.传入顺序队列Q，接受数据e
//2.首先判断队列是否为空，若为空则返回false
//3.从头部出对，并令队头指针上移一位
bool EraseQueue(SqQueue &Q, ElemType &e)
{
    //如果队头等于队尾，表明队里没有元素，不执行该程序
    if (IsEmpty(Q))
    {
        cerr << "no elem to erase" << endl;
        return false;
    }
    e = Q.elem[Q.front];
    Q.front = (Q.front + 1) % MAXSIZE;
    return true;
}
~~~

8.求队列的元素个数

~~~cpp
//1.传入顺序队列Q
//2.根据公式返回队列个数
int GetLength(SqQueue &Q)
{
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
~~~

9.打印队列

~~~cpp
//1.传入顺序队列Q
//2.使用for循，在队列为空之前输出数据。
void PrintQueue(SqQueue &Q)
{
    cout << "Queue:" << endl;
    for (auto i = Q.front; i != Q.rear; i = (i + 1) % MAXSIZE)
    {
        cout << Q.elem[i] << endl;
    }
}
~~~

## 4.6 队列的链式结构及实现

1.若用户无法估计所用队列的长度，应采用链队列

2.我们将对头指针指向链队列的头结点，而队尾指针指向终端结点

3.空队列：front和rear都指向头结点



![3750c9bf3036894120ad3adf97970e51](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/3750c9bf3036894120ad3adf97970e51.png)

-----------------

1.定义链队

~~~cpp
//定义结点类型
typedef struct Qnode
{
    ELemType data;
    Qnode *next;
}QNode,*QuenePtr;
//定义队列，其中包含结点类型的头指针后尾指针
//其中头指针中的数据存储数据元素个数，尾指针的存储需要的数据信息
struct LinkQueue 
{
    Qnode *front; //头指针
    Qnode *rear;  //尾指针
};
~~~

2.初始化

~~~cpp
//1.令首指针和尾指针都指向头结点
//2.令头结点内的data数据元素为0，代表元素个数
//3.令头结点指向空
void InitQueue(LinkQueue &Q)
{
    Q.front = Q.rear = new Qnode;
    Q.front->data = 0; //用于保存链队的元素个数
    Q.rear->next = nullptr;
}
~~~

3.进队

~~~cpp
//1.传入链队列Q和数据e
//2.创建链式指针temp
//3.向临时指针temp内读入数据，并指向空
//4.令此时尾指针指向的结点此时指向temp，并令rear指向temp
//5.令头结点内的data+1，代表此时的元素个数
void InsertQueue(LinkQueue &Q, const ELemType &e)
{
    //把元素插在最后面
    Qnode *temp = new Qnode;
    temp->data = e;
    temp->next = nullptr;
    Q.rear->next = temp;
    Q.rear = temp;
    ++Q.front->data; //元素个数加1
}
~~~

4.创建链队

~~~cpp
//1.传入链队列Q和个数n
//2.通过for循环读入n个数据
void CreatQueue(LinkQueue &Q, const int n)
{
    cout << "input msg" << endl;
    ELemType input;
    for (int i = 0; i < n; ++i)
    {
        cin >> input;
        InsertQueue(Q, input);
    }
}
~~~

5.出队

~~~cpp
//1.传入链队列Q
//2.判断此时头结点的指向是否为空，如果是，则说明此时队列已经是空队列
//3.创建指针p指向首页结点
//4.将头结点指向第二个结点
//5.将元素的值赋给e
//6.删除临时指针p
//7.将头结点中的元素个数-1
bool EraseQueue(LinkQueue &Q,ElemType &e)
{
    if (Q.front->next == nullptr)
    {
        cerr << "empty Queue" << endl;
        return false;
    }
    Qnode *p = Q.front->next;
    Q.front->next = p->next;
    e = p->data;
    delete p;
    --Q.front->data; //元素个数-1
    return true;
}
~~~

6.打印链队

~~~cpp
//1.传入链队列Q
//2.创建链式指针p指向首元结点
//3.当指针p不为空时，输出此时p指向的数据
//4.当指针p指向空时，说明此时以到队尾，打印完成
void PrintQueue(LinkQueue &Q)
{
    Qnode *p = Q.front->next;
    while (p)
    {
        cout << p->data << endl;
        p = p->next;
    }
}
~~~

# 五. 串、数组和广义表

串：串(string)是由零个或多个字符组成的有限序列

## 5.1 串的定义

1.串：串(string)是由零个或多个字符组成的有限序列

子串：一个串中任意个连续字符组成的子序列(含空串)称为该串的子串

主串：包含子串的串

空格串：只包含空格的串

子串位置：子串第一个字符在主串中的位置

2.串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的



## 5.2 串的存储结构

1.串的顺序存储结构：用一组地址连续的存储单元来存储串中的字符序列

![92acca0eb145e0b2059a01c3014e0f3d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/92acca0eb145e0b2059a01c3014e0f3d.png)

```cpp
typedef struct __SString 
{
    char ch[MAXLEN + 1]; //存储串的一维数组
    int length;	//串的当前长度
} SString;
```

2.串的链式存储结构：一个结点可以存放一个字符，也可以存放多个字符

![734e8dd43ab8f73c7a77813639294c01](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/734e8dd43ab8f73c7a77813639294c01.png)

```c++
#define CHUNKSIZE 80 //每一节点的最大长度
typedef struct __Chunk 
{
	char ch[CHUNKSIZE + 1];
	__Chunk *next;
} Chunk;
typedef struct __LString 
{
	Chunk *head, *tail;
	int curlen; //当前字符串长度
} LString;
```





## 5.3 朴素的模式匹配算法(BF算法)





## 5.4 KMP模式匹配算法





## 5.5 数组

1.数组：按一定格式排列起来的，具有相同类型的数据元素的集合





## 5.6 广义表

1.广义表：(又称列表Lists)是n>=0个元素的有限序列，其中每一个ai或者是原子，或者是一个广义表







# 六. 树、二叉树、森林



## 6.1 树的定义

1.树的定义：

树(Tree)是n(n>=0)个结点的有限集。若n=0，称为空树；若n>0，则它满足如下两个条件：

(1)有且仅有一个特定的称为根(Root)的结点

(2)其余结点可分为m(m>=0)个互不相交的有限集T1，T2，T3,......,Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree).

![2cdfe705382fd03e2ffaa23d797e5a37](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2cdfe705382fd03e2ffaa23d797e5a37.png)

![85c4cb24e39fcd8b6074c1adf1459a82](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/85c4cb24e39fcd8b6074c1adf1459a82.png)

2.树的基本术语：

![8ee557e5d84c652949a426426924c9cb](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/8ee557e5d84c652949a426426924c9cb.png)

| 定义：                                  | 示例：                                          |
| --------------------------------------- | ----------------------------------------------- |
| 根节点：非空树中无前驱结点的结点。      | 上图中的A结点                                   |
| 结点的度：结点拥有的子树数              | degree(A)=3,degree(B)=2,degree(C)=1,degree(D)=3 |
| 树的度：树内各结点的度的最大值          | 上图树的度为3                                   |
| 树的深度：树种结点的最大层次            | 上图中树的深度为4                               |
| 孩子：结点的子树的根称为该结点的孩子    | K和L是E的孩子                                   |
| 双亲：子树的根称为子树的双亲            | E是K和L的双亲                                   |
| 兄弟：同一个双亲的孩子之间互称兄弟      | H、I、J互为兄弟                                 |
| 堂兄弟：双亲在同一层的结点              | G和H是堂兄弟                                    |
| 非终端结点/内部结点：由双亲和孩子的结点 | 上图中如B、C、D都是非终端结点/内部结点          |
| 终端结点/叶子：没有孩子的结点           | 上图中K,L,M都是终端结点/叶子                    |
| 森林：是m(m>=0)棵互不相交的树的集合     | 把上图中根节点A删除后，其余树便组成了森林       |

树一定是森林，但是森林不一定是树



## 6.2 二叉树的定义和性质

1.二叉树的定义：二叉树是n(n>=0)个结点的有限集，它或是空集(n=0)，或者由一个根节点及两个互不相交的分别称作这个跟的左子树和右子树的二叉树组成

特点：

- 每个结点最多有俩孩子(二叉树中不存在度大于2的结点)


- 子树有左右之分，其次序不能颠倒


- 二叉树可以是空集合，根可以有空的左子树或空的右子树


![bbc420f8db8488510700c09b0206fdd1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/bbc420f8db8488510700c09b0206fdd1.png)

2.二叉树的性质：

第一层的编号i=1而不是0

| 性质：                                                       | 拓展：                                                       |
| ------------------------------------------------------------ | :----------------------------------------------------------- |
| 性质1：在二叉树的第i层上至多有$2^{i-1}$个结点(数学归纳法推导) | 第i层上至少有1个结点                                         |
| 性质2：深度为k的二叉树之多有$2^k-1$(k>=1)个结点(等比数列求和) | 深度为k时至少有k个结点                                       |
| 性质3：对任何一颗二叉树T，如果其叶子树为$n_0$,度为2的结点数为$n_2$,则$n_0=n_2+1$。 | 设总边数B来推导                                              |
| 性质4：具有n个结点的完全二叉树的深度为$\lfloor\log_2n\rfloor+1$. | $\lfloor x \rfloor$称作x的底，表示不大于x的最大整数          |
| 性质5：如果对一颗有n个结点的完全二叉树(其深度为$\lfloor\log_2n\rfloor+1$)的结点按层序编号(从第1层到第$\lfloor\log_2n\rfloor+1$层，每层从左到右，对任一节点i(1<=i<=n)有： | (1)如果i=1，则结点j是二叉树的根，无双亲；如果i>1，其双亲是结点$\lfloor i/2\rfloor$. |
|                                                              | (2)如果2i>n，则结点j无左孩子(结点i为叶子结点)；否则其左孩子是结点2i |
|                                                              | (3)如果2i+1>n，则结点i无右孩子；否则其右孩子是结点2i+1       |

性质3推导过程:

![71a9d142c3a7ed2502b02d23cfd54d8f_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/71a9d142c3a7ed2502b02d23cfd54d8f_720.png)

性质5演示：

![94f1f07c99eba22a76c14ae1d67b17bb](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/94f1f07c99eba22a76c14ae1d67b17bb.png)

3.满二叉树：

一棵深度为k且有$2^k-1$个结点的二叉树称为满二叉树

特点：

- 每一层上的结点数都是最大结点数(即每层都满)

- 叶子结点全部在最底层

- 对满二叉树结点位置进行编号，从根结点开始，自上而下，自左而右，每一个结点位置都有元素




4.完全二叉树：

深度为k的具有n给结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号为1~n的结点一一对应时，称之为完全二叉树

住：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一颗完全二叉树(一定是==连续的去掉==)。

特点：

- 叶子只可能分布在层次最大的两层上


- 对任一结点，如果其右子树的最大层次为i，则其左子树的最大层次必为i或i+1.




![3535fc219c577a242b71a8b8537e569c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/3535fc219c577a242b71a8b8537e569c.png)



## 6.3 二叉树的存储结构

**1.二叉树的顺序存储结构：**

```cpp
#define MAXTSIZE 100
typedef TElemType SqBiTree[MAXTSIZE]
SqBiTree bt;
```

由于顺序存储结构容易造成空间的浪费，所以二叉树的顺序存储结构一般用于满二叉树或完全二叉树，

![a6fe1c9ebe6d584c5643a4d7b033606e](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a6fe1c9ebe6d584c5643a4d7b033606e.png)

**2.二叉树的链式存储结构：**

二叉链表：

```cpp
typedef struct BiNode
{
    TElemType data;
    struct BiNode *lchild, *rchild;	//左右孩子指针
}BiNode,*BiTree;
```

在n个结点的二叉链表中，有n+1个空指针域



**3.三叉链表：**

```cpp
typedef struct BiNode
{
    TElemType data;
    struct BiNode *parent,*lchild, *rchild;	//双亲指针+左右孩子指针
}BiNode,*BiTree;
```





## 6.4 遍历二叉树

假设:L：遍历左子树    D：访问根结点    R：遍历右子树，规定先左后右，则有以下三种情况：

DLR——先序遍历

LDR——中序遍历

LRD——后序遍历

![43e529d872ea9d11ca5b50abda70e6d8](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/43e529d872ea9d11ca5b50abda70e6d8.png)

遍历时先从根节点开始，然后按照规则进行遍历，分叉遍历成功后返回到上一级

1.先序遍历(根左右DLR)：

![01e2912c0ca14c2ec1668d61fe4660fb](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/01e2912c0ca14c2ec1668d61fe4660fb.png)

遍历顺序结果:ABDGHCEIF

```cpp
bool PreOrderTraverse(BiTree &T)
{
    if(T == nullptr)
    {
        return true;
    }
    //访问根结点
    visit(T);
    //递归遍历左孩子
    PreOrderTraverse(T->lchild);
    //递归遍历右孩子
    PreOrderTraverse(T->rchild);
    return true;
}
```

2.中序遍历(左根右LDR)：

![d48e948cfcabb217cc20453179693b4d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/d48e948cfcabb217cc20453179693b4d.png)

遍历顺序结果:GDHBAEICF

```cpp
bool InOrderTraverse(BiTree &T)
{
    if (T == nullptr)
    {
        return true;
    }
    //第一步：访问左孩子
    InOrderTraverse(T->lchild);
    //第二步：访问根结点
    visit(T);
    //第三步：访问右孩子
    InOrderTraverse(T->rchild);
    return true;
}
```

3.后序遍历(左右根LRD)：



![46a6f6fab2c116f3d4939e8c02e6f33f](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/46a6f6fab2c116f3d4939e8c02e6f33f.png)

遍历顺序结果:GHDBIEFCA

```cpp
bool PostOrderTraverse(BiTree &T)
{
    if (T == nullptr)
    {
        return true;
    }
    //第一步：访问左孩子
    PostOrderTraverse(T->lchild);
    //第二步：访问右孩子
    PostOrderTraverse(T->rchild);
    //第三步：访问根结点
    visit(T);
    return true;
}
```

- 三种算法的时间复杂度：O(n)，空间复杂度：O(n)


- 三种算法的思想都是DFS（深度优先算法）




4.由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一颗二叉树

使用先序和中序的确定流程：

![4ca98f6c365f0dc1d9d5c1b56e93c462_720](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/4ca98f6c365f0dc1d9d5c1b56e93c462_720.png) 

使用后序和中旬的确定流程：

![7daeb886f91c50e3629299c3fe3a7e47](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/7daeb886f91c50e3629299c3fe3a7e47.png)

5.二叉树的中序遍历——非递归算法(使用栈)：

```cpp
//1.传入二叉树指针T指向二叉树的根节点
//2.创建栈S并初始化，创建指针p指向根节点
//3.当指针p未指向空或者栈没空时进入循环
//4.根据中序LDR的顺序判断
//5.如果指针p此时不为空，则将此时指针p所指数据入栈，并令p指向p的左孩子
//6.如果指针p此时为空，则令此时最后入栈的数据出栈给p，并令指针p指向此时指针p的右孩子
//7.等到所有数据都出栈后结束循环
void LDR(BiTree &T)
{
    //1.创建一个栈，用于保存二叉树的结点
    SqStack S;
    //2.创建栈S并初始化，创建指针p指向根节点
    InitSqStack(S);
    BiTree p = T;
    //3.当指针p未指向空或者栈没空时进入循环
    while( p || !IsEmpty(S))
    {
        //4.根据中序LDR的顺序判断
        //5.如果指针p此时不为空，则将此时指针p所指数据入栈，并令p指向p的左孩子
        if(p)
        {
            Push(S, p);
            p = p->lchild;
        }
        //6.如果指针p此时为空，则令此时最后入栈的数据出栈给p，并令指针p指向此时指针p的右孩子
        else
        {
            Pop(S, p);
            visit(p);
            p = p->rchild;
        }
    }
}
```

6.二叉树的层次遍历(使用队列)：

对于一颗二叉树，从根节点开始，按从上到下、从左到右的顺序访问每一个结点，每一个结点仅仅访问一次

![2b10c9012791abfd3fae42b3ab76f215](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/2b10c9012791abfd3fae42b3ab76f215.png)

```cpp
//1.传入二叉树的头指针S
//2.创建队列Q并初始化队列Q
//3.创建二叉树指针p，并将根节点压入队列
//4.当队列不为空时进入循环
//5.首先将队列中的头元素出队列并输出，并将该元素的左孩子和右孩子压入队列
//6.重复步骤5，直到队列中不在有元素存在
void LevelOrder(BiTree &S)
{
    /*
    算法设计思路：
    1.将根结点入队
    2.队列不为空时循环，从队列中出列一个元素，访问它，并作以下步骤：
        2.1 如果该元素的左孩子不为空，让该元素的左孩子入队
        2.2 如果该元素的右孩子不为空，让该元素的右孩子入队
    */
    //2.创建队列Q并初始化队列Q
    SqQueue Q;
    InitSqQueue(Q);
	//3.创建二叉树指针p，并将根节点压入队列
    BiTree p;
    PushQueue(Q, S);
    //4.当队列不为空时进入循环
    while (!QueueEmpty(Q))
    {
        //5.首先将队列中的头元素出队列并输出，并将该元素的左孩子和右孩子压入队列
        //将根结点出队
        DeQueue(Q, p);
        //访问根结点
        cout << p->data << endl;
        //if判断，是否能将根结点的左右孩子进队
        if (p->lchild != nullptr)
        {
            PushQueue(Q, p->lchild);
        }
        if (p->rchild != nullptr)
        {
            PushQueue(Q, p->rchild);
        }
    }
}
```

## 6.5 二叉树遍历算法的应用

1.二叉树的建立

按先序遍历序列(DLR)建立二叉树的二叉链表：

```cpp
//1.传入二叉树根节点T
//2.输入标志ch，如果是"#",则令指针指向空
//3.如果ch不是"#",则令T指向新空间，并把数据读入新空间内
//4.根据根左右(DLR)的顺序，建立二叉树
bool CreatBiTree(BiTree &T)
{
    char ch;
    cin >> ch;
    if(ch == "#")
    {
        T = NULL;
    }
    else
    {
        T = new BiNode;
    	//D
    	T->data = input;
    	//L
    	CreatBiTree(T->lchild);
    	//R
    	CreatBiTree(T->rchild);
    }
    return true;
}
```

![53d322aaa7f2ab54a55c5d48ef628552](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/53d322aaa7f2ab54a55c5d48ef628552.png)

2.复制二叉树：

```cpp
//1.传入原始二叉树T和接受二叉树NewT
//2.如果二叉树T为空，则返回false，并令接受二叉树NewT指向空
//3.如果不为空，则令此时的NewT接受数据，并传入T与NewT的左子树进行递归
//4.左子树递归完后，递归右子树
bool CopyBiTree(const BiTree &T, BiTree &NewT)
{
    if(T == nullptr)
    {
        NewT == NULL;
        return false;
    }
    else
    {
        NewT = new BiNode;
    	//D
    	NewT->data = T->data;
    	//L
    	CopyBiTree(T->lchild, NewT->lchild);
    	//R
    	CopyBiTree(T->rchild, NewT->rchild);
    	return true;
    }
}
```

3.计算二叉树的深度：

```cpp
//1.传入二叉树头指针T
//2.如果此时二叉树为空，则返回0
//3.如果此时二叉树不为空，则令m接受左子树的遍历，n接受右子树的遍历
//4.遍历结束后比较m和n的大小，返回大的那个值并+1.
int Depth(BiTree &T)
{
    if(T == nullptr)
    {
        return 0;
    }
    int m = Depth(T->lchild);
    int n = Depth(T->rchild);
    if(m>n)
        return m+1;
    else
        return n+1;
}
```

4.计算二叉树结点总数：

```cpp
//1.传入二叉树头结点T
//2.如果头结点为空，则返回0
//3.如果不为空，则通过递归计算左结点和右结点数并最后+1
//4.这个1是包含自己的意思
int CountNode(BiTree &T)
{
    if (T == nullptr)
    {
        return 0;
    }
    return CountNode(T->lchild) + CountNode(T->rchild) + 1;
}
```

5.计算二叉树叶子点数：

```cpp
//1.传入二叉树头结点T
//2.如果是空树则返回0
//3.如果不是空树，则需要判断这个结点的左子树和右子树是否都为空
//4.如果都是空则返回1
//5.如果不都为空，则通过遍历计算左右结点的叶子数
int Count0Node(BiTree &T)
{
    if (T == nullptr)
    {
        return 0;
    }
    if (T->lchild == nullptr && T->rchild == nullptr)
    {
        return 1;
    }
    return Count0Node(T->lchild) + Count0Node(T->rchild);
}
```

6.线索二叉树：

如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某节点的右孩子为空，则将空的右孩子指针域改为指向其后继，这种改变指向的指针称为"线索"。

![94e3b76e5b58b150b6e0255d743c8f88](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/94e3b76e5b58b150b6e0255d743c8f88.png)

```cpp
typedef struct BiThrNode
{
    int data;
    int ltag,rTag;
    struct BithrNode *lchild,*rchild;
}BiThrNode,*BithrTree;
```

为了方便操作，在结点之上添加一个头结点root

![9e34cf1002395a8b20ff66d02307b268](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/9e34cf1002395a8b20ff66d02307b268.png)



## 6.6 树和森林

1.双亲表示法：

![534613f5c352661eb86df2d017be4c84](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/534613f5c352661eb86df2d017be4c84.png)

结点结构：

```cpp
typedef struct PTNode
{
    DataType data;	//数据域
    int parent;		//双亲的序号
}
```

树结构：

```cpp
#define MAXSIZE 100
typedef struct PTree 
{
	PTNode nodes[MAXSIZE];	//结点数组
	int root; //根节点位置
	int n; //当前节点个数
};
```



2.孩子链表：

![0d984106a1b28c5d45f33de880172ff7](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/0d984106a1b28c5d45f33de880172ff7.png)

孩子结点结构：

```cpp
struct CTNode 
{
	int chlid;
	CTNode *next;
};
```

双亲结点结构：

```cpp
struct CTBox 
{
	DataType data;
	int parent; //可有可无，看具体需求
	CTNode * child;
};
```

树结构：

```cpp
struct CTree 
{
	CTBox[MAXSIZE];
	int root;
	int n;
};
```

![1d739505cd0868eb855cd229ada5f537](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/1d739505cd0868eb855cd229ada5f537.png)



3.孩子兄弟表示法：

用二叉链表作树的存储结构，链表中每个结点的两个指针域分别指向其第一个孩子结点和下一个兄弟结点

![a68985f05313173ae0b8da03111d6fb6](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a68985f05313173ae0b8da03111d6fb6.png)



```cpp
//节点的child指针域指向它的第一个孩子，sibling指向第一个兄弟
struct CSNode 
{
    DataType data;
	CSNode * child, *sibling;
};
```



4.树与二叉树的转换

![73a0143d99a2c9e50e4d0f4eead51f95](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/73a0143d99a2c9e50e4d0f4eead51f95.png)

树变二叉树：兄弟相连留长子

![e060f0acc02c71556323fef8a87990fe](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/e060f0acc02c71556323fef8a87990fe.png)

二叉树变树：

左孩右右连双亲，去掉原来右孩线

![a6258ddfd9561f62fdd05365e048f44a](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a6258ddfd9561f62fdd05365e048f44a.png)



5.森林与二叉树的转换：

森林变二叉树：树变二叉根相连

![4eb87a2fd15f4fe4f0c7d2ba67b7cdb5](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/4eb87a2fd15f4fe4f0c7d2ba67b7cdb5.png)



二叉树转换成森林：去掉全部右孩线，孤立二叉再还原

![e15604fbf6009632b160a2e174a35e8b](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/e15604fbf6009632b160a2e174a35e8b.png)



6.森林的遍历：

![d11043c197f151082ab211c50f3244b4](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/d11043c197f151082ab211c50f3244b4.png)



## 6.7 哈夫曼树

### 6.7.1 哈夫曼树的基本概念：

1.路径：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

2.结点的路径长度：两结点间路径上的分支数

3.树的路径长度：从**树根**到每一个结点的路径长度之和。记作：TL

4.权(weight)：将书中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权

5.结点的带权路径长度：从**根节点**到该结点之间的**路径长度**与该结点的**权**的**乘积**

6.树的带权路径长度：树中所有**叶子结点**的带权路径长度之**和**记作$WPL=\sum_{k=1}^nw_kl_k$

其中$w_k$是权值，$l_k$是结点到根的路径长度

哈夫曼树：最优二叉树(带权路径长度WPL最短的二叉树)

![6c727202585b1818bdce2d56a3ce026b](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6c727202585b1818bdce2d56a3ce026b.png)

注意：

- 满二叉树不一定是哈夫曼树


- 哈夫曼树中权越大的叶子离根越近


- 具有相同带权结点的哈夫曼树不唯一




### 6.7.2 哈夫曼树的构造

1.哈夫曼算法口诀：

构造森林全是根，选用两小造新树，删除两小添新人，重复2，3剩单根。

2.哈夫曼树的==结点的度数为0或2==，==没有度为1的结点==，包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点

3.包含==n个叶子结点==的哈夫曼树中共有==2n-1个结点==

4.构建哈夫曼树示例：

![c7d4c6f1bf0af8d154b0cb0e22e5d94d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/c7d4c6f1bf0af8d154b0cb0e22e5d94d.png)

### 6.7.3 哈夫曼树算法实现

![6d851a69ce12c484413915aa1eef4d5a](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6d851a69ce12c484413915aa1eef4d5a.png)

1.哈夫曼树的定义：

```cpp
typedef struct HNode
{
    int weight;                 //权重
    int parent, lchild, rchild; //每个结点的双亲、左右孩子的数组下标
} * HuffmanTree;
```

2.哈夫曼树的初始化：

```cpp
//1.传入哈夫曼树H，哈夫曼树的初始结点个数n
//2.使用顺序存储结构定义哈夫曼树，哈夫曼树中共有2n-1个结点，所以定义数组为2n
//3.哈夫曼树中共有2n-1个结点，不使用0下标
//4.初始化时令2n-1个结点的双亲和孩子结点指向都为0
//5.为前n个结点输入权重
void InitHTree(HuffmanTree &H, const int n)
{
    //哈夫曼树的存储结构为顺序存储
    //由哈夫曼树的构造过程得知，n个权重结点构造出的哈夫曼树具有2*n-1个结点
    //通常哈夫曼树的顺序存储结构下标从1开始计数，因此，如果我们使用数组实现的话
    //那么数组的长度应该是2*n
    H = new HNode[2 * n];
    for (int i = 1; i < 2 * n; ++i)
    {
        H[i].parent = H[i].lchild = H[i].rchild = 0;//右结合律
    }
    int input;
    for (int i = 1; i <= n; ++i)
    {
        cin >> input;
        H[i].weight = input;
    }
}
```

3.哈夫曼树的构造算法：

```cpp
//1.传入哈夫曼树H和初始叶子结点数量n
//2.首先对哈夫曼树进行初始化
//3.从数组的n+1处开始，但最后2n处结束进行for循环
//4.在for循环内，首先挑选出两个最小的结点树的下标分配给i1和i2
//5.将i1和i2的权重全部赋给i，并对i1和i2的双亲赋值为i，i的孩子赋值为i1和i2
void CreatHuffman(HuffmanTree &H, const int n)
{
    //第一步：对哈夫曼树进行初始化
    InitHTree(H, n);
    //第二步：找出当前森林中最小的两棵树，创建新树，并让原来的两个树作为新树的孩子
    for (int i = n + 1; i < 2 * n; ++i)
    {
        int i1 = 0, i2 = 0;
        Select(H, i - 1, i1, i2);//重点是这个Select算法
        H[i].weight = H[i1].weight + H[i2].weight;//
        H[i1].parent = H[i2].parent = i;
        H[i].lchild = i1;
        H[i].rchild = i2;
    }
}
```



(没看懂，等学了vector容器的用法再看)4.构造算法中的Select算法实现：

```cpp
//1.传入哈夫曼树H，结点数量n，返回数组下标i1和i2
//2.构建容器vec
//3.如果传入的结点中双亲结点为0，则压栈
void Select(HuffmanTree &H, const int n, int &i1, int &i2)
{
    vector<int> vec;
    for (int i = 1; i <= n; ++i)
    {
        if (H[i].parent == 0)
        {
            vec.push_back(i);
        }
    }
    //找出最小的一个
    auto flag1 = vec.begin();
    for (auto it = vec.begin() + 1; it != vec.end(); ++it)
    {
        if (H[*it].weight < H[*flag1].weight)
        {
            flag1 = it;
        }
    }
    i1 = *flag1; //最小的元素下标
    vec.erase(flag1);
    auto flag2 = vec.begin();
    for (auto it = vec.begin() + 1; it != vec.end(); ++it)
    {
        if (H[*it].weight < H[*flag2].weight)
        {
            flag2 = it;
        }
    }
    i2 = *flag2; //第二小的元素的下标
}
```

### 6.7.4 哈夫曼编码

方法：

1.统计字符集中每个字符在电文中出现的平均概率(概率越大，要求编码越短)

2.利用哈夫曼树的特点：权越大的叶子离根越近，将每个字符的概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短

3.在哈夫曼树的每个分支上标0或1

结点的左分支标0，右分支标1

把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码

![4204055dcf675acaa51fc5f1766cf469](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/4204055dcf675acaa51fc5f1766cf469.png)

### 6.7.5 哈夫曼编码算法及应用

==没看懂==

```c++
//1.传入哈夫曼树H和叶子节点个数n
//2.对叶子节点进行编码
void HuffmanCode(HuffmanTree &H, const int n)
{
    //第一步：调用函数创建一个顺序存储结构的哈夫曼树，同上的函数一样
    CreatHuffman(H, n);
    //第二步：遍历哈夫曼树中每一个叶子结点，也即哈夫曼数组中的前n个元素
    for (int i = 1; i <= n; ++i)
    {
        int chd = i;
        int par = H[chd].parent;
        //自下而上得到哈夫曼编码，用栈来保存再合适不过了
        SqStack S;
        InitStack(S);
        while (par != 0)
        {
            H[par].lchild == chd ? /*0进栈*/ Push(S, 0) : /*1进栈*/ Push(S, 1);
            chd = par;
            par = H[chd].parent;
        }
        //出栈//黑框中打印编码
        while (!IsEmpty(S))
        {
            int out;
            Pop(S, out);
            cout << out;
        }
        cout << endl;
    }
}
```



# 七. 图

## 7.1 图的定义和基本术语

**1.图：**G=(V,E)		Graph = (Vertex,Edge)

V：顶点(数据元素)的==有穷非空==集合

E：边的==有穷==集合

**无向图：**每条边都是无方向的

**有向图：**每条边都是有方向的

![5f487cad956307a3cf4ac975d7129fc9](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/5f487cad956307a3cf4ac975d7129fc9.png)

**完全图：**任意两个点都有一条边相连

![6cae778a51fcc2e43b6f1de2ace63fe9](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6cae778a51fcc2e43b6f1de2ace63fe9.png)

**稀疏图：**有很少边或弧的图(e<nlogn)

**稠密图：**有较多边或弧的图

**网：**边/弧带权的图

**邻接：**有边/弧相连的两个顶点之间的关系

- 存在$(V_i,V_j)$,则称$V_i和V_j$互为邻接点，(==无向边==)
- 存在$<V_i,V_j>$,则称$V_i邻接到V_j$，$V_j邻接于V_i$，(==有向边==)，从$V_i指到V_j$

**关系(依附)：**边/弧与顶点之间的关系。

- 存在$(V_i,V_j)$/$<V_i,V_j>$，则称该边/弧关联于存在$V_i和V_j$



**2.顶点的度：**与该顶点相关联的边的数目，记为TD(v)

- 在有向图中，顶点的度等于该顶点的入度和出度之==和==
  - 顶点V的==入度==是以v为==终点==的有向边的条数，记作==ID(v)==
  - 顶点V的==出度==是以v为==始点==的有向边的条数，记作==OD(v)==

![b2fb6cbdf9cd63cf67c285dc45607db1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/b2fb6cbdf9cd63cf67c285dc45607db1.png)



**3.路径：**接续的边构成的顶点序列

**路径长度：**路径上边或弧的数目/权值之和

**回路(环)：**第一个顶点和最后一个顶点相同的路径

**简单路径：**除路径起点和终点可以相同外，其余顶点均不相同的路径

**简单回路(简单环)：**除路径起点和终点相同外，其余顶点均不相同的路径



![8866472be630213f2ca53b0db980f159](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/8866472be630213f2ca53b0db980f159.png)



4.**连通图(强连通图)：**在无/有向图G=(V,[E])中，若对任何两个顶点v、u都存在从v到u的路径，则称G是连通图(强连通图)

![a9bdd6a4fabb8ebd6d9a5c294a51d638](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a9bdd6a4fabb8ebd6d9a5c294a51d638.png)

**权与网：**图中边或弧所具有的相关数称为==权==，表明从一个顶点到另一个顶点的距离或耗费；带权的图称为==网==

**子图：**设有两个图 G = (V,{E})、G = (V1,{E1}),若V1属于V，E1属于E，则称G1是G的子图

![615431f9284e232a878bd88317e8601d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/615431f9284e232a878bd88317e8601d.png)

**连通分量(强连通分量)：**

- 无向图G的极大连通子图称为G的连通分量
  - 极大连通子图意思是：该子图是G连通子图，将G的任何不在该子图中的顶点加入，子图不再连通

- 有向图G的极大强连通子图称为G的强连通分量
  - 极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的

![f7684d66acc2146281d4e4f212c464bc](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/f7684d66acc2146281d4e4f212c464bc.png)



![6a5048ee39da0065eb7555d4f4832b45](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6a5048ee39da0065eb7555d4f4832b45.png)



**极小连通子图：**该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通

**生成树：**包含无向图G所有顶点的极小连通子图

**生成森林：**对非连通图，由各个连通分量的生成树的集合



![a8e9840b0d758b29f753ac51cd0bc04b](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a8e9840b0d758b29f753ac51cd0bc04b.png)





## 7.2 图的存储结构

图的逻辑结构：多对多

图没有顺序存储结构，但可以借助二维数组来表示元素间的关系：**数组表示法(邻接矩阵)**

链式存储结构：**多重链表(邻接表、邻接多重表、十字链表)**

### 7.2.1 邻接矩阵

**1.数组(邻接矩阵)表示法：**

建立一个==顶点表==(记录各个顶点信息)和一个==邻接矩阵==(表示各个顶点之间关系)

- 设图A=(V,E)有n个顶点，则顶点表可如下表示

![98abe74093e1c6f834e2ed07f988b625](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/98abe74093e1c6f834e2ed07f988b625.png)

- 图的邻接矩阵是一个二维数组A.arcs[n] [n]，定义为如下所示：

![002bbe34fe67a344fd33b21b3bcc459c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/002bbe34fe67a344fd33b21b3bcc459c.png)



**2.无向图的邻接矩阵表示法：**

![32b468ab71e258fee9eb393023d450e8](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/32b468ab71e258fee9eb393023d450e8.png)

注意：

- 无向图的邻接矩阵是==对称==的
- 顶点i的度=第i行(列)中1的个数
- ==完全图==的邻接矩阵中，对角元素为0，其余为1



**3.有向图的邻接矩阵表示法：**

![801df6f6137917a3b2a295fc3434d67d](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/801df6f6137917a3b2a295fc3434d67d.png)

- 有向图的邻接矩阵==可能是不对称的==
- 顶点的==出度===第i==行==元素之和
- 顶点的==入度===第i==列==元素之和
- 顶点的度：第i行元素之和==+==第i列元素之和



**4.网(即有权图)的邻接矩阵表示法：**

![1d795deb44dc900fbc8ed9ea1c4d1ad8](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/1d795deb44dc900fbc8ed9ea1c4d1ad8.png)



**5.邻接矩阵的存储结构代码：**

图的定义

~~~cpp
#define Maxlnt 32767	//表示极大值，即无穷
#define MVNum 100		//最大顶点数
typedef char VerTexType;	//设顶点的数据类型为字符型
typedef int ArcType;		//假设边的权值类型为整形

typedef struct AMGraph
{
    //图的顶点向量,即顶点表
    VerTexType vexs[MVNum];
    //图的邻接矩阵
    ArcType arcs[MVNum][MVNum];
    //图的当前点数和边数
    int vexnum, arcnum;
};
~~~

创建无向网

~~~cpp
//1.传入图G
//2.输入无向图的总顶点数和总边数
//3.对顶点表输入节点信息，并将其保存在一维数组verx[]中，即vi
//4.初始化邻接矩阵，即将二维数组的所有值设为无穷大
//5.通过for循环，对所有边进行赋权重weight，并输入一条边所依附的顶点及边的权值
//6.查找到a，b在G中的位置，并对其边进行赋权重

void CreatUDN(AMGraph &G)
{
    //第一步：输入无向图的顶点数目
    cout << "input num" << endl;
    cin >> G.vexnum >> G.arcnum; //输入总顶点数和总边数
    //第二步：输入结点的信息，保存在一维数组中
    cout << "input vexs" << endl;
    for (int i = 0; i < G.vexnum; ++i)
    {
        cin >> G.vexs[i];
    }
    //第三步：将邻接矩阵的元素值置为无穷大
    for (int i = 0; i < G.arcnum; ++i)
    {
        for (int j = 0; j < G.arcnum; ++j)
        {
            G.arcs[i][j] = MAXlnt;
        }
    }
    //第四步：输入顶点相互关系以及权重
    for (int k = 0; k < G.arcnum;++k)
    {
        int i, j, weight;
        VerTexType a, b;
        cin >> a >> b >> weight;
        //由输入的顶点a和b查找到对应的下标i,j
        i = LocateVex(G,a)
        j = LocateVex(G,b)
        G.arcs[i][j] = G.arcs[j][i] = weight;
    }
}
~~~

邻接矩阵的LocateVex函数

~~~cpp
//1.传入图表G和要查找的数值e
//2.在顶点最大数值内进行for循环查找是否有相同值
//3.如果有的话返回其坐标i；没有的话返回值-1

int LocateVex(AMGraph &G, const VerTexType &e)
{
    for (int i = 0; i < G.vexnum;++i)
    {
        if(G.vexs[i]==e)
            return i;
    }
    return -1;
}
~~~



**6.由无向网类比出其他的结构：**

![383b0ff4e4905d67eb395371df262a7c](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/383b0ff4e4905d67eb395371df262a7c.png)



**7.邻接矩阵的优缺点：**

- 优点：
  - 直观、简单、好理解
  - 方便检查任意一对顶点间是否存在边
  - 方便找任一顶点的所有“邻接点”
  - 方便计算任一顶点的度
- 缺点：
  - 不便于增加和删除顶点
  - 浪费空间——存稀疏图
  - 浪费时间——统计稀疏图中一共有多少条边





### 7.2.2 邻接表

**1.邻接表表示法(链式)：**

- 顶点(==头结点==)：按编号顺序将顶点数据存储在一维数组中
- 关联同一顶点的边(==表结点==)：用线性链表存储



![484ca180504d3e1d0d4a38a42e49a0b3](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/484ca180504d3e1d0d4a38a42e49a0b3.png)



**2.无向图：**



![411d40d53b5c584edbd1970708058aa5](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/411d40d53b5c584edbd1970708058aa5.png)

注意：

- 邻接表不唯一
- 若无向图中有n个顶点，e条边，则其邻接表需要==n+2e==个结点
- 无向图中顶点$V_i$的度为第i个单链表中的结点数



**3.有向图：**

![55024938d1296c9d73630e026d604ff0](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/55024938d1296c9d73630e026d604ff0.png)



注意：

- 可以使用出度表或入读表来显示图结构



**4.邻接表存储表示：**

定义

~~~cpp
//边表的定义
struct ArcNode
{
    int adjvex;       //保存顶点的下标
    int weight;       //保存边的权重
    ArcNode *nextarc; //指向下一个边结点
};

//顶点表的定义
struct VNode
{
    //数据域，存放顶点
    VecTexType data;
    //指针域，用于保存邻接表的
    ArcNode *firstarc;
};

//图的定义
struct ALGraph
{
    //定义一个数组，保存图的顶点
    VNode vexs[MAXSIZE];
    //定义两个变量，保存当前图的顶点个数以及边的条数
    int vexnum, arcnum;
};
~~~

邻接表的LocateVex函数

~~~cpp
int LocateVex(ALGraph &G, const char &v)
{
    for (int i = 0; i < G.vexnum; ++i)
    {
        if (G.vexs[i].data == v)
            return i;
    }
    return -1;
}
~~~

创建无向图算法

~~~cpp
//1.传入图G
//2.输入图的顶点个数和边的条数
//3.通过for循环，对图内的顶点数值域赋值，并将顶点的指针指向空
//4.通过for循环对顶点的边进行赋值
//5.输入各边的值，并对顶点中的相应坐标进行查找，并返回顶点坐标i和j
//6.通过指针p和q进行头插法完成边的插入,如果想完成有向图的建立，只需要删除q指针的操作即可

void CreatUDG(ALGraph &G)
{
    //第一步：输入图的顶点个数以及边的条数
    cout << "info" << endl;
    cin >> G.vexnum >> G.arcnum;
    //第二步：给顶点向量赋值
    for (int i = 0; i < G.vexnum; ++i)
    {
        cin >> G.vexs[i].data;
        G.vexs[i].firstarc = nullptr;
    }
    //给每个顶点所含的边赋值
    for (int j = 0; j < G.arcnum; ++j)
    {
        cout << "input info about arc" << endl;
        char a, b;
        //int w;
        cin >> a >> b;
        int i = LocateVex(G, a);
        int j = LocateVex(G, b);
        
        //申请动态内存
        ArcNode *p = new ArcNode;
        p->adjvex = j;
        //p->weight = w;
        p->nextarc = G.vexs[i].firstarc;
        G.vexs[i].firstarc = p;

        ArcNode *q = new ArcNode;
        q->adjvex = i;
        //q->weight = w;
        q->nextarc = G.vexs[j].firstarc;
        G.vexs[j].firstarc = q;
    }
}
~~~



**5.邻接表特点：**

- 方便找任一顶点的所有“邻接点”
- 节约稀疏图的空间
  - 需要N个头指针+2E个结点(每个结点至少2个域)
- 方便计算任一顶点的"度"
  - 对无向图：是的
  - 对有向图：只能计算"出度"；需要构造"逆邻接表"(存指向自己的边)来方便计算"入度"
- 不方便检查任意一对顶点间是否存在边



**6.邻接矩阵与邻接表表示法的关系：**

- 联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数
- 区别：对于任一确定的无向图，邻接矩阵是==唯一==的，但邻接表==不唯一==；邻接矩阵的空间复杂度为$O(n^2)$，而邻接表空间复杂度为$O(n+e)$

- 用途：邻接矩阵多用于稠密图；而邻接表多用于稀疏图



### 7.2.3 十字链表(有向图的另一种存储结构)

十字链表(Orthogonal List)是有向图的另一种链式存储结构，我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表

有向图中的每一条弧对应十字链表中的一个==弧结点==，同时有向图的每个顶点在十字链表中对应有一个结点，叫做==顶点结点==。

![df11240d33ead6d07be7c2246999a7dc](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/df11240d33ead6d07be7c2246999a7dc.png)



### 7.2.4 邻接多重表(无向图的另一种链式存储结构)



![6b6a47f1f5a1630a1fde1bcb3831dbd1](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/6b6a47f1f5a1630a1fde1bcb3831dbd1.png)





## 7.3 图的遍历

1.遍历定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历

2.遍历实质：找每个顶点的邻接点的过程

3.图的特点：图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问玩某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点

4.避免重复访问的思路：设置辅助数组visiser[n]，用来标记每个被访问过的顶点

- 初始状态visited[i]为0
- 顶点i被访问，改visited[i]为1，防止被多次访问





### 7.3.1 深度优先搜索(Depth_First Search——DFS)



![a4237b8a53207bd65f74fa6286a61b97](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/a4237b8a53207bd65f74fa6286a61b97.png)



![bc36655e6e278c842b091b8c9de8b0d4](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/bc36655e6e278c842b091b8c9de8b0d4.png)



**1.邻接矩阵表示图的深度优先搜索遍历：**

~~~cpp
//1.定义一个visited数组作标志
//2.传入图G和第一个顶点v的位置
//3.将顶点v输出，并将visited数组中对应的位置边为真，代表已经访问过了
//4.使用for循环开始遍历
//5.当邻接矩阵的边存在并且visited数组表示没有被访问过，进入遍历循环
int visited[MAXSIZE] = {};
void DFS_AM(AMGraph &G, int v)
{
    //输出图顶点的包含的内容
    //cout << v;
    cout << G.vexs[v];
    //标志数组visit对应的元素被访问了，要记为1
    visited[v] = 1;
    //从邻接矩阵的某一行的第1个元素开始-遍历到该行第n个元素
    for (int w = 0; w < G.vexnum; ++w)
    {
        //如果找到一个相连的顶点，并且该顶点还没有被访问过，进入递归函数
        if((G.arcs[v][w]!=0) && visited[w]==0)
        {
            DFS_AM(G, w);
        }
    }
    //算法时间复杂度O(n^2)
}
~~~



**2.邻接表表示图的深度优先搜索遍历：**

~~~cpp
int visited[MAXSIZE] = {};
void DFS_AL(ALGraph &G, int v)
{
    //访问v代表的顶点
    cout << G.vexs[v].data << endl;
    //访问之后，顶点标记为1
    visited[v] = 1;
    //访问该顶点之后的边结点
    ArcNode *p = G.vexs[v].firstarc;
    while (p != nullptr)
    {
        int i = p->adjvex;
        if (visited[i] == 0)
        {
            DFS_AL(G, i);
        }
        p = p->nextarc;
    }
}
~~~



### 7.3.2 广度优先搜索(Breadth_First Search)

![4f39a08286e39ce512dac9d2d4cef730](https://typora-picture-wang.oss-cn-shanghai.aliyuncs.com/4f39a08286e39ce512dac9d2d4cef730.png)





**1.邻接矩阵表示图的广度优先搜索遍历：**

==再研究研究吧，没看懂==

```c++
//1.传入图G，数据v，元素是否已被遍历数组visit
//2.初始化队列，并先令数据v入队
//3.令visit数组对应位置变为真，代表此位置的数据已经被遍历
//4.当队列非空时，将队头元素出队并赋给pop
//5.将出队元素输出

void BFS_AM(AMGraph *G, int v, bool *visit) 
{
	SqQueue Q;
	InitQueue(&Q);
	EntryQ(&Q, v);   //先让顶点入队
	visit[v] = true; //入队时设置visit状态
	int pop;         
	//用于接收队列弹出数据
	while (!IsEmpty(&Q)) 
    {
 		OutQ(&Q, &pop);
		printf("%c ", G->vertex[pop]); //出队时，打印
		for (int k = 0; k < G->vertices; ++k) 
        {
 			if (G->edge[pop][k] && !visit[k]) 
        	{
 			EntryQ(&Q, k);
 			visit[k] = true;
 		//! 设置visit状态，不可以放在printf后面，因为for循环可能造成重复入队
			}
 		}
 	}
}

void BFS_AMGraph(AMGraph *G, VertexType v) 
{
 	bool *visit = (bool *)malloc(sizeof(bool) * G->vertices); //为visit分配空间
	memset(visit, false, sizeof(bool) * G->vertices);         
	int index = Locate_vertex(G, v); //找到下标
	BFS_AM(G, index, visit);         
	//以此下标为顶点出发，遍历
	free(visit);
}
```





























